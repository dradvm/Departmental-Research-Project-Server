/**
 * Client
 **/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model Answer
 *
 */
export type Answer = $Result.DefaultSelection<Prisma.$AnswerPayload>;
/**
 * Model Cart
 *
 */
export type Cart = $Result.DefaultSelection<Prisma.$CartPayload>;
/**
 * Model Category
 *
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>;
/**
 * Model Certificate
 *
 */
export type Certificate = $Result.DefaultSelection<Prisma.$CertificatePayload>;
/**
 * Model Coupon
 *
 */
export type Coupon = $Result.DefaultSelection<Prisma.$CouponPayload>;
/**
 * Model CouponCourse
 *
 */
export type CouponCourse =
  $Result.DefaultSelection<Prisma.$CouponCoursePayload>;
/**
 * Model Course
 *
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>;
/**
 * Model CourseCategory
 *
 */
export type CourseCategory =
  $Result.DefaultSelection<Prisma.$CourseCategoryPayload>;
/**
 * Model CourseObjective
 *
 */
export type CourseObjective =
  $Result.DefaultSelection<Prisma.$CourseObjectivePayload>;
/**
 * Model Enrollment
 *
 */
export type Enrollment = $Result.DefaultSelection<Prisma.$EnrollmentPayload>;
/**
 * Model Follow
 *
 */
export type Follow = $Result.DefaultSelection<Prisma.$FollowPayload>;
/**
 * Model Lecture
 *
 */
export type Lecture = $Result.DefaultSelection<Prisma.$LecturePayload>;
/**
 * Model Message
 *
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>;
/**
 * Model Note
 *
 */
export type Note = $Result.DefaultSelection<Prisma.$NotePayload>;
/**
 * Model Notification
 *
 */
export type Notification =
  $Result.DefaultSelection<Prisma.$NotificationPayload>;
/**
 * Model NotificationReceiver
 *
 */
export type NotificationReceiver =
  $Result.DefaultSelection<Prisma.$NotificationReceiverPayload>;
/**
 * Model Payment
 *
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>;
/**
 * Model PaymentDetail
 *
 */
export type PaymentDetail =
  $Result.DefaultSelection<Prisma.$PaymentDetailPayload>;
/**
 * Model Question
 *
 */
export type Question = $Result.DefaultSelection<Prisma.$QuestionPayload>;
/**
 * Model Report
 *
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>;
/**
 * Model Review
 *
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>;
/**
 * Model Section
 *
 */
export type Section = $Result.DefaultSelection<Prisma.$SectionPayload>;
/**
 * Model StudyRemind
 *
 */
export type StudyRemind = $Result.DefaultSelection<Prisma.$StudyRemindPayload>;
/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model UserCertificate
 *
 */
export type UserCertificate =
  $Result.DefaultSelection<Prisma.$UserCertificatePayload>;
/**
 * Model UserCoupon
 *
 */
export type UserCoupon = $Result.DefaultSelection<Prisma.$UserCouponPayload>;
/**
 * Model Wishlist
 *
 */
export type Wishlist = $Result.DefaultSelection<Prisma.$WishlistPayload>;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Answers
 * const answers = await prisma.answer.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Answers
   * const answers = await prisma.answer.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent
    ) => void
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>
    ) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    }
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    'extends',
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.answer`: Exposes CRUD operations for the **Answer** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Answers
   * const answers = await prisma.answer.findMany()
   * ```
   */
  get answer(): Prisma.AnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cart`: Exposes CRUD operations for the **Cart** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Carts
   * const carts = await prisma.cart.findMany()
   * ```
   */
  get cart(): Prisma.CartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Categories
   * const categories = await prisma.category.findMany()
   * ```
   */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certificate`: Exposes CRUD operations for the **Certificate** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Certificates
   * const certificates = await prisma.certificate.findMany()
   * ```
   */
  get certificate(): Prisma.CertificateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coupon`: Exposes CRUD operations for the **Coupon** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Coupons
   * const coupons = await prisma.coupon.findMany()
   * ```
   */
  get coupon(): Prisma.CouponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.couponCourse`: Exposes CRUD operations for the **CouponCourse** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more CouponCourses
   * const couponCourses = await prisma.couponCourse.findMany()
   * ```
   */
  get couponCourse(): Prisma.CouponCourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Courses
   * const courses = await prisma.course.findMany()
   * ```
   */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseCategory`: Exposes CRUD operations for the **CourseCategory** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more CourseCategories
   * const courseCategories = await prisma.courseCategory.findMany()
   * ```
   */
  get courseCategory(): Prisma.CourseCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseObjective`: Exposes CRUD operations for the **CourseObjective** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more CourseObjectives
   * const courseObjectives = await prisma.courseObjective.findMany()
   * ```
   */
  get courseObjective(): Prisma.CourseObjectiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enrollment`: Exposes CRUD operations for the **Enrollment** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Enrollments
   * const enrollments = await prisma.enrollment.findMany()
   * ```
   */
  get enrollment(): Prisma.EnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.follow`: Exposes CRUD operations for the **Follow** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Follows
   * const follows = await prisma.follow.findMany()
   * ```
   */
  get follow(): Prisma.FollowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lecture`: Exposes CRUD operations for the **Lecture** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Lectures
   * const lectures = await prisma.lecture.findMany()
   * ```
   */
  get lecture(): Prisma.LectureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Messages
   * const messages = await prisma.message.findMany()
   * ```
   */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.note`: Exposes CRUD operations for the **Note** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Notes
   * const notes = await prisma.note.findMany()
   * ```
   */
  get note(): Prisma.NoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Notifications
   * const notifications = await prisma.notification.findMany()
   * ```
   */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationReceiver`: Exposes CRUD operations for the **NotificationReceiver** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more NotificationReceivers
   * const notificationReceivers = await prisma.notificationReceiver.findMany()
   * ```
   */
  get notificationReceiver(): Prisma.NotificationReceiverDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Payments
   * const payments = await prisma.payment.findMany()
   * ```
   */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentDetail`: Exposes CRUD operations for the **PaymentDetail** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more PaymentDetails
   * const paymentDetails = await prisma.paymentDetail.findMany()
   * ```
   */
  get paymentDetail(): Prisma.PaymentDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Questions
   * const questions = await prisma.question.findMany()
   * ```
   */
  get question(): Prisma.QuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Reports
   * const reports = await prisma.report.findMany()
   * ```
   */
  get report(): Prisma.ReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Reviews
   * const reviews = await prisma.review.findMany()
   * ```
   */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.section`: Exposes CRUD operations for the **Section** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Sections
   * const sections = await prisma.section.findMany()
   * ```
   */
  get section(): Prisma.SectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studyRemind`: Exposes CRUD operations for the **StudyRemind** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more StudyReminds
   * const studyReminds = await prisma.studyRemind.findMany()
   * ```
   */
  get studyRemind(): Prisma.StudyRemindDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userCertificate`: Exposes CRUD operations for the **UserCertificate** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserCertificates
   * const userCertificates = await prisma.userCertificate.findMany()
   * ```
   */
  get userCertificate(): Prisma.UserCertificateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userCoupon`: Exposes CRUD operations for the **UserCoupon** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserCoupons
   * const userCoupons = await prisma.userCoupon.findMany()
   * ```
   */
  get userCoupon(): Prisma.UserCouponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wishlist`: Exposes CRUD operations for the **Wishlist** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Wishlists
   * const wishlists = await prisma.wishlist.findMany()
   * ```
   */
  get wishlist(): Prisma.WishlistDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    Answer: 'Answer';
    Cart: 'Cart';
    Category: 'Category';
    Certificate: 'Certificate';
    Coupon: 'Coupon';
    CouponCourse: 'CouponCourse';
    Course: 'Course';
    CourseCategory: 'CourseCategory';
    CourseObjective: 'CourseObjective';
    Enrollment: 'Enrollment';
    Follow: 'Follow';
    Lecture: 'Lecture';
    Message: 'Message';
    Note: 'Note';
    Notification: 'Notification';
    NotificationReceiver: 'NotificationReceiver';
    Payment: 'Payment';
    PaymentDetail: 'PaymentDetail';
    Question: 'Question';
    Report: 'Report';
    Review: 'Review';
    Section: 'Section';
    StudyRemind: 'StudyRemind';
    User: 'User';
    UserCertificate: 'UserCertificate';
    UserCoupon: 'UserCoupon';
    Wishlist: 'Wishlist';
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<
      { extArgs: $Extensions.InternalArgs },
      $Utils.Record<string, any>
    > {
    returns: Prisma.TypeMap<
      this['params']['extArgs'],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | 'answer'
        | 'cart'
        | 'category'
        | 'certificate'
        | 'coupon'
        | 'couponCourse'
        | 'course'
        | 'courseCategory'
        | 'courseObjective'
        | 'enrollment'
        | 'follow'
        | 'lecture'
        | 'message'
        | 'note'
        | 'notification'
        | 'notificationReceiver'
        | 'payment'
        | 'paymentDetail'
        | 'question'
        | 'report'
        | 'review'
        | 'section'
        | 'studyRemind'
        | 'user'
        | 'userCertificate'
        | 'userCoupon'
        | 'wishlist';
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      Answer: {
        payload: Prisma.$AnswerPayload<ExtArgs>;
        fields: Prisma.AnswerFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AnswerFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AnswerFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>;
          };
          findFirst: {
            args: Prisma.AnswerFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AnswerFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>;
          };
          findMany: {
            args: Prisma.AnswerFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>[];
          };
          create: {
            args: Prisma.AnswerCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>;
          };
          createMany: {
            args: Prisma.AnswerCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.AnswerDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>;
          };
          update: {
            args: Prisma.AnswerUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>;
          };
          deleteMany: {
            args: Prisma.AnswerDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AnswerUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AnswerUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>;
          };
          aggregate: {
            args: Prisma.AnswerAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAnswer>;
          };
          groupBy: {
            args: Prisma.AnswerGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AnswerGroupByOutputType>[];
          };
          count: {
            args: Prisma.AnswerCountArgs<ExtArgs>;
            result: $Utils.Optional<AnswerCountAggregateOutputType> | number;
          };
        };
      };
      Cart: {
        payload: Prisma.$CartPayload<ExtArgs>;
        fields: Prisma.CartFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CartFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CartFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload>;
          };
          findFirst: {
            args: Prisma.CartFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CartFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload>;
          };
          findMany: {
            args: Prisma.CartFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[];
          };
          create: {
            args: Prisma.CartCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload>;
          };
          createMany: {
            args: Prisma.CartCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.CartDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload>;
          };
          update: {
            args: Prisma.CartUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload>;
          };
          deleteMany: {
            args: Prisma.CartDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CartUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CartUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload>;
          };
          aggregate: {
            args: Prisma.CartAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCart>;
          };
          groupBy: {
            args: Prisma.CartGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CartGroupByOutputType>[];
          };
          count: {
            args: Prisma.CartCountArgs<ExtArgs>;
            result: $Utils.Optional<CartCountAggregateOutputType> | number;
          };
        };
      };
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>;
        fields: Prisma.CategoryFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>;
          };
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>;
          };
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[];
          };
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>;
          };
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>;
          };
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>;
          };
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>;
          };
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCategory>;
          };
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CategoryGroupByOutputType>[];
          };
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>;
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number;
          };
        };
      };
      Certificate: {
        payload: Prisma.$CertificatePayload<ExtArgs>;
        fields: Prisma.CertificateFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CertificateFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CertificateFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>;
          };
          findFirst: {
            args: Prisma.CertificateFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CertificateFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>;
          };
          findMany: {
            args: Prisma.CertificateFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[];
          };
          create: {
            args: Prisma.CertificateCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>;
          };
          createMany: {
            args: Prisma.CertificateCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.CertificateDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>;
          };
          update: {
            args: Prisma.CertificateUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>;
          };
          deleteMany: {
            args: Prisma.CertificateDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CertificateUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CertificateUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>;
          };
          aggregate: {
            args: Prisma.CertificateAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCertificate>;
          };
          groupBy: {
            args: Prisma.CertificateGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CertificateGroupByOutputType>[];
          };
          count: {
            args: Prisma.CertificateCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<CertificateCountAggregateOutputType>
              | number;
          };
        };
      };
      Coupon: {
        payload: Prisma.$CouponPayload<ExtArgs>;
        fields: Prisma.CouponFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CouponFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CouponFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>;
          };
          findFirst: {
            args: Prisma.CouponFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CouponFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>;
          };
          findMany: {
            args: Prisma.CouponFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[];
          };
          create: {
            args: Prisma.CouponCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>;
          };
          createMany: {
            args: Prisma.CouponCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.CouponDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>;
          };
          update: {
            args: Prisma.CouponUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>;
          };
          deleteMany: {
            args: Prisma.CouponDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CouponUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CouponUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>;
          };
          aggregate: {
            args: Prisma.CouponAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCoupon>;
          };
          groupBy: {
            args: Prisma.CouponGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CouponGroupByOutputType>[];
          };
          count: {
            args: Prisma.CouponCountArgs<ExtArgs>;
            result: $Utils.Optional<CouponCountAggregateOutputType> | number;
          };
        };
      };
      CouponCourse: {
        payload: Prisma.$CouponCoursePayload<ExtArgs>;
        fields: Prisma.CouponCourseFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CouponCourseFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponCoursePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CouponCourseFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponCoursePayload>;
          };
          findFirst: {
            args: Prisma.CouponCourseFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponCoursePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CouponCourseFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponCoursePayload>;
          };
          findMany: {
            args: Prisma.CouponCourseFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponCoursePayload>[];
          };
          create: {
            args: Prisma.CouponCourseCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponCoursePayload>;
          };
          createMany: {
            args: Prisma.CouponCourseCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.CouponCourseDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponCoursePayload>;
          };
          update: {
            args: Prisma.CouponCourseUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponCoursePayload>;
          };
          deleteMany: {
            args: Prisma.CouponCourseDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CouponCourseUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CouponCourseUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponCoursePayload>;
          };
          aggregate: {
            args: Prisma.CouponCourseAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCouponCourse>;
          };
          groupBy: {
            args: Prisma.CouponCourseGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CouponCourseGroupByOutputType>[];
          };
          count: {
            args: Prisma.CouponCourseCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<CouponCourseCountAggregateOutputType>
              | number;
          };
        };
      };
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>;
        fields: Prisma.CourseFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>;
          };
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>;
          };
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[];
          };
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>;
          };
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>;
          };
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>;
          };
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>;
          };
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCourse>;
          };
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CourseGroupByOutputType>[];
          };
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>;
            result: $Utils.Optional<CourseCountAggregateOutputType> | number;
          };
        };
      };
      CourseCategory: {
        payload: Prisma.$CourseCategoryPayload<ExtArgs>;
        fields: Prisma.CourseCategoryFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CourseCategoryFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CourseCategoryFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload>;
          };
          findFirst: {
            args: Prisma.CourseCategoryFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CourseCategoryFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload>;
          };
          findMany: {
            args: Prisma.CourseCategoryFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload>[];
          };
          create: {
            args: Prisma.CourseCategoryCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload>;
          };
          createMany: {
            args: Prisma.CourseCategoryCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.CourseCategoryDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload>;
          };
          update: {
            args: Prisma.CourseCategoryUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload>;
          };
          deleteMany: {
            args: Prisma.CourseCategoryDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CourseCategoryUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CourseCategoryUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload>;
          };
          aggregate: {
            args: Prisma.CourseCategoryAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCourseCategory>;
          };
          groupBy: {
            args: Prisma.CourseCategoryGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CourseCategoryGroupByOutputType>[];
          };
          count: {
            args: Prisma.CourseCategoryCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<CourseCategoryCountAggregateOutputType>
              | number;
          };
        };
      };
      CourseObjective: {
        payload: Prisma.$CourseObjectivePayload<ExtArgs>;
        fields: Prisma.CourseObjectiveFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CourseObjectiveFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CourseObjectiveFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload>;
          };
          findFirst: {
            args: Prisma.CourseObjectiveFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CourseObjectiveFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload>;
          };
          findMany: {
            args: Prisma.CourseObjectiveFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload>[];
          };
          create: {
            args: Prisma.CourseObjectiveCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload>;
          };
          createMany: {
            args: Prisma.CourseObjectiveCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.CourseObjectiveDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload>;
          };
          update: {
            args: Prisma.CourseObjectiveUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload>;
          };
          deleteMany: {
            args: Prisma.CourseObjectiveDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CourseObjectiveUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CourseObjectiveUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload>;
          };
          aggregate: {
            args: Prisma.CourseObjectiveAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCourseObjective>;
          };
          groupBy: {
            args: Prisma.CourseObjectiveGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CourseObjectiveGroupByOutputType>[];
          };
          count: {
            args: Prisma.CourseObjectiveCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<CourseObjectiveCountAggregateOutputType>
              | number;
          };
        };
      };
      Enrollment: {
        payload: Prisma.$EnrollmentPayload<ExtArgs>;
        fields: Prisma.EnrollmentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.EnrollmentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.EnrollmentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>;
          };
          findFirst: {
            args: Prisma.EnrollmentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.EnrollmentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>;
          };
          findMany: {
            args: Prisma.EnrollmentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[];
          };
          create: {
            args: Prisma.EnrollmentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>;
          };
          createMany: {
            args: Prisma.EnrollmentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.EnrollmentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>;
          };
          update: {
            args: Prisma.EnrollmentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>;
          };
          deleteMany: {
            args: Prisma.EnrollmentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.EnrollmentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.EnrollmentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>;
          };
          aggregate: {
            args: Prisma.EnrollmentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateEnrollment>;
          };
          groupBy: {
            args: Prisma.EnrollmentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<EnrollmentGroupByOutputType>[];
          };
          count: {
            args: Prisma.EnrollmentCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<EnrollmentCountAggregateOutputType>
              | number;
          };
        };
      };
      Follow: {
        payload: Prisma.$FollowPayload<ExtArgs>;
        fields: Prisma.FollowFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FollowFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FollowFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>;
          };
          findFirst: {
            args: Prisma.FollowFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FollowFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>;
          };
          findMany: {
            args: Prisma.FollowFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[];
          };
          create: {
            args: Prisma.FollowCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>;
          };
          createMany: {
            args: Prisma.FollowCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.FollowDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>;
          };
          update: {
            args: Prisma.FollowUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>;
          };
          deleteMany: {
            args: Prisma.FollowDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FollowUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.FollowUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>;
          };
          aggregate: {
            args: Prisma.FollowAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFollow>;
          };
          groupBy: {
            args: Prisma.FollowGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FollowGroupByOutputType>[];
          };
          count: {
            args: Prisma.FollowCountArgs<ExtArgs>;
            result: $Utils.Optional<FollowCountAggregateOutputType> | number;
          };
        };
      };
      Lecture: {
        payload: Prisma.$LecturePayload<ExtArgs>;
        fields: Prisma.LectureFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.LectureFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.LectureFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>;
          };
          findFirst: {
            args: Prisma.LectureFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.LectureFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>;
          };
          findMany: {
            args: Prisma.LectureFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>[];
          };
          create: {
            args: Prisma.LectureCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>;
          };
          createMany: {
            args: Prisma.LectureCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.LectureDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>;
          };
          update: {
            args: Prisma.LectureUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>;
          };
          deleteMany: {
            args: Prisma.LectureDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.LectureUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.LectureUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>;
          };
          aggregate: {
            args: Prisma.LectureAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLecture>;
          };
          groupBy: {
            args: Prisma.LectureGroupByArgs<ExtArgs>;
            result: $Utils.Optional<LectureGroupByOutputType>[];
          };
          count: {
            args: Prisma.LectureCountArgs<ExtArgs>;
            result: $Utils.Optional<LectureCountAggregateOutputType> | number;
          };
        };
      };
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>;
        fields: Prisma.MessageFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>;
          };
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>;
          };
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[];
          };
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>;
          };
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>;
          };
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>;
          };
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>;
          };
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMessage>;
          };
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MessageGroupByOutputType>[];
          };
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>;
            result: $Utils.Optional<MessageCountAggregateOutputType> | number;
          };
        };
      };
      Note: {
        payload: Prisma.$NotePayload<ExtArgs>;
        fields: Prisma.NoteFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NoteFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NoteFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotePayload>;
          };
          findFirst: {
            args: Prisma.NoteFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NoteFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotePayload>;
          };
          findMany: {
            args: Prisma.NoteFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[];
          };
          create: {
            args: Prisma.NoteCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotePayload>;
          };
          createMany: {
            args: Prisma.NoteCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.NoteDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotePayload>;
          };
          update: {
            args: Prisma.NoteUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotePayload>;
          };
          deleteMany: {
            args: Prisma.NoteDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NoteUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.NoteUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotePayload>;
          };
          aggregate: {
            args: Prisma.NoteAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNote>;
          };
          groupBy: {
            args: Prisma.NoteGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NoteGroupByOutputType>[];
          };
          count: {
            args: Prisma.NoteCountArgs<ExtArgs>;
            result: $Utils.Optional<NoteCountAggregateOutputType> | number;
          };
        };
      };
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>;
        fields: Prisma.NotificationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotification>;
          };
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<NotificationCountAggregateOutputType>
              | number;
          };
        };
      };
      NotificationReceiver: {
        payload: Prisma.$NotificationReceiverPayload<ExtArgs>;
        fields: Prisma.NotificationReceiverFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationReceiverFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationReceiverPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationReceiverFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationReceiverPayload>;
          };
          findFirst: {
            args: Prisma.NotificationReceiverFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationReceiverPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationReceiverFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationReceiverPayload>;
          };
          findMany: {
            args: Prisma.NotificationReceiverFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationReceiverPayload>[];
          };
          create: {
            args: Prisma.NotificationReceiverCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationReceiverPayload>;
          };
          createMany: {
            args: Prisma.NotificationReceiverCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.NotificationReceiverDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationReceiverPayload>;
          };
          update: {
            args: Prisma.NotificationReceiverUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationReceiverPayload>;
          };
          deleteMany: {
            args: Prisma.NotificationReceiverDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationReceiverUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.NotificationReceiverUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationReceiverPayload>;
          };
          aggregate: {
            args: Prisma.NotificationReceiverAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotificationReceiver>;
          };
          groupBy: {
            args: Prisma.NotificationReceiverGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationReceiverGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationReceiverCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<NotificationReceiverCountAggregateOutputType>
              | number;
          };
        };
      };
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>;
        fields: Prisma.PaymentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[];
          };
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePayment>;
          };
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PaymentGroupByOutputType>[];
          };
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>;
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number;
          };
        };
      };
      PaymentDetail: {
        payload: Prisma.$PaymentDetailPayload<ExtArgs>;
        fields: Prisma.PaymentDetailFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PaymentDetailFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PaymentDetailFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload>;
          };
          findFirst: {
            args: Prisma.PaymentDetailFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PaymentDetailFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload>;
          };
          findMany: {
            args: Prisma.PaymentDetailFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload>[];
          };
          create: {
            args: Prisma.PaymentDetailCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload>;
          };
          createMany: {
            args: Prisma.PaymentDetailCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.PaymentDetailDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload>;
          };
          update: {
            args: Prisma.PaymentDetailUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload>;
          };
          deleteMany: {
            args: Prisma.PaymentDetailDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PaymentDetailUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.PaymentDetailUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload>;
          };
          aggregate: {
            args: Prisma.PaymentDetailAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePaymentDetail>;
          };
          groupBy: {
            args: Prisma.PaymentDetailGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PaymentDetailGroupByOutputType>[];
          };
          count: {
            args: Prisma.PaymentDetailCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<PaymentDetailCountAggregateOutputType>
              | number;
          };
        };
      };
      Question: {
        payload: Prisma.$QuestionPayload<ExtArgs>;
        fields: Prisma.QuestionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.QuestionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.QuestionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>;
          };
          findFirst: {
            args: Prisma.QuestionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.QuestionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>;
          };
          findMany: {
            args: Prisma.QuestionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[];
          };
          create: {
            args: Prisma.QuestionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>;
          };
          createMany: {
            args: Prisma.QuestionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.QuestionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>;
          };
          update: {
            args: Prisma.QuestionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>;
          };
          deleteMany: {
            args: Prisma.QuestionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.QuestionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.QuestionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>;
          };
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateQuestion>;
          };
          groupBy: {
            args: Prisma.QuestionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<QuestionGroupByOutputType>[];
          };
          count: {
            args: Prisma.QuestionCountArgs<ExtArgs>;
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number;
          };
        };
      };
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>;
        fields: Prisma.ReportFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>;
          };
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>;
          };
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[];
          };
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>;
          };
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>;
          };
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>;
          };
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>;
          };
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateReport>;
          };
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ReportGroupByOutputType>[];
          };
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>;
            result: $Utils.Optional<ReportCountAggregateOutputType> | number;
          };
        };
      };
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>;
        fields: Prisma.ReviewFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[];
          };
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateReview>;
          };
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ReviewGroupByOutputType>[];
          };
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>;
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number;
          };
        };
      };
      Section: {
        payload: Prisma.$SectionPayload<ExtArgs>;
        fields: Prisma.SectionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SectionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SectionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>;
          };
          findFirst: {
            args: Prisma.SectionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SectionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>;
          };
          findMany: {
            args: Prisma.SectionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[];
          };
          create: {
            args: Prisma.SectionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>;
          };
          createMany: {
            args: Prisma.SectionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.SectionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>;
          };
          update: {
            args: Prisma.SectionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>;
          };
          deleteMany: {
            args: Prisma.SectionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SectionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.SectionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>;
          };
          aggregate: {
            args: Prisma.SectionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSection>;
          };
          groupBy: {
            args: Prisma.SectionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SectionGroupByOutputType>[];
          };
          count: {
            args: Prisma.SectionCountArgs<ExtArgs>;
            result: $Utils.Optional<SectionCountAggregateOutputType> | number;
          };
        };
      };
      StudyRemind: {
        payload: Prisma.$StudyRemindPayload<ExtArgs>;
        fields: Prisma.StudyRemindFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.StudyRemindFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudyRemindPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.StudyRemindFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudyRemindPayload>;
          };
          findFirst: {
            args: Prisma.StudyRemindFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudyRemindPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.StudyRemindFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudyRemindPayload>;
          };
          findMany: {
            args: Prisma.StudyRemindFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudyRemindPayload>[];
          };
          create: {
            args: Prisma.StudyRemindCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudyRemindPayload>;
          };
          createMany: {
            args: Prisma.StudyRemindCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.StudyRemindDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudyRemindPayload>;
          };
          update: {
            args: Prisma.StudyRemindUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudyRemindPayload>;
          };
          deleteMany: {
            args: Prisma.StudyRemindDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.StudyRemindUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.StudyRemindUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudyRemindPayload>;
          };
          aggregate: {
            args: Prisma.StudyRemindAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateStudyRemind>;
          };
          groupBy: {
            args: Prisma.StudyRemindGroupByArgs<ExtArgs>;
            result: $Utils.Optional<StudyRemindGroupByOutputType>[];
          };
          count: {
            args: Prisma.StudyRemindCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<StudyRemindCountAggregateOutputType>
              | number;
          };
        };
      };
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      UserCertificate: {
        payload: Prisma.$UserCertificatePayload<ExtArgs>;
        fields: Prisma.UserCertificateFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserCertificateFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserCertificatePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserCertificateFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserCertificatePayload>;
          };
          findFirst: {
            args: Prisma.UserCertificateFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserCertificatePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserCertificateFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserCertificatePayload>;
          };
          findMany: {
            args: Prisma.UserCertificateFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserCertificatePayload>[];
          };
          create: {
            args: Prisma.UserCertificateCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserCertificatePayload>;
          };
          createMany: {
            args: Prisma.UserCertificateCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.UserCertificateDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserCertificatePayload>;
          };
          update: {
            args: Prisma.UserCertificateUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserCertificatePayload>;
          };
          deleteMany: {
            args: Prisma.UserCertificateDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserCertificateUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.UserCertificateUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserCertificatePayload>;
          };
          aggregate: {
            args: Prisma.UserCertificateAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUserCertificate>;
          };
          groupBy: {
            args: Prisma.UserCertificateGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserCertificateGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCertificateCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<UserCertificateCountAggregateOutputType>
              | number;
          };
        };
      };
      UserCoupon: {
        payload: Prisma.$UserCouponPayload<ExtArgs>;
        fields: Prisma.UserCouponFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserCouponFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserCouponFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>;
          };
          findFirst: {
            args: Prisma.UserCouponFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserCouponFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>;
          };
          findMany: {
            args: Prisma.UserCouponFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>[];
          };
          create: {
            args: Prisma.UserCouponCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>;
          };
          createMany: {
            args: Prisma.UserCouponCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.UserCouponDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>;
          };
          update: {
            args: Prisma.UserCouponUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>;
          };
          deleteMany: {
            args: Prisma.UserCouponDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserCouponUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.UserCouponUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>;
          };
          aggregate: {
            args: Prisma.UserCouponAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUserCoupon>;
          };
          groupBy: {
            args: Prisma.UserCouponGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserCouponGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCouponCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<UserCouponCountAggregateOutputType>
              | number;
          };
        };
      };
      Wishlist: {
        payload: Prisma.$WishlistPayload<ExtArgs>;
        fields: Prisma.WishlistFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.WishlistFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.WishlistFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>;
          };
          findFirst: {
            args: Prisma.WishlistFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.WishlistFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>;
          };
          findMany: {
            args: Prisma.WishlistFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>[];
          };
          create: {
            args: Prisma.WishlistCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>;
          };
          createMany: {
            args: Prisma.WishlistCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.WishlistDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>;
          };
          update: {
            args: Prisma.WishlistUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>;
          };
          deleteMany: {
            args: Prisma.WishlistDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.WishlistUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.WishlistUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>;
          };
          aggregate: {
            args: Prisma.WishlistAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateWishlist>;
          };
          groupBy: {
            args: Prisma.WishlistGroupByArgs<ExtArgs>;
            result: $Utils.Optional<WishlistGroupByOutputType>[];
          };
          count: {
            args: Prisma.WishlistCountArgs<ExtArgs>;
            result: $Utils.Optional<WishlistCountAggregateOutputType> | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    answer?: AnswerOmit;
    cart?: CartOmit;
    category?: CategoryOmit;
    certificate?: CertificateOmit;
    coupon?: CouponOmit;
    couponCourse?: CouponCourseOmit;
    course?: CourseOmit;
    courseCategory?: CourseCategoryOmit;
    courseObjective?: CourseObjectiveOmit;
    enrollment?: EnrollmentOmit;
    follow?: FollowOmit;
    lecture?: LectureOmit;
    message?: MessageOmit;
    note?: NoteOmit;
    notification?: NotificationOmit;
    notificationReceiver?: NotificationReceiverOmit;
    payment?: PaymentOmit;
    paymentDetail?: PaymentDetailOmit;
    question?: QuestionOmit;
    report?: ReportOmit;
    review?: ReviewOmit;
    section?: SectionOmit;
    studyRemind?: StudyRemindOmit;
    user?: UserOmit;
    userCertificate?: UserCertificateOmit;
    userCoupon?: UserCouponOmit;
    wishlist?: WishlistOmit;
  };

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error';
  export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
  };

  export type GetLogType<T extends LogLevel | LogDefinition> =
    T extends LogDefinition
      ? T['emit'] extends 'event'
        ? T['level']
        : never
      : never;
  export type GetEvents<T extends any> =
    T extends Array<LogLevel | LogDefinition>
      ?
          | GetLogType<T[0]>
          | GetLogType<T[1]>
          | GetLogType<T[2]>
          | GetLogType<T[3]>
      : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy';

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName;
    action: PrismaAction;
    args: any;
    dataPath: string[];
    runInTransaction: boolean;
  };

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>
  ) => $Utils.JsPromise<T>;

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    CourseCategory: number;
  };

  export type CategoryCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    CourseCategory?: boolean | CategoryCountOutputTypeCountCourseCategoryArgs;
  };

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountCourseCategoryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CourseCategoryWhereInput;
  };

  /**
   * Count Type CertificateCountOutputType
   */

  export type CertificateCountOutputType = {
    UserCertificate: number;
  };

  export type CertificateCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    UserCertificate?:
      | boolean
      | CertificateCountOutputTypeCountUserCertificateArgs;
  };

  // Custom InputTypes
  /**
   * CertificateCountOutputType without action
   */
  export type CertificateCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CertificateCountOutputType
     */
    select?: CertificateCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CertificateCountOutputType without action
   */
  export type CertificateCountOutputTypeCountUserCertificateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: UserCertificateWhereInput;
  };

  /**
   * Count Type CouponCountOutputType
   */

  export type CouponCountOutputType = {
    CouponCourse: number;
    UserCoupon: number;
  };

  export type CouponCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    CouponCourse?: boolean | CouponCountOutputTypeCountCouponCourseArgs;
    UserCoupon?: boolean | CouponCountOutputTypeCountUserCouponArgs;
  };

  // Custom InputTypes
  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CouponCountOutputType
     */
    select?: CouponCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeCountCouponCourseArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CouponCourseWhereInput;
  };

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeCountUserCouponArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: UserCouponWhereInput;
  };

  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    Cart: number;
    CouponCourse: number;
    CourseCategory: number;
    CourseObjective: number;
    Enrollment: number;
    PaymentDetail: number;
    Review: number;
    Section: number;
    StudyRemind: number;
    Wishlist: number;
  };

  export type CourseCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Cart?: boolean | CourseCountOutputTypeCountCartArgs;
    CouponCourse?: boolean | CourseCountOutputTypeCountCouponCourseArgs;
    CourseCategory?: boolean | CourseCountOutputTypeCountCourseCategoryArgs;
    CourseObjective?: boolean | CourseCountOutputTypeCountCourseObjectiveArgs;
    Enrollment?: boolean | CourseCountOutputTypeCountEnrollmentArgs;
    PaymentDetail?: boolean | CourseCountOutputTypeCountPaymentDetailArgs;
    Review?: boolean | CourseCountOutputTypeCountReviewArgs;
    Section?: boolean | CourseCountOutputTypeCountSectionArgs;
    StudyRemind?: boolean | CourseCountOutputTypeCountStudyRemindArgs;
    Wishlist?: boolean | CourseCountOutputTypeCountWishlistArgs;
  };

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCartArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CartWhereInput;
  };

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCouponCourseArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CouponCourseWhereInput;
  };

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCourseCategoryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CourseCategoryWhereInput;
  };

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCourseObjectiveArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CourseObjectiveWhereInput;
  };

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountEnrollmentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: EnrollmentWhereInput;
  };

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountPaymentDetailArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: PaymentDetailWhereInput;
  };

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountReviewArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ReviewWhereInput;
  };

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountSectionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: SectionWhereInput;
  };

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountStudyRemindArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: StudyRemindWhereInput;
  };

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountWishlistArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: WishlistWhereInput;
  };

  /**
   * Count Type LectureCountOutputType
   */

  export type LectureCountOutputType = {
    Note: number;
    Question: number;
  };

  export type LectureCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Note?: boolean | LectureCountOutputTypeCountNoteArgs;
    Question?: boolean | LectureCountOutputTypeCountQuestionArgs;
  };

  // Custom InputTypes
  /**
   * LectureCountOutputType without action
   */
  export type LectureCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LectureCountOutputType
     */
    select?: LectureCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * LectureCountOutputType without action
   */
  export type LectureCountOutputTypeCountNoteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: NoteWhereInput;
  };

  /**
   * LectureCountOutputType without action
   */
  export type LectureCountOutputTypeCountQuestionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: QuestionWhereInput;
  };

  /**
   * Count Type NotificationCountOutputType
   */

  export type NotificationCountOutputType = {
    NotificationReceiver: number;
  };

  export type NotificationCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    NotificationReceiver?:
      | boolean
      | NotificationCountOutputTypeCountNotificationReceiverArgs;
  };

  // Custom InputTypes
  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the NotificationCountOutputType
     */
    select?: NotificationCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeCountNotificationReceiverArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: NotificationReceiverWhereInput;
  };

  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    PaymentDetail: number;
  };

  export type PaymentCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    PaymentDetail?: boolean | PaymentCountOutputTypeCountPaymentDetailArgs;
  };

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountPaymentDetailArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: PaymentDetailWhereInput;
  };

  /**
   * Count Type QuestionCountOutputType
   */

  export type QuestionCountOutputType = {
    Answer: number;
  };

  export type QuestionCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Answer?: boolean | QuestionCountOutputTypeCountAnswerArgs;
  };

  // Custom InputTypes
  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the QuestionCountOutputType
     */
    select?: QuestionCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountAnswerArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: AnswerWhereInput;
  };

  /**
   * Count Type SectionCountOutputType
   */

  export type SectionCountOutputType = {
    Lecture: number;
  };

  export type SectionCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Lecture?: boolean | SectionCountOutputTypeCountLectureArgs;
  };

  // Custom InputTypes
  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the SectionCountOutputType
     */
    select?: SectionCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountLectureArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: LectureWhereInput;
  };

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Answer: number;
    Cart: number;
    Coupon: number;
    Course: number;
    Enrollment: number;
    Follow_Follow_idFollowerToUser: number;
    Follow_Follow_idFollowingToUser: number;
    Message_Message_idUserReceiverToUser: number;
    Message_Message_idUserSenderToUser: number;
    Note: number;
    Notification: number;
    NotificationReceiver: number;
    Payment: number;
    Question: number;
    Report: number;
    Review: number;
    StudyRemind: number;
    UserCertificate: number;
    UserCoupon: number;
    Wishlist: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Answer?: boolean | UserCountOutputTypeCountAnswerArgs;
    Cart?: boolean | UserCountOutputTypeCountCartArgs;
    Coupon?: boolean | UserCountOutputTypeCountCouponArgs;
    Course?: boolean | UserCountOutputTypeCountCourseArgs;
    Enrollment?: boolean | UserCountOutputTypeCountEnrollmentArgs;
    Follow_Follow_idFollowerToUser?:
      | boolean
      | UserCountOutputTypeCountFollow_Follow_idFollowerToUserArgs;
    Follow_Follow_idFollowingToUser?:
      | boolean
      | UserCountOutputTypeCountFollow_Follow_idFollowingToUserArgs;
    Message_Message_idUserReceiverToUser?:
      | boolean
      | UserCountOutputTypeCountMessage_Message_idUserReceiverToUserArgs;
    Message_Message_idUserSenderToUser?:
      | boolean
      | UserCountOutputTypeCountMessage_Message_idUserSenderToUserArgs;
    Note?: boolean | UserCountOutputTypeCountNoteArgs;
    Notification?: boolean | UserCountOutputTypeCountNotificationArgs;
    NotificationReceiver?:
      | boolean
      | UserCountOutputTypeCountNotificationReceiverArgs;
    Payment?: boolean | UserCountOutputTypeCountPaymentArgs;
    Question?: boolean | UserCountOutputTypeCountQuestionArgs;
    Report?: boolean | UserCountOutputTypeCountReportArgs;
    Review?: boolean | UserCountOutputTypeCountReviewArgs;
    StudyRemind?: boolean | UserCountOutputTypeCountStudyRemindArgs;
    UserCertificate?: boolean | UserCountOutputTypeCountUserCertificateArgs;
    UserCoupon?: boolean | UserCountOutputTypeCountUserCouponArgs;
    Wishlist?: boolean | UserCountOutputTypeCountWishlistArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnswerArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: AnswerWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCartArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CartWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCouponArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CouponWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCourseArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CourseWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEnrollmentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: EnrollmentWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollow_Follow_idFollowerToUserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: FollowWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollow_Follow_idFollowingToUserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: FollowWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessage_Message_idUserReceiverToUserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: MessageWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessage_Message_idUserSenderToUserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: MessageWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNoteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: NoteWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: NotificationWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationReceiverArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: NotificationReceiverWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: PaymentWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuestionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: QuestionWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ReportWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ReviewWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStudyRemindArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: StudyRemindWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserCertificateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: UserCertificateWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserCouponArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: UserCouponWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWishlistArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: WishlistWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model Answer
   */

  export type AggregateAnswer = {
    _count: AnswerCountAggregateOutputType | null;
    _avg: AnswerAvgAggregateOutputType | null;
    _sum: AnswerSumAggregateOutputType | null;
    _min: AnswerMinAggregateOutputType | null;
    _max: AnswerMaxAggregateOutputType | null;
  };

  export type AnswerAvgAggregateOutputType = {
    idQuestion: number | null;
    idAnswer: number | null;
    idUser: number | null;
  };

  export type AnswerSumAggregateOutputType = {
    idQuestion: number | null;
    idAnswer: number | null;
    idUser: number | null;
  };

  export type AnswerMinAggregateOutputType = {
    idQuestion: number | null;
    idAnswer: number | null;
    idUser: number | null;
    contentAnswer: string | null;
  };

  export type AnswerMaxAggregateOutputType = {
    idQuestion: number | null;
    idAnswer: number | null;
    idUser: number | null;
    contentAnswer: string | null;
  };

  export type AnswerCountAggregateOutputType = {
    idQuestion: number;
    idAnswer: number;
    idUser: number;
    contentAnswer: number;
    _all: number;
  };

  export type AnswerAvgAggregateInputType = {
    idQuestion?: true;
    idAnswer?: true;
    idUser?: true;
  };

  export type AnswerSumAggregateInputType = {
    idQuestion?: true;
    idAnswer?: true;
    idUser?: true;
  };

  export type AnswerMinAggregateInputType = {
    idQuestion?: true;
    idAnswer?: true;
    idUser?: true;
    contentAnswer?: true;
  };

  export type AnswerMaxAggregateInputType = {
    idQuestion?: true;
    idAnswer?: true;
    idUser?: true;
    contentAnswer?: true;
  };

  export type AnswerCountAggregateInputType = {
    idQuestion?: true;
    idAnswer?: true;
    idUser?: true;
    contentAnswer?: true;
    _all?: true;
  };

  export type AnswerAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Answer to aggregate.
     */
    where?: AnswerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AnswerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Answers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Answers
     **/
    _count?: true | AnswerCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AnswerAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AnswerSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AnswerMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AnswerMaxAggregateInputType;
  };

  export type GetAnswerAggregateType<T extends AnswerAggregateArgs> = {
    [P in keyof T & keyof AggregateAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswer[P]>
      : GetScalarType<T[P], AggregateAnswer[P]>;
  };

  export type AnswerGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: AnswerWhereInput;
    orderBy?:
      | AnswerOrderByWithAggregationInput
      | AnswerOrderByWithAggregationInput[];
    by: AnswerScalarFieldEnum[] | AnswerScalarFieldEnum;
    having?: AnswerScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AnswerCountAggregateInputType | true;
    _avg?: AnswerAvgAggregateInputType;
    _sum?: AnswerSumAggregateInputType;
    _min?: AnswerMinAggregateInputType;
    _max?: AnswerMaxAggregateInputType;
  };

  export type AnswerGroupByOutputType = {
    idQuestion: number;
    idAnswer: number;
    idUser: number | null;
    contentAnswer: string | null;
    _count: AnswerCountAggregateOutputType | null;
    _avg: AnswerAvgAggregateOutputType | null;
    _sum: AnswerSumAggregateOutputType | null;
    _min: AnswerMinAggregateOutputType | null;
    _max: AnswerMaxAggregateOutputType | null;
  };

  type GetAnswerGroupByPayload<T extends AnswerGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AnswerGroupByOutputType, T['by']> & {
          [P in keyof T & keyof AnswerGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnswerGroupByOutputType[P]>
            : GetScalarType<T[P], AnswerGroupByOutputType[P]>;
        }
      >
    >;

  export type AnswerSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idQuestion?: boolean;
      idAnswer?: boolean;
      idUser?: boolean;
      contentAnswer?: boolean;
      Question?: boolean | QuestionDefaultArgs<ExtArgs>;
      User?: boolean | Answer$UserArgs<ExtArgs>;
    },
    ExtArgs['result']['answer']
  >;

  export type AnswerSelectScalar = {
    idQuestion?: boolean;
    idAnswer?: boolean;
    idUser?: boolean;
    contentAnswer?: boolean;
  };

  export type AnswerOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idQuestion' | 'idAnswer' | 'idUser' | 'contentAnswer',
    ExtArgs['result']['answer']
  >;
  export type AnswerInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Question?: boolean | QuestionDefaultArgs<ExtArgs>;
    User?: boolean | Answer$UserArgs<ExtArgs>;
  };

  export type $AnswerPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Answer';
    objects: {
      Question: Prisma.$QuestionPayload<ExtArgs>;
      User: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idQuestion: number;
        idAnswer: number;
        idUser: number | null;
        contentAnswer: string | null;
      },
      ExtArgs['result']['answer']
    >;
    composites: {};
  };

  type AnswerGetPayload<
    S extends boolean | null | undefined | AnswerDefaultArgs
  > = $Result.GetResult<Prisma.$AnswerPayload, S>;

  type AnswerCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<AnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: AnswerCountAggregateInputType | true;
  };

  export interface AnswerDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Answer'];
      meta: { name: 'Answer' };
    };
    /**
     * Find zero or one Answer that matches the filter.
     * @param {AnswerFindUniqueArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnswerFindUniqueArgs>(
      args: SelectSubset<T, AnswerFindUniqueArgs<ExtArgs>>
    ): Prisma__AnswerClient<
      $Result.GetResult<
        Prisma.$AnswerPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Answer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnswerFindUniqueOrThrowArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnswerFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AnswerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AnswerClient<
      $Result.GetResult<
        Prisma.$AnswerPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Answer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindFirstArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnswerFindFirstArgs>(
      args?: SelectSubset<T, AnswerFindFirstArgs<ExtArgs>>
    ): Prisma__AnswerClient<
      $Result.GetResult<
        Prisma.$AnswerPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Answer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindFirstOrThrowArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnswerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AnswerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AnswerClient<
      $Result.GetResult<
        Prisma.$AnswerPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Answers
     * const answers = await prisma.answer.findMany()
     *
     * // Get first 10 Answers
     * const answers = await prisma.answer.findMany({ take: 10 })
     *
     * // Only select the `idQuestion`
     * const answerWithIdQuestionOnly = await prisma.answer.findMany({ select: { idQuestion: true } })
     *
     */
    findMany<T extends AnswerFindManyArgs>(
      args?: SelectSubset<T, AnswerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AnswerPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Answer.
     * @param {AnswerCreateArgs} args - Arguments to create a Answer.
     * @example
     * // Create one Answer
     * const Answer = await prisma.answer.create({
     *   data: {
     *     // ... data to create a Answer
     *   }
     * })
     *
     */
    create<T extends AnswerCreateArgs>(
      args: SelectSubset<T, AnswerCreateArgs<ExtArgs>>
    ): Prisma__AnswerClient<
      $Result.GetResult<
        Prisma.$AnswerPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Answers.
     * @param {AnswerCreateManyArgs} args - Arguments to create many Answers.
     * @example
     * // Create many Answers
     * const answer = await prisma.answer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AnswerCreateManyArgs>(
      args?: SelectSubset<T, AnswerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Answer.
     * @param {AnswerDeleteArgs} args - Arguments to delete one Answer.
     * @example
     * // Delete one Answer
     * const Answer = await prisma.answer.delete({
     *   where: {
     *     // ... filter to delete one Answer
     *   }
     * })
     *
     */
    delete<T extends AnswerDeleteArgs>(
      args: SelectSubset<T, AnswerDeleteArgs<ExtArgs>>
    ): Prisma__AnswerClient<
      $Result.GetResult<
        Prisma.$AnswerPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Answer.
     * @param {AnswerUpdateArgs} args - Arguments to update one Answer.
     * @example
     * // Update one Answer
     * const answer = await prisma.answer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AnswerUpdateArgs>(
      args: SelectSubset<T, AnswerUpdateArgs<ExtArgs>>
    ): Prisma__AnswerClient<
      $Result.GetResult<
        Prisma.$AnswerPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Answers.
     * @param {AnswerDeleteManyArgs} args - Arguments to filter Answers to delete.
     * @example
     * // Delete a few Answers
     * const { count } = await prisma.answer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AnswerDeleteManyArgs>(
      args?: SelectSubset<T, AnswerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Answers
     * const answer = await prisma.answer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AnswerUpdateManyArgs>(
      args: SelectSubset<T, AnswerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Answer.
     * @param {AnswerUpsertArgs} args - Arguments to update or create a Answer.
     * @example
     * // Update or create a Answer
     * const answer = await prisma.answer.upsert({
     *   create: {
     *     // ... data to create a Answer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Answer we want to update
     *   }
     * })
     */
    upsert<T extends AnswerUpsertArgs>(
      args: SelectSubset<T, AnswerUpsertArgs<ExtArgs>>
    ): Prisma__AnswerClient<
      $Result.GetResult<
        Prisma.$AnswerPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerCountArgs} args - Arguments to filter Answers to count.
     * @example
     * // Count the number of Answers
     * const count = await prisma.answer.count({
     *   where: {
     *     // ... the filter for the Answers we want to count
     *   }
     * })
     **/
    count<T extends AnswerCountArgs>(
      args?: Subset<T, AnswerCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnswerCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AnswerAggregateArgs>(
      args: Subset<T, AnswerAggregateArgs>
    ): Prisma.PrismaPromise<GetAnswerAggregateType<T>>;

    /**
     * Group by Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnswerGroupByArgs['orderBy'] }
        : { orderBy?: AnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, AnswerGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAnswerGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Answer model
     */
    readonly fields: AnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Answer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnswerClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Question<T extends QuestionDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, QuestionDefaultArgs<ExtArgs>>
    ): Prisma__QuestionClient<
      | $Result.GetResult<
          Prisma.$QuestionPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    User<T extends Answer$UserArgs<ExtArgs> = {}>(
      args?: Subset<T, Answer$UserArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Answer model
   */
  interface AnswerFieldRefs {
    readonly idQuestion: FieldRef<'Answer', 'Int'>;
    readonly idAnswer: FieldRef<'Answer', 'Int'>;
    readonly idUser: FieldRef<'Answer', 'Int'>;
    readonly contentAnswer: FieldRef<'Answer', 'String'>;
  }

  // Custom InputTypes
  /**
   * Answer findUnique
   */
  export type AnswerFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null;
    /**
     * Filter, which Answer to fetch.
     */
    where: AnswerWhereUniqueInput;
  };

  /**
   * Answer findUniqueOrThrow
   */
  export type AnswerFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null;
    /**
     * Filter, which Answer to fetch.
     */
    where: AnswerWhereUniqueInput;
  };

  /**
   * Answer findFirst
   */
  export type AnswerFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null;
    /**
     * Filter, which Answer to fetch.
     */
    where?: AnswerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Answers.
     */
    cursor?: AnswerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Answers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[];
  };

  /**
   * Answer findFirstOrThrow
   */
  export type AnswerFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null;
    /**
     * Filter, which Answer to fetch.
     */
    where?: AnswerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Answers.
     */
    cursor?: AnswerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Answers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[];
  };

  /**
   * Answer findMany
   */
  export type AnswerFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null;
    /**
     * Filter, which Answers to fetch.
     */
    where?: AnswerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Answers.
     */
    cursor?: AnswerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Answers.
     */
    skip?: number;
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[];
  };

  /**
   * Answer create
   */
  export type AnswerCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null;
    /**
     * The data needed to create a Answer.
     */
    data: XOR<AnswerCreateInput, AnswerUncheckedCreateInput>;
  };

  /**
   * Answer createMany
   */
  export type AnswerCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Answers.
     */
    data: AnswerCreateManyInput | AnswerCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Answer update
   */
  export type AnswerUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null;
    /**
     * The data needed to update a Answer.
     */
    data: XOR<AnswerUpdateInput, AnswerUncheckedUpdateInput>;
    /**
     * Choose, which Answer to update.
     */
    where: AnswerWhereUniqueInput;
  };

  /**
   * Answer updateMany
   */
  export type AnswerUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Answers.
     */
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyInput>;
    /**
     * Filter which Answers to update
     */
    where?: AnswerWhereInput;
    /**
     * Limit how many Answers to update.
     */
    limit?: number;
  };

  /**
   * Answer upsert
   */
  export type AnswerUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null;
    /**
     * The filter to search for the Answer to update in case it exists.
     */
    where: AnswerWhereUniqueInput;
    /**
     * In case the Answer found by the `where` argument doesn't exist, create a new Answer with this data.
     */
    create: XOR<AnswerCreateInput, AnswerUncheckedCreateInput>;
    /**
     * In case the Answer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnswerUpdateInput, AnswerUncheckedUpdateInput>;
  };

  /**
   * Answer delete
   */
  export type AnswerDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null;
    /**
     * Filter which Answer to delete.
     */
    where: AnswerWhereUniqueInput;
  };

  /**
   * Answer deleteMany
   */
  export type AnswerDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Answers to delete
     */
    where?: AnswerWhereInput;
    /**
     * Limit how many Answers to delete.
     */
    limit?: number;
  };

  /**
   * Answer.User
   */
  export type Answer$UserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Answer without action
   */
  export type AnswerDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null;
  };

  /**
   * Model Cart
   */

  export type AggregateCart = {
    _count: CartCountAggregateOutputType | null;
    _avg: CartAvgAggregateOutputType | null;
    _sum: CartSumAggregateOutputType | null;
    _min: CartMinAggregateOutputType | null;
    _max: CartMaxAggregateOutputType | null;
  };

  export type CartAvgAggregateOutputType = {
    idUser: number | null;
    idCourse: number | null;
  };

  export type CartSumAggregateOutputType = {
    idUser: number | null;
    idCourse: number | null;
  };

  export type CartMinAggregateOutputType = {
    idUser: number | null;
    idCourse: number | null;
  };

  export type CartMaxAggregateOutputType = {
    idUser: number | null;
    idCourse: number | null;
  };

  export type CartCountAggregateOutputType = {
    idUser: number;
    idCourse: number;
    _all: number;
  };

  export type CartAvgAggregateInputType = {
    idUser?: true;
    idCourse?: true;
  };

  export type CartSumAggregateInputType = {
    idUser?: true;
    idCourse?: true;
  };

  export type CartMinAggregateInputType = {
    idUser?: true;
    idCourse?: true;
  };

  export type CartMaxAggregateInputType = {
    idUser?: true;
    idCourse?: true;
  };

  export type CartCountAggregateInputType = {
    idUser?: true;
    idCourse?: true;
    _all?: true;
  };

  export type CartAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Cart to aggregate.
     */
    where?: CartWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CartWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Carts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Carts
     **/
    _count?: true | CartCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CartAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CartSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CartMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CartMaxAggregateInputType;
  };

  export type GetCartAggregateType<T extends CartAggregateArgs> = {
    [P in keyof T & keyof AggregateCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart[P]>
      : GetScalarType<T[P], AggregateCart[P]>;
  };

  export type CartGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CartWhereInput;
    orderBy?:
      | CartOrderByWithAggregationInput
      | CartOrderByWithAggregationInput[];
    by: CartScalarFieldEnum[] | CartScalarFieldEnum;
    having?: CartScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CartCountAggregateInputType | true;
    _avg?: CartAvgAggregateInputType;
    _sum?: CartSumAggregateInputType;
    _min?: CartMinAggregateInputType;
    _max?: CartMaxAggregateInputType;
  };

  export type CartGroupByOutputType = {
    idUser: number;
    idCourse: number;
    _count: CartCountAggregateOutputType | null;
    _avg: CartAvgAggregateOutputType | null;
    _sum: CartSumAggregateOutputType | null;
    _min: CartMinAggregateOutputType | null;
    _max: CartMaxAggregateOutputType | null;
  };

  type GetCartGroupByPayload<T extends CartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartGroupByOutputType, T['by']> & {
        [P in keyof T & keyof CartGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], CartGroupByOutputType[P]>
          : GetScalarType<T[P], CartGroupByOutputType[P]>;
      }
    >
  >;

  export type CartSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idUser?: boolean;
      idCourse?: boolean;
      Course?: boolean | CourseDefaultArgs<ExtArgs>;
      User?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['cart']
  >;

  export type CartSelectScalar = {
    idUser?: boolean;
    idCourse?: boolean;
  };

  export type CartOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<'idUser' | 'idCourse', ExtArgs['result']['cart']>;
  export type CartInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Course?: boolean | CourseDefaultArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $CartPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Cart';
    objects: {
      Course: Prisma.$CoursePayload<ExtArgs>;
      User: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idUser: number;
        idCourse: number;
      },
      ExtArgs['result']['cart']
    >;
    composites: {};
  };

  type CartGetPayload<S extends boolean | null | undefined | CartDefaultArgs> =
    $Result.GetResult<Prisma.$CartPayload, S>;

  type CartCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<CartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: CartCountAggregateInputType | true;
  };

  export interface CartDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Cart'];
      meta: { name: 'Cart' };
    };
    /**
     * Find zero or one Cart that matches the filter.
     * @param {CartFindUniqueArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartFindUniqueArgs>(
      args: SelectSubset<T, CartFindUniqueArgs<ExtArgs>>
    ): Prisma__CartClient<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Cart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartFindUniqueOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CartFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CartClient<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartFindFirstArgs>(
      args?: SelectSubset<T, CartFindFirstArgs<ExtArgs>>
    ): Prisma__CartClient<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Cart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CartFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CartClient<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.cart.findMany()
     *
     * // Get first 10 Carts
     * const carts = await prisma.cart.findMany({ take: 10 })
     *
     * // Only select the `idUser`
     * const cartWithIdUserOnly = await prisma.cart.findMany({ select: { idUser: true } })
     *
     */
    findMany<T extends CartFindManyArgs>(
      args?: SelectSubset<T, CartFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Cart.
     * @param {CartCreateArgs} args - Arguments to create a Cart.
     * @example
     * // Create one Cart
     * const Cart = await prisma.cart.create({
     *   data: {
     *     // ... data to create a Cart
     *   }
     * })
     *
     */
    create<T extends CartCreateArgs>(
      args: SelectSubset<T, CartCreateArgs<ExtArgs>>
    ): Prisma__CartClient<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Carts.
     * @param {CartCreateManyArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CartCreateManyArgs>(
      args?: SelectSubset<T, CartCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Cart.
     * @param {CartDeleteArgs} args - Arguments to delete one Cart.
     * @example
     * // Delete one Cart
     * const Cart = await prisma.cart.delete({
     *   where: {
     *     // ... filter to delete one Cart
     *   }
     * })
     *
     */
    delete<T extends CartDeleteArgs>(
      args: SelectSubset<T, CartDeleteArgs<ExtArgs>>
    ): Prisma__CartClient<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Cart.
     * @param {CartUpdateArgs} args - Arguments to update one Cart.
     * @example
     * // Update one Cart
     * const cart = await prisma.cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CartUpdateArgs>(
      args: SelectSubset<T, CartUpdateArgs<ExtArgs>>
    ): Prisma__CartClient<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Carts.
     * @param {CartDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CartDeleteManyArgs>(
      args?: SelectSubset<T, CartDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CartUpdateManyArgs>(
      args: SelectSubset<T, CartUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Cart.
     * @param {CartUpsertArgs} args - Arguments to update or create a Cart.
     * @example
     * // Update or create a Cart
     * const cart = await prisma.cart.upsert({
     *   create: {
     *     // ... data to create a Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart we want to update
     *   }
     * })
     */
    upsert<T extends CartUpsertArgs>(
      args: SelectSubset<T, CartUpsertArgs<ExtArgs>>
    ): Prisma__CartClient<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.cart.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
     **/
    count<T extends CartCountArgs>(
      args?: Subset<T, CartCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CartAggregateArgs>(
      args: Subset<T, CartAggregateArgs>
    ): Prisma.PrismaPromise<GetCartAggregateType<T>>;

    /**
     * Group by Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartGroupByArgs['orderBy'] }
        : { orderBy?: CartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, CartGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetCartGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Cart model
     */
    readonly fields: CartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Course<T extends CourseDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CourseDefaultArgs<ExtArgs>>
    ): Prisma__CourseClient<
      | $Result.GetResult<
          Prisma.$CoursePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    User<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Cart model
   */
  interface CartFieldRefs {
    readonly idUser: FieldRef<'Cart', 'Int'>;
    readonly idCourse: FieldRef<'Cart', 'Int'>;
  }

  // Custom InputTypes
  /**
   * Cart findUnique
   */
  export type CartFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput;
  };

  /**
   * Cart findUniqueOrThrow
   */
  export type CartFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput;
  };

  /**
   * Cart findFirst
   */
  export type CartFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Carts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[];
  };

  /**
   * Cart findFirstOrThrow
   */
  export type CartFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Carts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[];
  };

  /**
   * Cart findMany
   */
  export type CartFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    /**
     * Filter, which Carts to fetch.
     */
    where?: CartWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Carts.
     */
    cursor?: CartWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Carts.
     */
    skip?: number;
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[];
  };

  /**
   * Cart create
   */
  export type CartCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    /**
     * The data needed to create a Cart.
     */
    data: XOR<CartCreateInput, CartUncheckedCreateInput>;
  };

  /**
   * Cart createMany
   */
  export type CartCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Cart update
   */
  export type CartUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    /**
     * The data needed to update a Cart.
     */
    data: XOR<CartUpdateInput, CartUncheckedUpdateInput>;
    /**
     * Choose, which Cart to update.
     */
    where: CartWhereUniqueInput;
  };

  /**
   * Cart updateMany
   */
  export type CartUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>;
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput;
    /**
     * Limit how many Carts to update.
     */
    limit?: number;
  };

  /**
   * Cart upsert
   */
  export type CartUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    /**
     * The filter to search for the Cart to update in case it exists.
     */
    where: CartWhereUniqueInput;
    /**
     * In case the Cart found by the `where` argument doesn't exist, create a new Cart with this data.
     */
    create: XOR<CartCreateInput, CartUncheckedCreateInput>;
    /**
     * In case the Cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartUpdateInput, CartUncheckedUpdateInput>;
  };

  /**
   * Cart delete
   */
  export type CartDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    /**
     * Filter which Cart to delete.
     */
    where: CartWhereUniqueInput;
  };

  /**
   * Cart deleteMany
   */
  export type CartDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Carts to delete
     */
    where?: CartWhereInput;
    /**
     * Limit how many Carts to delete.
     */
    limit?: number;
  };

  /**
   * Cart without action
   */
  export type CartDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
  };

  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null;
    _avg: CategoryAvgAggregateOutputType | null;
    _sum: CategorySumAggregateOutputType | null;
    _min: CategoryMinAggregateOutputType | null;
    _max: CategoryMaxAggregateOutputType | null;
  };

  export type CategoryAvgAggregateOutputType = {
    idCategory: number | null;
  };

  export type CategorySumAggregateOutputType = {
    idCategory: number | null;
  };

  export type CategoryMinAggregateOutputType = {
    idCategory: number | null;
    nameCategory: string | null;
  };

  export type CategoryMaxAggregateOutputType = {
    idCategory: number | null;
    nameCategory: string | null;
  };

  export type CategoryCountAggregateOutputType = {
    idCategory: number;
    nameCategory: number;
    _all: number;
  };

  export type CategoryAvgAggregateInputType = {
    idCategory?: true;
  };

  export type CategorySumAggregateInputType = {
    idCategory?: true;
  };

  export type CategoryMinAggregateInputType = {
    idCategory?: true;
    nameCategory?: true;
  };

  export type CategoryMaxAggregateInputType = {
    idCategory?: true;
    nameCategory?: true;
  };

  export type CategoryCountAggregateInputType = {
    idCategory?: true;
    nameCategory?: true;
    _all?: true;
  };

  export type CategoryAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Categories to fetch.
     */
    orderBy?:
      | CategoryOrderByWithRelationInput
      | CategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Categories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Categories
     **/
    _count?: true | CategoryCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CategoryAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CategorySumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CategoryMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CategoryMaxAggregateInputType;
  };

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
    [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>;
  };

  export type CategoryGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CategoryWhereInput;
    orderBy?:
      | CategoryOrderByWithAggregationInput
      | CategoryOrderByWithAggregationInput[];
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum;
    having?: CategoryScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CategoryCountAggregateInputType | true;
    _avg?: CategoryAvgAggregateInputType;
    _sum?: CategorySumAggregateInputType;
    _min?: CategoryMinAggregateInputType;
    _max?: CategoryMaxAggregateInputType;
  };

  export type CategoryGroupByOutputType = {
    idCategory: number;
    nameCategory: string | null;
    _count: CategoryCountAggregateOutputType | null;
    _avg: CategoryAvgAggregateOutputType | null;
    _sum: CategorySumAggregateOutputType | null;
    _min: CategoryMinAggregateOutputType | null;
    _max: CategoryMaxAggregateOutputType | null;
  };

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CategoryGroupByOutputType, T['by']> & {
          [P in keyof T & keyof CategoryGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>;
        }
      >
    >;

  export type CategorySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idCategory?: boolean;
      nameCategory?: boolean;
      CourseCategory?: boolean | Category$CourseCategoryArgs<ExtArgs>;
      _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['category']
  >;

  export type CategorySelectScalar = {
    idCategory?: boolean;
    nameCategory?: boolean;
  };

  export type CategoryOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idCategory' | 'nameCategory',
    ExtArgs['result']['category']
  >;
  export type CategoryInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    CourseCategory?: boolean | Category$CourseCategoryArgs<ExtArgs>;
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $CategoryPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Category';
    objects: {
      CourseCategory: Prisma.$CourseCategoryPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idCategory: number;
        nameCategory: string | null;
      },
      ExtArgs['result']['category']
    >;
    composites: {};
  };

  type CategoryGetPayload<
    S extends boolean | null | undefined | CategoryDefaultArgs
  > = $Result.GetResult<Prisma.$CategoryPayload, S>;

  type CategoryCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: CategoryCountAggregateInputType | true;
  };

  export interface CategoryDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Category'];
      meta: { name: 'Category' };
    };
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(
      args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__CategoryClient<
      $Result.GetResult<
        Prisma.$CategoryPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryClient<
      $Result.GetResult<
        Prisma.$CategoryPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(
      args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>
    ): Prisma__CategoryClient<
      $Result.GetResult<
        Prisma.$CategoryPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryClient<
      $Result.GetResult<
        Prisma.$CategoryPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     *
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     *
     * // Only select the `idCategory`
     * const categoryWithIdCategoryOnly = await prisma.category.findMany({ select: { idCategory: true } })
     *
     */
    findMany<T extends CategoryFindManyArgs>(
      args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CategoryPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     *
     */
    create<T extends CategoryCreateArgs>(
      args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>
    ): Prisma__CategoryClient<
      $Result.GetResult<
        Prisma.$CategoryPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CategoryCreateManyArgs>(
      args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     *
     */
    delete<T extends CategoryDeleteArgs>(
      args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>
    ): Prisma__CategoryClient<
      $Result.GetResult<
        Prisma.$CategoryPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CategoryUpdateArgs>(
      args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>
    ): Prisma__CategoryClient<
      $Result.GetResult<
        Prisma.$CategoryPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CategoryDeleteManyArgs>(
      args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CategoryUpdateManyArgs>(
      args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(
      args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>
    ): Prisma__CategoryClient<
      $Result.GetResult<
        Prisma.$CategoryPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
     **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CategoryAggregateArgs>(
      args: Subset<T, CategoryAggregateArgs>
    ): Prisma.PrismaPromise<GetCategoryAggregateType<T>>;

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetCategoryGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Category model
     */
    readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    CourseCategory<T extends Category$CourseCategoryArgs<ExtArgs> = {}>(
      args?: Subset<T, Category$CourseCategoryArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CourseCategoryPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly idCategory: FieldRef<'Category', 'Int'>;
    readonly nameCategory: FieldRef<'Category', 'String'>;
  }

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput;
  };

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput;
  };

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Categories to fetch.
     */
    orderBy?:
      | CategoryOrderByWithRelationInput
      | CategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Categories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[];
  };

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Categories to fetch.
     */
    orderBy?:
      | CategoryOrderByWithRelationInput
      | CategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Categories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[];
  };

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Categories to fetch.
     */
    orderBy?:
      | CategoryOrderByWithRelationInput
      | CategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Categories.
     */
    skip?: number;
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[];
  };

  /**
   * Category create
   */
  export type CategoryCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * The data needed to create a Category.
     */
    data?: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>;
  };

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Category update
   */
  export type CategoryUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>;
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput;
  };

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Categories.
     */
    data: XOR<
      CategoryUpdateManyMutationInput,
      CategoryUncheckedUpdateManyInput
    >;
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput;
    /**
     * Limit how many Categories to update.
     */
    limit?: number;
  };

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput;
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>;
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>;
  };

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput;
  };

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput;
    /**
     * Limit how many Categories to delete.
     */
    limit?: number;
  };

  /**
   * Category.CourseCategory
   */
  export type Category$CourseCategoryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null;
    where?: CourseCategoryWhereInput;
    orderBy?:
      | CourseCategoryOrderByWithRelationInput
      | CourseCategoryOrderByWithRelationInput[];
    cursor?: CourseCategoryWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CourseCategoryScalarFieldEnum | CourseCategoryScalarFieldEnum[];
  };

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
  };

  /**
   * Model Certificate
   */

  export type AggregateCertificate = {
    _count: CertificateCountAggregateOutputType | null;
    _avg: CertificateAvgAggregateOutputType | null;
    _sum: CertificateSumAggregateOutputType | null;
    _min: CertificateMinAggregateOutputType | null;
    _max: CertificateMaxAggregateOutputType | null;
  };

  export type CertificateAvgAggregateOutputType = {
    idCourse: number | null;
  };

  export type CertificateSumAggregateOutputType = {
    idCourse: number | null;
  };

  export type CertificateMinAggregateOutputType = {
    idCourse: number | null;
    certificate: string | null;
  };

  export type CertificateMaxAggregateOutputType = {
    idCourse: number | null;
    certificate: string | null;
  };

  export type CertificateCountAggregateOutputType = {
    idCourse: number;
    certificate: number;
    _all: number;
  };

  export type CertificateAvgAggregateInputType = {
    idCourse?: true;
  };

  export type CertificateSumAggregateInputType = {
    idCourse?: true;
  };

  export type CertificateMinAggregateInputType = {
    idCourse?: true;
    certificate?: true;
  };

  export type CertificateMaxAggregateInputType = {
    idCourse?: true;
    certificate?: true;
  };

  export type CertificateCountAggregateInputType = {
    idCourse?: true;
    certificate?: true;
    _all?: true;
  };

  export type CertificateAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Certificate to aggregate.
     */
    where?: CertificateWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Certificates to fetch.
     */
    orderBy?:
      | CertificateOrderByWithRelationInput
      | CertificateOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CertificateWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Certificates.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Certificates
     **/
    _count?: true | CertificateCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CertificateAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CertificateSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CertificateMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CertificateMaxAggregateInputType;
  };

  export type GetCertificateAggregateType<T extends CertificateAggregateArgs> =
    {
      [P in keyof T & keyof AggregateCertificate]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateCertificate[P]>
        : GetScalarType<T[P], AggregateCertificate[P]>;
    };

  export type CertificateGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CertificateWhereInput;
    orderBy?:
      | CertificateOrderByWithAggregationInput
      | CertificateOrderByWithAggregationInput[];
    by: CertificateScalarFieldEnum[] | CertificateScalarFieldEnum;
    having?: CertificateScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CertificateCountAggregateInputType | true;
    _avg?: CertificateAvgAggregateInputType;
    _sum?: CertificateSumAggregateInputType;
    _min?: CertificateMinAggregateInputType;
    _max?: CertificateMaxAggregateInputType;
  };

  export type CertificateGroupByOutputType = {
    idCourse: number;
    certificate: string | null;
    _count: CertificateCountAggregateOutputType | null;
    _avg: CertificateAvgAggregateOutputType | null;
    _sum: CertificateSumAggregateOutputType | null;
    _min: CertificateMinAggregateOutputType | null;
    _max: CertificateMaxAggregateOutputType | null;
  };

  type GetCertificateGroupByPayload<T extends CertificateGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CertificateGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof CertificateGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateGroupByOutputType[P]>;
        }
      >
    >;

  export type CertificateSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idCourse?: boolean;
      certificate?: boolean;
      Course?: boolean | CourseDefaultArgs<ExtArgs>;
      UserCertificate?: boolean | Certificate$UserCertificateArgs<ExtArgs>;
      _count?: boolean | CertificateCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['certificate']
  >;

  export type CertificateSelectScalar = {
    idCourse?: boolean;
    certificate?: boolean;
  };

  export type CertificateOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idCourse' | 'certificate',
    ExtArgs['result']['certificate']
  >;
  export type CertificateInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Course?: boolean | CourseDefaultArgs<ExtArgs>;
    UserCertificate?: boolean | Certificate$UserCertificateArgs<ExtArgs>;
    _count?: boolean | CertificateCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $CertificatePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Certificate';
    objects: {
      Course: Prisma.$CoursePayload<ExtArgs>;
      UserCertificate: Prisma.$UserCertificatePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idCourse: number;
        certificate: string | null;
      },
      ExtArgs['result']['certificate']
    >;
    composites: {};
  };

  type CertificateGetPayload<
    S extends boolean | null | undefined | CertificateDefaultArgs
  > = $Result.GetResult<Prisma.$CertificatePayload, S>;

  type CertificateCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    CertificateFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: CertificateCountAggregateInputType | true;
  };

  export interface CertificateDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Certificate'];
      meta: { name: 'Certificate' };
    };
    /**
     * Find zero or one Certificate that matches the filter.
     * @param {CertificateFindUniqueArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificateFindUniqueArgs>(
      args: SelectSubset<T, CertificateFindUniqueArgs<ExtArgs>>
    ): Prisma__CertificateClient<
      $Result.GetResult<
        Prisma.$CertificatePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Certificate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CertificateFindUniqueOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificateFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CertificateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CertificateClient<
      $Result.GetResult<
        Prisma.$CertificatePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Certificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificateFindFirstArgs>(
      args?: SelectSubset<T, CertificateFindFirstArgs<ExtArgs>>
    ): Prisma__CertificateClient<
      $Result.GetResult<
        Prisma.$CertificatePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Certificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificateFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CertificateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CertificateClient<
      $Result.GetResult<
        Prisma.$CertificatePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificate.findMany()
     *
     * // Get first 10 Certificates
     * const certificates = await prisma.certificate.findMany({ take: 10 })
     *
     * // Only select the `idCourse`
     * const certificateWithIdCourseOnly = await prisma.certificate.findMany({ select: { idCourse: true } })
     *
     */
    findMany<T extends CertificateFindManyArgs>(
      args?: SelectSubset<T, CertificateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CertificatePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Certificate.
     * @param {CertificateCreateArgs} args - Arguments to create a Certificate.
     * @example
     * // Create one Certificate
     * const Certificate = await prisma.certificate.create({
     *   data: {
     *     // ... data to create a Certificate
     *   }
     * })
     *
     */
    create<T extends CertificateCreateArgs>(
      args: SelectSubset<T, CertificateCreateArgs<ExtArgs>>
    ): Prisma__CertificateClient<
      $Result.GetResult<
        Prisma.$CertificatePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Certificates.
     * @param {CertificateCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CertificateCreateManyArgs>(
      args?: SelectSubset<T, CertificateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Certificate.
     * @param {CertificateDeleteArgs} args - Arguments to delete one Certificate.
     * @example
     * // Delete one Certificate
     * const Certificate = await prisma.certificate.delete({
     *   where: {
     *     // ... filter to delete one Certificate
     *   }
     * })
     *
     */
    delete<T extends CertificateDeleteArgs>(
      args: SelectSubset<T, CertificateDeleteArgs<ExtArgs>>
    ): Prisma__CertificateClient<
      $Result.GetResult<
        Prisma.$CertificatePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Certificate.
     * @param {CertificateUpdateArgs} args - Arguments to update one Certificate.
     * @example
     * // Update one Certificate
     * const certificate = await prisma.certificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CertificateUpdateArgs>(
      args: SelectSubset<T, CertificateUpdateArgs<ExtArgs>>
    ): Prisma__CertificateClient<
      $Result.GetResult<
        Prisma.$CertificatePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Certificates.
     * @param {CertificateDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CertificateDeleteManyArgs>(
      args?: SelectSubset<T, CertificateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CertificateUpdateManyArgs>(
      args: SelectSubset<T, CertificateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Certificate.
     * @param {CertificateUpsertArgs} args - Arguments to update or create a Certificate.
     * @example
     * // Update or create a Certificate
     * const certificate = await prisma.certificate.upsert({
     *   create: {
     *     // ... data to create a Certificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificate we want to update
     *   }
     * })
     */
    upsert<T extends CertificateUpsertArgs>(
      args: SelectSubset<T, CertificateUpsertArgs<ExtArgs>>
    ): Prisma__CertificateClient<
      $Result.GetResult<
        Prisma.$CertificatePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificate.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
     **/
    count<T extends CertificateCountArgs>(
      args?: Subset<T, CertificateCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CertificateAggregateArgs>(
      args: Subset<T, CertificateAggregateArgs>
    ): Prisma.PrismaPromise<GetCertificateAggregateType<T>>;

    /**
     * Group by Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateGroupByArgs['orderBy'] }
        : { orderBy?: CertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, CertificateGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetCertificateGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Certificate model
     */
    readonly fields: CertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificateClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Course<T extends CourseDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CourseDefaultArgs<ExtArgs>>
    ): Prisma__CourseClient<
      | $Result.GetResult<
          Prisma.$CoursePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    UserCertificate<T extends Certificate$UserCertificateArgs<ExtArgs> = {}>(
      args?: Subset<T, Certificate$UserCertificateArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UserCertificatePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Certificate model
   */
  interface CertificateFieldRefs {
    readonly idCourse: FieldRef<'Certificate', 'Int'>;
    readonly certificate: FieldRef<'Certificate', 'String'>;
  }

  // Custom InputTypes
  /**
   * Certificate findUnique
   */
  export type CertificateFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null;
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput;
  };

  /**
   * Certificate findUniqueOrThrow
   */
  export type CertificateFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null;
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput;
  };

  /**
   * Certificate findFirst
   */
  export type CertificateFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null;
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Certificates to fetch.
     */
    orderBy?:
      | CertificateOrderByWithRelationInput
      | CertificateOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Certificates.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[];
  };

  /**
   * Certificate findFirstOrThrow
   */
  export type CertificateFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null;
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Certificates to fetch.
     */
    orderBy?:
      | CertificateOrderByWithRelationInput
      | CertificateOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Certificates.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[];
  };

  /**
   * Certificate findMany
   */
  export type CertificateFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null;
    /**
     * Filter, which Certificates to fetch.
     */
    where?: CertificateWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Certificates to fetch.
     */
    orderBy?:
      | CertificateOrderByWithRelationInput
      | CertificateOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Certificates.
     */
    cursor?: CertificateWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Certificates.
     */
    skip?: number;
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[];
  };

  /**
   * Certificate create
   */
  export type CertificateCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null;
    /**
     * The data needed to create a Certificate.
     */
    data: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>;
  };

  /**
   * Certificate createMany
   */
  export type CertificateCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Certificate update
   */
  export type CertificateUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null;
    /**
     * The data needed to update a Certificate.
     */
    data: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>;
    /**
     * Choose, which Certificate to update.
     */
    where: CertificateWhereUniqueInput;
  };

  /**
   * Certificate updateMany
   */
  export type CertificateUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Certificates.
     */
    data: XOR<
      CertificateUpdateManyMutationInput,
      CertificateUncheckedUpdateManyInput
    >;
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput;
    /**
     * Limit how many Certificates to update.
     */
    limit?: number;
  };

  /**
   * Certificate upsert
   */
  export type CertificateUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null;
    /**
     * The filter to search for the Certificate to update in case it exists.
     */
    where: CertificateWhereUniqueInput;
    /**
     * In case the Certificate found by the `where` argument doesn't exist, create a new Certificate with this data.
     */
    create: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>;
    /**
     * In case the Certificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>;
  };

  /**
   * Certificate delete
   */
  export type CertificateDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null;
    /**
     * Filter which Certificate to delete.
     */
    where: CertificateWhereUniqueInput;
  };

  /**
   * Certificate deleteMany
   */
  export type CertificateDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Certificates to delete
     */
    where?: CertificateWhereInput;
    /**
     * Limit how many Certificates to delete.
     */
    limit?: number;
  };

  /**
   * Certificate.UserCertificate
   */
  export type Certificate$UserCertificateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCertificate
     */
    select?: UserCertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCertificate
     */
    omit?: UserCertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificateInclude<ExtArgs> | null;
    where?: UserCertificateWhereInput;
    orderBy?:
      | UserCertificateOrderByWithRelationInput
      | UserCertificateOrderByWithRelationInput[];
    cursor?: UserCertificateWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | UserCertificateScalarFieldEnum
      | UserCertificateScalarFieldEnum[];
  };

  /**
   * Certificate without action
   */
  export type CertificateDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null;
  };

  /**
   * Model Coupon
   */

  export type AggregateCoupon = {
    _count: CouponCountAggregateOutputType | null;
    _avg: CouponAvgAggregateOutputType | null;
    _sum: CouponSumAggregateOutputType | null;
    _min: CouponMinAggregateOutputType | null;
    _max: CouponMaxAggregateOutputType | null;
  };

  export type CouponAvgAggregateOutputType = {
    idCoupon: number | null;
    value: Decimal | null;
    quantity: number | null;
    appliedAmount: number | null;
    minRequire: Decimal | null;
    maxValueDiscount: Decimal | null;
    idUser: number | null;
  };

  export type CouponSumAggregateOutputType = {
    idCoupon: number | null;
    value: Decimal | null;
    quantity: number | null;
    appliedAmount: number | null;
    minRequire: Decimal | null;
    maxValueDiscount: Decimal | null;
    idUser: number | null;
  };

  export type CouponMinAggregateOutputType = {
    idCoupon: number | null;
    type: string | null;
    value: Decimal | null;
    startDate: Date | null;
    endDate: Date | null;
    quantity: number | null;
    appliedAmount: number | null;
    minRequire: Decimal | null;
    maxValueDiscount: Decimal | null;
    code: string | null;
    idUser: number | null;
  };

  export type CouponMaxAggregateOutputType = {
    idCoupon: number | null;
    type: string | null;
    value: Decimal | null;
    startDate: Date | null;
    endDate: Date | null;
    quantity: number | null;
    appliedAmount: number | null;
    minRequire: Decimal | null;
    maxValueDiscount: Decimal | null;
    code: string | null;
    idUser: number | null;
  };

  export type CouponCountAggregateOutputType = {
    idCoupon: number;
    type: number;
    value: number;
    startDate: number;
    endDate: number;
    quantity: number;
    appliedAmount: number;
    minRequire: number;
    maxValueDiscount: number;
    code: number;
    idUser: number;
    _all: number;
  };

  export type CouponAvgAggregateInputType = {
    idCoupon?: true;
    value?: true;
    quantity?: true;
    appliedAmount?: true;
    minRequire?: true;
    maxValueDiscount?: true;
    idUser?: true;
  };

  export type CouponSumAggregateInputType = {
    idCoupon?: true;
    value?: true;
    quantity?: true;
    appliedAmount?: true;
    minRequire?: true;
    maxValueDiscount?: true;
    idUser?: true;
  };

  export type CouponMinAggregateInputType = {
    idCoupon?: true;
    type?: true;
    value?: true;
    startDate?: true;
    endDate?: true;
    quantity?: true;
    appliedAmount?: true;
    minRequire?: true;
    maxValueDiscount?: true;
    code?: true;
    idUser?: true;
  };

  export type CouponMaxAggregateInputType = {
    idCoupon?: true;
    type?: true;
    value?: true;
    startDate?: true;
    endDate?: true;
    quantity?: true;
    appliedAmount?: true;
    minRequire?: true;
    maxValueDiscount?: true;
    code?: true;
    idUser?: true;
  };

  export type CouponCountAggregateInputType = {
    idCoupon?: true;
    type?: true;
    value?: true;
    startDate?: true;
    endDate?: true;
    quantity?: true;
    appliedAmount?: true;
    minRequire?: true;
    maxValueDiscount?: true;
    code?: true;
    idUser?: true;
    _all?: true;
  };

  export type CouponAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Coupon to aggregate.
     */
    where?: CouponWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CouponWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Coupons.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Coupons
     **/
    _count?: true | CouponCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CouponAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CouponSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CouponMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CouponMaxAggregateInputType;
  };

  export type GetCouponAggregateType<T extends CouponAggregateArgs> = {
    [P in keyof T & keyof AggregateCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon[P]>
      : GetScalarType<T[P], AggregateCoupon[P]>;
  };

  export type CouponGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CouponWhereInput;
    orderBy?:
      | CouponOrderByWithAggregationInput
      | CouponOrderByWithAggregationInput[];
    by: CouponScalarFieldEnum[] | CouponScalarFieldEnum;
    having?: CouponScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CouponCountAggregateInputType | true;
    _avg?: CouponAvgAggregateInputType;
    _sum?: CouponSumAggregateInputType;
    _min?: CouponMinAggregateInputType;
    _max?: CouponMaxAggregateInputType;
  };

  export type CouponGroupByOutputType = {
    idCoupon: number;
    type: string | null;
    value: Decimal | null;
    startDate: Date | null;
    endDate: Date | null;
    quantity: number | null;
    appliedAmount: number | null;
    minRequire: Decimal | null;
    maxValueDiscount: Decimal | null;
    code: string | null;
    idUser: number | null;
    _count: CouponCountAggregateOutputType | null;
    _avg: CouponAvgAggregateOutputType | null;
    _sum: CouponSumAggregateOutputType | null;
    _min: CouponMinAggregateOutputType | null;
    _max: CouponMaxAggregateOutputType | null;
  };

  type GetCouponGroupByPayload<T extends CouponGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CouponGroupByOutputType, T['by']> & {
          [P in keyof T & keyof CouponGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponGroupByOutputType[P]>
            : GetScalarType<T[P], CouponGroupByOutputType[P]>;
        }
      >
    >;

  export type CouponSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idCoupon?: boolean;
      type?: boolean;
      value?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      quantity?: boolean;
      appliedAmount?: boolean;
      minRequire?: boolean;
      maxValueDiscount?: boolean;
      code?: boolean;
      idUser?: boolean;
      User?: boolean | Coupon$UserArgs<ExtArgs>;
      CouponCourse?: boolean | Coupon$CouponCourseArgs<ExtArgs>;
      UserCoupon?: boolean | Coupon$UserCouponArgs<ExtArgs>;
      _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['coupon']
  >;

  export type CouponSelectScalar = {
    idCoupon?: boolean;
    type?: boolean;
    value?: boolean;
    startDate?: boolean;
    endDate?: boolean;
    quantity?: boolean;
    appliedAmount?: boolean;
    minRequire?: boolean;
    maxValueDiscount?: boolean;
    code?: boolean;
    idUser?: boolean;
  };

  export type CouponOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'idCoupon'
    | 'type'
    | 'value'
    | 'startDate'
    | 'endDate'
    | 'quantity'
    | 'appliedAmount'
    | 'minRequire'
    | 'maxValueDiscount'
    | 'code'
    | 'idUser',
    ExtArgs['result']['coupon']
  >;
  export type CouponInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    User?: boolean | Coupon$UserArgs<ExtArgs>;
    CouponCourse?: boolean | Coupon$CouponCourseArgs<ExtArgs>;
    UserCoupon?: boolean | Coupon$UserCouponArgs<ExtArgs>;
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $CouponPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Coupon';
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null;
      CouponCourse: Prisma.$CouponCoursePayload<ExtArgs>[];
      UserCoupon: Prisma.$UserCouponPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idCoupon: number;
        type: string | null;
        value: Prisma.Decimal | null;
        startDate: Date | null;
        endDate: Date | null;
        quantity: number | null;
        appliedAmount: number | null;
        minRequire: Prisma.Decimal | null;
        maxValueDiscount: Prisma.Decimal | null;
        code: string | null;
        idUser: number | null;
      },
      ExtArgs['result']['coupon']
    >;
    composites: {};
  };

  type CouponGetPayload<
    S extends boolean | null | undefined | CouponDefaultArgs
  > = $Result.GetResult<Prisma.$CouponPayload, S>;

  type CouponCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<CouponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: CouponCountAggregateInputType | true;
  };

  export interface CouponDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Coupon'];
      meta: { name: 'Coupon' };
    };
    /**
     * Find zero or one Coupon that matches the filter.
     * @param {CouponFindUniqueArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponFindUniqueArgs>(
      args: SelectSubset<T, CouponFindUniqueArgs<ExtArgs>>
    ): Prisma__CouponClient<
      $Result.GetResult<
        Prisma.$CouponPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Coupon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CouponFindUniqueOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CouponFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CouponClient<
      $Result.GetResult<
        Prisma.$CouponPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Coupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponFindFirstArgs>(
      args?: SelectSubset<T, CouponFindFirstArgs<ExtArgs>>
    ): Prisma__CouponClient<
      $Result.GetResult<
        Prisma.$CouponPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Coupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CouponFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CouponClient<
      $Result.GetResult<
        Prisma.$CouponPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupon.findMany()
     *
     * // Get first 10 Coupons
     * const coupons = await prisma.coupon.findMany({ take: 10 })
     *
     * // Only select the `idCoupon`
     * const couponWithIdCouponOnly = await prisma.coupon.findMany({ select: { idCoupon: true } })
     *
     */
    findMany<T extends CouponFindManyArgs>(
      args?: SelectSubset<T, CouponFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CouponPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Coupon.
     * @param {CouponCreateArgs} args - Arguments to create a Coupon.
     * @example
     * // Create one Coupon
     * const Coupon = await prisma.coupon.create({
     *   data: {
     *     // ... data to create a Coupon
     *   }
     * })
     *
     */
    create<T extends CouponCreateArgs>(
      args: SelectSubset<T, CouponCreateArgs<ExtArgs>>
    ): Prisma__CouponClient<
      $Result.GetResult<
        Prisma.$CouponPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Coupons.
     * @param {CouponCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CouponCreateManyArgs>(
      args?: SelectSubset<T, CouponCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Coupon.
     * @param {CouponDeleteArgs} args - Arguments to delete one Coupon.
     * @example
     * // Delete one Coupon
     * const Coupon = await prisma.coupon.delete({
     *   where: {
     *     // ... filter to delete one Coupon
     *   }
     * })
     *
     */
    delete<T extends CouponDeleteArgs>(
      args: SelectSubset<T, CouponDeleteArgs<ExtArgs>>
    ): Prisma__CouponClient<
      $Result.GetResult<
        Prisma.$CouponPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Coupon.
     * @param {CouponUpdateArgs} args - Arguments to update one Coupon.
     * @example
     * // Update one Coupon
     * const coupon = await prisma.coupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CouponUpdateArgs>(
      args: SelectSubset<T, CouponUpdateArgs<ExtArgs>>
    ): Prisma__CouponClient<
      $Result.GetResult<
        Prisma.$CouponPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Coupons.
     * @param {CouponDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CouponDeleteManyArgs>(
      args?: SelectSubset<T, CouponDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CouponUpdateManyArgs>(
      args: SelectSubset<T, CouponUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Coupon.
     * @param {CouponUpsertArgs} args - Arguments to update or create a Coupon.
     * @example
     * // Update or create a Coupon
     * const coupon = await prisma.coupon.upsert({
     *   create: {
     *     // ... data to create a Coupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon we want to update
     *   }
     * })
     */
    upsert<T extends CouponUpsertArgs>(
      args: SelectSubset<T, CouponUpsertArgs<ExtArgs>>
    ): Prisma__CouponClient<
      $Result.GetResult<
        Prisma.$CouponPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupon.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
     **/
    count<T extends CouponCountArgs>(
      args?: Subset<T, CouponCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CouponAggregateArgs>(
      args: Subset<T, CouponAggregateArgs>
    ): Prisma.PrismaPromise<GetCouponAggregateType<T>>;

    /**
     * Group by Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponGroupByArgs['orderBy'] }
        : { orderBy?: CouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, CouponGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetCouponGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Coupon model
     */
    readonly fields: CouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    User<T extends Coupon$UserArgs<ExtArgs> = {}>(
      args?: Subset<T, Coupon$UserArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    CouponCourse<T extends Coupon$CouponCourseArgs<ExtArgs> = {}>(
      args?: Subset<T, Coupon$CouponCourseArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CouponCoursePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    UserCoupon<T extends Coupon$UserCouponArgs<ExtArgs> = {}>(
      args?: Subset<T, Coupon$UserCouponArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UserCouponPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Coupon model
   */
  interface CouponFieldRefs {
    readonly idCoupon: FieldRef<'Coupon', 'Int'>;
    readonly type: FieldRef<'Coupon', 'String'>;
    readonly value: FieldRef<'Coupon', 'Decimal'>;
    readonly startDate: FieldRef<'Coupon', 'DateTime'>;
    readonly endDate: FieldRef<'Coupon', 'DateTime'>;
    readonly quantity: FieldRef<'Coupon', 'Int'>;
    readonly appliedAmount: FieldRef<'Coupon', 'Int'>;
    readonly minRequire: FieldRef<'Coupon', 'Decimal'>;
    readonly maxValueDiscount: FieldRef<'Coupon', 'Decimal'>;
    readonly code: FieldRef<'Coupon', 'String'>;
    readonly idUser: FieldRef<'Coupon', 'Int'>;
  }

  // Custom InputTypes
  /**
   * Coupon findUnique
   */
  export type CouponFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput;
  };

  /**
   * Coupon findUniqueOrThrow
   */
  export type CouponFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput;
  };

  /**
   * Coupon findFirst
   */
  export type CouponFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Coupons.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[];
  };

  /**
   * Coupon findFirstOrThrow
   */
  export type CouponFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Coupons.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[];
  };

  /**
   * Coupon findMany
   */
  export type CouponFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    /**
     * Filter, which Coupons to fetch.
     */
    where?: CouponWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Coupons.
     */
    cursor?: CouponWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Coupons.
     */
    skip?: number;
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[];
  };

  /**
   * Coupon create
   */
  export type CouponCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    /**
     * The data needed to create a Coupon.
     */
    data?: XOR<CouponCreateInput, CouponUncheckedCreateInput>;
  };

  /**
   * Coupon createMany
   */
  export type CouponCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Coupon update
   */
  export type CouponUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    /**
     * The data needed to update a Coupon.
     */
    data: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>;
    /**
     * Choose, which Coupon to update.
     */
    where: CouponWhereUniqueInput;
  };

  /**
   * Coupon updateMany
   */
  export type CouponUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>;
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput;
    /**
     * Limit how many Coupons to update.
     */
    limit?: number;
  };

  /**
   * Coupon upsert
   */
  export type CouponUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    /**
     * The filter to search for the Coupon to update in case it exists.
     */
    where: CouponWhereUniqueInput;
    /**
     * In case the Coupon found by the `where` argument doesn't exist, create a new Coupon with this data.
     */
    create: XOR<CouponCreateInput, CouponUncheckedCreateInput>;
    /**
     * In case the Coupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>;
  };

  /**
   * Coupon delete
   */
  export type CouponDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    /**
     * Filter which Coupon to delete.
     */
    where: CouponWhereUniqueInput;
  };

  /**
   * Coupon deleteMany
   */
  export type CouponDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Coupons to delete
     */
    where?: CouponWhereInput;
    /**
     * Limit how many Coupons to delete.
     */
    limit?: number;
  };

  /**
   * Coupon.User
   */
  export type Coupon$UserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Coupon.CouponCourse
   */
  export type Coupon$CouponCourseArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CouponCourse
     */
    select?: CouponCourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CouponCourse
     */
    omit?: CouponCourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponCourseInclude<ExtArgs> | null;
    where?: CouponCourseWhereInput;
    orderBy?:
      | CouponCourseOrderByWithRelationInput
      | CouponCourseOrderByWithRelationInput[];
    cursor?: CouponCourseWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CouponCourseScalarFieldEnum | CouponCourseScalarFieldEnum[];
  };

  /**
   * Coupon.UserCoupon
   */
  export type Coupon$UserCouponArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null;
    where?: UserCouponWhereInput;
    orderBy?:
      | UserCouponOrderByWithRelationInput
      | UserCouponOrderByWithRelationInput[];
    cursor?: UserCouponWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserCouponScalarFieldEnum | UserCouponScalarFieldEnum[];
  };

  /**
   * Coupon without action
   */
  export type CouponDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
  };

  /**
   * Model CouponCourse
   */

  export type AggregateCouponCourse = {
    _count: CouponCourseCountAggregateOutputType | null;
    _avg: CouponCourseAvgAggregateOutputType | null;
    _sum: CouponCourseSumAggregateOutputType | null;
    _min: CouponCourseMinAggregateOutputType | null;
    _max: CouponCourseMaxAggregateOutputType | null;
  };

  export type CouponCourseAvgAggregateOutputType = {
    idCoupon: number | null;
    idCourse: number | null;
  };

  export type CouponCourseSumAggregateOutputType = {
    idCoupon: number | null;
    idCourse: number | null;
  };

  export type CouponCourseMinAggregateOutputType = {
    idCoupon: number | null;
    idCourse: number | null;
  };

  export type CouponCourseMaxAggregateOutputType = {
    idCoupon: number | null;
    idCourse: number | null;
  };

  export type CouponCourseCountAggregateOutputType = {
    idCoupon: number;
    idCourse: number;
    _all: number;
  };

  export type CouponCourseAvgAggregateInputType = {
    idCoupon?: true;
    idCourse?: true;
  };

  export type CouponCourseSumAggregateInputType = {
    idCoupon?: true;
    idCourse?: true;
  };

  export type CouponCourseMinAggregateInputType = {
    idCoupon?: true;
    idCourse?: true;
  };

  export type CouponCourseMaxAggregateInputType = {
    idCoupon?: true;
    idCourse?: true;
  };

  export type CouponCourseCountAggregateInputType = {
    idCoupon?: true;
    idCourse?: true;
    _all?: true;
  };

  export type CouponCourseAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which CouponCourse to aggregate.
     */
    where?: CouponCourseWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CouponCourses to fetch.
     */
    orderBy?:
      | CouponCourseOrderByWithRelationInput
      | CouponCourseOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CouponCourseWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CouponCourses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CouponCourses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CouponCourses
     **/
    _count?: true | CouponCourseCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CouponCourseAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CouponCourseSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CouponCourseMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CouponCourseMaxAggregateInputType;
  };

  export type GetCouponCourseAggregateType<
    T extends CouponCourseAggregateArgs
  > = {
    [P in keyof T & keyof AggregateCouponCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCouponCourse[P]>
      : GetScalarType<T[P], AggregateCouponCourse[P]>;
  };

  export type CouponCourseGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CouponCourseWhereInput;
    orderBy?:
      | CouponCourseOrderByWithAggregationInput
      | CouponCourseOrderByWithAggregationInput[];
    by: CouponCourseScalarFieldEnum[] | CouponCourseScalarFieldEnum;
    having?: CouponCourseScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CouponCourseCountAggregateInputType | true;
    _avg?: CouponCourseAvgAggregateInputType;
    _sum?: CouponCourseSumAggregateInputType;
    _min?: CouponCourseMinAggregateInputType;
    _max?: CouponCourseMaxAggregateInputType;
  };

  export type CouponCourseGroupByOutputType = {
    idCoupon: number;
    idCourse: number;
    _count: CouponCourseCountAggregateOutputType | null;
    _avg: CouponCourseAvgAggregateOutputType | null;
    _sum: CouponCourseSumAggregateOutputType | null;
    _min: CouponCourseMinAggregateOutputType | null;
    _max: CouponCourseMaxAggregateOutputType | null;
  };

  type GetCouponCourseGroupByPayload<T extends CouponCourseGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CouponCourseGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof CouponCourseGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponCourseGroupByOutputType[P]>
            : GetScalarType<T[P], CouponCourseGroupByOutputType[P]>;
        }
      >
    >;

  export type CouponCourseSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idCoupon?: boolean;
      idCourse?: boolean;
      Coupon?: boolean | CouponDefaultArgs<ExtArgs>;
      Course?: boolean | CourseDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['couponCourse']
  >;

  export type CouponCourseSelectScalar = {
    idCoupon?: boolean;
    idCourse?: boolean;
  };

  export type CouponCourseOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idCoupon' | 'idCourse',
    ExtArgs['result']['couponCourse']
  >;
  export type CouponCourseInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Coupon?: boolean | CouponDefaultArgs<ExtArgs>;
    Course?: boolean | CourseDefaultArgs<ExtArgs>;
  };

  export type $CouponCoursePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'CouponCourse';
    objects: {
      Coupon: Prisma.$CouponPayload<ExtArgs>;
      Course: Prisma.$CoursePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idCoupon: number;
        idCourse: number;
      },
      ExtArgs['result']['couponCourse']
    >;
    composites: {};
  };

  type CouponCourseGetPayload<
    S extends boolean | null | undefined | CouponCourseDefaultArgs
  > = $Result.GetResult<Prisma.$CouponCoursePayload, S>;

  type CouponCourseCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    CouponCourseFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: CouponCourseCountAggregateInputType | true;
  };

  export interface CouponCourseDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['CouponCourse'];
      meta: { name: 'CouponCourse' };
    };
    /**
     * Find zero or one CouponCourse that matches the filter.
     * @param {CouponCourseFindUniqueArgs} args - Arguments to find a CouponCourse
     * @example
     * // Get one CouponCourse
     * const couponCourse = await prisma.couponCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponCourseFindUniqueArgs>(
      args: SelectSubset<T, CouponCourseFindUniqueArgs<ExtArgs>>
    ): Prisma__CouponCourseClient<
      $Result.GetResult<
        Prisma.$CouponCoursePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one CouponCourse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CouponCourseFindUniqueOrThrowArgs} args - Arguments to find a CouponCourse
     * @example
     * // Get one CouponCourse
     * const couponCourse = await prisma.couponCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponCourseFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CouponCourseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CouponCourseClient<
      $Result.GetResult<
        Prisma.$CouponCoursePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CouponCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCourseFindFirstArgs} args - Arguments to find a CouponCourse
     * @example
     * // Get one CouponCourse
     * const couponCourse = await prisma.couponCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponCourseFindFirstArgs>(
      args?: SelectSubset<T, CouponCourseFindFirstArgs<ExtArgs>>
    ): Prisma__CouponCourseClient<
      $Result.GetResult<
        Prisma.$CouponCoursePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CouponCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCourseFindFirstOrThrowArgs} args - Arguments to find a CouponCourse
     * @example
     * // Get one CouponCourse
     * const couponCourse = await prisma.couponCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponCourseFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CouponCourseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CouponCourseClient<
      $Result.GetResult<
        Prisma.$CouponCoursePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more CouponCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CouponCourses
     * const couponCourses = await prisma.couponCourse.findMany()
     *
     * // Get first 10 CouponCourses
     * const couponCourses = await prisma.couponCourse.findMany({ take: 10 })
     *
     * // Only select the `idCoupon`
     * const couponCourseWithIdCouponOnly = await prisma.couponCourse.findMany({ select: { idCoupon: true } })
     *
     */
    findMany<T extends CouponCourseFindManyArgs>(
      args?: SelectSubset<T, CouponCourseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CouponCoursePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a CouponCourse.
     * @param {CouponCourseCreateArgs} args - Arguments to create a CouponCourse.
     * @example
     * // Create one CouponCourse
     * const CouponCourse = await prisma.couponCourse.create({
     *   data: {
     *     // ... data to create a CouponCourse
     *   }
     * })
     *
     */
    create<T extends CouponCourseCreateArgs>(
      args: SelectSubset<T, CouponCourseCreateArgs<ExtArgs>>
    ): Prisma__CouponCourseClient<
      $Result.GetResult<
        Prisma.$CouponCoursePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many CouponCourses.
     * @param {CouponCourseCreateManyArgs} args - Arguments to create many CouponCourses.
     * @example
     * // Create many CouponCourses
     * const couponCourse = await prisma.couponCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CouponCourseCreateManyArgs>(
      args?: SelectSubset<T, CouponCourseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a CouponCourse.
     * @param {CouponCourseDeleteArgs} args - Arguments to delete one CouponCourse.
     * @example
     * // Delete one CouponCourse
     * const CouponCourse = await prisma.couponCourse.delete({
     *   where: {
     *     // ... filter to delete one CouponCourse
     *   }
     * })
     *
     */
    delete<T extends CouponCourseDeleteArgs>(
      args: SelectSubset<T, CouponCourseDeleteArgs<ExtArgs>>
    ): Prisma__CouponCourseClient<
      $Result.GetResult<
        Prisma.$CouponCoursePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one CouponCourse.
     * @param {CouponCourseUpdateArgs} args - Arguments to update one CouponCourse.
     * @example
     * // Update one CouponCourse
     * const couponCourse = await prisma.couponCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CouponCourseUpdateArgs>(
      args: SelectSubset<T, CouponCourseUpdateArgs<ExtArgs>>
    ): Prisma__CouponCourseClient<
      $Result.GetResult<
        Prisma.$CouponCoursePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more CouponCourses.
     * @param {CouponCourseDeleteManyArgs} args - Arguments to filter CouponCourses to delete.
     * @example
     * // Delete a few CouponCourses
     * const { count } = await prisma.couponCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CouponCourseDeleteManyArgs>(
      args?: SelectSubset<T, CouponCourseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more CouponCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CouponCourses
     * const couponCourse = await prisma.couponCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CouponCourseUpdateManyArgs>(
      args: SelectSubset<T, CouponCourseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one CouponCourse.
     * @param {CouponCourseUpsertArgs} args - Arguments to update or create a CouponCourse.
     * @example
     * // Update or create a CouponCourse
     * const couponCourse = await prisma.couponCourse.upsert({
     *   create: {
     *     // ... data to create a CouponCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CouponCourse we want to update
     *   }
     * })
     */
    upsert<T extends CouponCourseUpsertArgs>(
      args: SelectSubset<T, CouponCourseUpsertArgs<ExtArgs>>
    ): Prisma__CouponCourseClient<
      $Result.GetResult<
        Prisma.$CouponCoursePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of CouponCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCourseCountArgs} args - Arguments to filter CouponCourses to count.
     * @example
     * // Count the number of CouponCourses
     * const count = await prisma.couponCourse.count({
     *   where: {
     *     // ... the filter for the CouponCourses we want to count
     *   }
     * })
     **/
    count<T extends CouponCourseCountArgs>(
      args?: Subset<T, CouponCourseCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponCourseCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a CouponCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CouponCourseAggregateArgs>(
      args: Subset<T, CouponCourseAggregateArgs>
    ): Prisma.PrismaPromise<GetCouponCourseAggregateType<T>>;

    /**
     * Group by CouponCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CouponCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponCourseGroupByArgs['orderBy'] }
        : { orderBy?: CouponCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, CouponCourseGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetCouponCourseGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the CouponCourse model
     */
    readonly fields: CouponCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CouponCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponCourseClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Coupon<T extends CouponDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CouponDefaultArgs<ExtArgs>>
    ): Prisma__CouponClient<
      | $Result.GetResult<
          Prisma.$CouponPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    Course<T extends CourseDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CourseDefaultArgs<ExtArgs>>
    ): Prisma__CourseClient<
      | $Result.GetResult<
          Prisma.$CoursePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the CouponCourse model
   */
  interface CouponCourseFieldRefs {
    readonly idCoupon: FieldRef<'CouponCourse', 'Int'>;
    readonly idCourse: FieldRef<'CouponCourse', 'Int'>;
  }

  // Custom InputTypes
  /**
   * CouponCourse findUnique
   */
  export type CouponCourseFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CouponCourse
     */
    select?: CouponCourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CouponCourse
     */
    omit?: CouponCourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponCourseInclude<ExtArgs> | null;
    /**
     * Filter, which CouponCourse to fetch.
     */
    where: CouponCourseWhereUniqueInput;
  };

  /**
   * CouponCourse findUniqueOrThrow
   */
  export type CouponCourseFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CouponCourse
     */
    select?: CouponCourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CouponCourse
     */
    omit?: CouponCourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponCourseInclude<ExtArgs> | null;
    /**
     * Filter, which CouponCourse to fetch.
     */
    where: CouponCourseWhereUniqueInput;
  };

  /**
   * CouponCourse findFirst
   */
  export type CouponCourseFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CouponCourse
     */
    select?: CouponCourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CouponCourse
     */
    omit?: CouponCourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponCourseInclude<ExtArgs> | null;
    /**
     * Filter, which CouponCourse to fetch.
     */
    where?: CouponCourseWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CouponCourses to fetch.
     */
    orderBy?:
      | CouponCourseOrderByWithRelationInput
      | CouponCourseOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CouponCourses.
     */
    cursor?: CouponCourseWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CouponCourses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CouponCourses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CouponCourses.
     */
    distinct?: CouponCourseScalarFieldEnum | CouponCourseScalarFieldEnum[];
  };

  /**
   * CouponCourse findFirstOrThrow
   */
  export type CouponCourseFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CouponCourse
     */
    select?: CouponCourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CouponCourse
     */
    omit?: CouponCourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponCourseInclude<ExtArgs> | null;
    /**
     * Filter, which CouponCourse to fetch.
     */
    where?: CouponCourseWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CouponCourses to fetch.
     */
    orderBy?:
      | CouponCourseOrderByWithRelationInput
      | CouponCourseOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CouponCourses.
     */
    cursor?: CouponCourseWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CouponCourses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CouponCourses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CouponCourses.
     */
    distinct?: CouponCourseScalarFieldEnum | CouponCourseScalarFieldEnum[];
  };

  /**
   * CouponCourse findMany
   */
  export type CouponCourseFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CouponCourse
     */
    select?: CouponCourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CouponCourse
     */
    omit?: CouponCourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponCourseInclude<ExtArgs> | null;
    /**
     * Filter, which CouponCourses to fetch.
     */
    where?: CouponCourseWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CouponCourses to fetch.
     */
    orderBy?:
      | CouponCourseOrderByWithRelationInput
      | CouponCourseOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CouponCourses.
     */
    cursor?: CouponCourseWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CouponCourses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CouponCourses.
     */
    skip?: number;
    distinct?: CouponCourseScalarFieldEnum | CouponCourseScalarFieldEnum[];
  };

  /**
   * CouponCourse create
   */
  export type CouponCourseCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CouponCourse
     */
    select?: CouponCourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CouponCourse
     */
    omit?: CouponCourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponCourseInclude<ExtArgs> | null;
    /**
     * The data needed to create a CouponCourse.
     */
    data: XOR<CouponCourseCreateInput, CouponCourseUncheckedCreateInput>;
  };

  /**
   * CouponCourse createMany
   */
  export type CouponCourseCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many CouponCourses.
     */
    data: CouponCourseCreateManyInput | CouponCourseCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * CouponCourse update
   */
  export type CouponCourseUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CouponCourse
     */
    select?: CouponCourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CouponCourse
     */
    omit?: CouponCourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponCourseInclude<ExtArgs> | null;
    /**
     * The data needed to update a CouponCourse.
     */
    data: XOR<CouponCourseUpdateInput, CouponCourseUncheckedUpdateInput>;
    /**
     * Choose, which CouponCourse to update.
     */
    where: CouponCourseWhereUniqueInput;
  };

  /**
   * CouponCourse updateMany
   */
  export type CouponCourseUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update CouponCourses.
     */
    data: XOR<
      CouponCourseUpdateManyMutationInput,
      CouponCourseUncheckedUpdateManyInput
    >;
    /**
     * Filter which CouponCourses to update
     */
    where?: CouponCourseWhereInput;
    /**
     * Limit how many CouponCourses to update.
     */
    limit?: number;
  };

  /**
   * CouponCourse upsert
   */
  export type CouponCourseUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CouponCourse
     */
    select?: CouponCourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CouponCourse
     */
    omit?: CouponCourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponCourseInclude<ExtArgs> | null;
    /**
     * The filter to search for the CouponCourse to update in case it exists.
     */
    where: CouponCourseWhereUniqueInput;
    /**
     * In case the CouponCourse found by the `where` argument doesn't exist, create a new CouponCourse with this data.
     */
    create: XOR<CouponCourseCreateInput, CouponCourseUncheckedCreateInput>;
    /**
     * In case the CouponCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponCourseUpdateInput, CouponCourseUncheckedUpdateInput>;
  };

  /**
   * CouponCourse delete
   */
  export type CouponCourseDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CouponCourse
     */
    select?: CouponCourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CouponCourse
     */
    omit?: CouponCourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponCourseInclude<ExtArgs> | null;
    /**
     * Filter which CouponCourse to delete.
     */
    where: CouponCourseWhereUniqueInput;
  };

  /**
   * CouponCourse deleteMany
   */
  export type CouponCourseDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which CouponCourses to delete
     */
    where?: CouponCourseWhereInput;
    /**
     * Limit how many CouponCourses to delete.
     */
    limit?: number;
  };

  /**
   * CouponCourse without action
   */
  export type CouponCourseDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CouponCourse
     */
    select?: CouponCourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CouponCourse
     */
    omit?: CouponCourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponCourseInclude<ExtArgs> | null;
  };

  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null;
    _avg: CourseAvgAggregateOutputType | null;
    _sum: CourseSumAggregateOutputType | null;
    _min: CourseMinAggregateOutputType | null;
    _max: CourseMaxAggregateOutputType | null;
  };

  export type CourseAvgAggregateOutputType = {
    idCourse: number | null;
    idUser: number | null;
    price: Decimal | null;
  };

  export type CourseSumAggregateOutputType = {
    idCourse: number | null;
    idUser: number | null;
    price: Decimal | null;
  };

  export type CourseMinAggregateOutputType = {
    idCourse: number | null;
    idUser: number | null;
    title: string | null;
    subTitle: string | null;
    description: string | null;
    price: Decimal | null;
    isPublic: boolean | null;
    isAccepted: boolean | null;
    thumbnail: string | null;
    requirement: string | null;
    targetAudience: string | null;
  };

  export type CourseMaxAggregateOutputType = {
    idCourse: number | null;
    idUser: number | null;
    title: string | null;
    subTitle: string | null;
    description: string | null;
    price: Decimal | null;
    isPublic: boolean | null;
    isAccepted: boolean | null;
    thumbnail: string | null;
    requirement: string | null;
    targetAudience: string | null;
  };

  export type CourseCountAggregateOutputType = {
    idCourse: number;
    idUser: number;
    title: number;
    subTitle: number;
    description: number;
    price: number;
    isPublic: number;
    isAccepted: number;
    thumbnail: number;
    requirement: number;
    targetAudience: number;
    _all: number;
  };

  export type CourseAvgAggregateInputType = {
    idCourse?: true;
    idUser?: true;
    price?: true;
  };

  export type CourseSumAggregateInputType = {
    idCourse?: true;
    idUser?: true;
    price?: true;
  };

  export type CourseMinAggregateInputType = {
    idCourse?: true;
    idUser?: true;
    title?: true;
    subTitle?: true;
    description?: true;
    price?: true;
    isPublic?: true;
    isAccepted?: true;
    thumbnail?: true;
    requirement?: true;
    targetAudience?: true;
  };

  export type CourseMaxAggregateInputType = {
    idCourse?: true;
    idUser?: true;
    title?: true;
    subTitle?: true;
    description?: true;
    price?: true;
    isPublic?: true;
    isAccepted?: true;
    thumbnail?: true;
    requirement?: true;
    targetAudience?: true;
  };

  export type CourseCountAggregateInputType = {
    idCourse?: true;
    idUser?: true;
    title?: true;
    subTitle?: true;
    description?: true;
    price?: true;
    isPublic?: true;
    isAccepted?: true;
    thumbnail?: true;
    requirement?: true;
    targetAudience?: true;
    _all?: true;
  };

  export type CourseAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Courses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Courses
     **/
    _count?: true | CourseCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CourseAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CourseSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CourseMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CourseMaxAggregateInputType;
  };

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
    [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>;
  };

  export type CourseGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CourseWhereInput;
    orderBy?:
      | CourseOrderByWithAggregationInput
      | CourseOrderByWithAggregationInput[];
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum;
    having?: CourseScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CourseCountAggregateInputType | true;
    _avg?: CourseAvgAggregateInputType;
    _sum?: CourseSumAggregateInputType;
    _min?: CourseMinAggregateInputType;
    _max?: CourseMaxAggregateInputType;
  };

  export type CourseGroupByOutputType = {
    idCourse: number;
    idUser: number | null;
    title: string | null;
    subTitle: string | null;
    description: string | null;
    price: Decimal | null;
    isPublic: boolean | null;
    isAccepted: boolean | null;
    thumbnail: string | null;
    requirement: string | null;
    targetAudience: string | null;
    _count: CourseCountAggregateOutputType | null;
    _avg: CourseAvgAggregateOutputType | null;
    _sum: CourseSumAggregateOutputType | null;
    _min: CourseMinAggregateOutputType | null;
    _max: CourseMaxAggregateOutputType | null;
  };

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CourseGroupByOutputType, T['by']> & {
          [P in keyof T & keyof CourseGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>;
        }
      >
    >;

  export type CourseSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idCourse?: boolean;
      idUser?: boolean;
      title?: boolean;
      subTitle?: boolean;
      description?: boolean;
      price?: boolean;
      isPublic?: boolean;
      isAccepted?: boolean;
      thumbnail?: boolean;
      requirement?: boolean;
      targetAudience?: boolean;
      Cart?: boolean | Course$CartArgs<ExtArgs>;
      Certificate?: boolean | Course$CertificateArgs<ExtArgs>;
      CouponCourse?: boolean | Course$CouponCourseArgs<ExtArgs>;
      User?: boolean | Course$UserArgs<ExtArgs>;
      CourseCategory?: boolean | Course$CourseCategoryArgs<ExtArgs>;
      CourseObjective?: boolean | Course$CourseObjectiveArgs<ExtArgs>;
      Enrollment?: boolean | Course$EnrollmentArgs<ExtArgs>;
      PaymentDetail?: boolean | Course$PaymentDetailArgs<ExtArgs>;
      Review?: boolean | Course$ReviewArgs<ExtArgs>;
      Section?: boolean | Course$SectionArgs<ExtArgs>;
      StudyRemind?: boolean | Course$StudyRemindArgs<ExtArgs>;
      Wishlist?: boolean | Course$WishlistArgs<ExtArgs>;
      _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['course']
  >;

  export type CourseSelectScalar = {
    idCourse?: boolean;
    idUser?: boolean;
    title?: boolean;
    subTitle?: boolean;
    description?: boolean;
    price?: boolean;
    isPublic?: boolean;
    isAccepted?: boolean;
    thumbnail?: boolean;
    requirement?: boolean;
    targetAudience?: boolean;
  };

  export type CourseOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'idCourse'
    | 'idUser'
    | 'title'
    | 'subTitle'
    | 'description'
    | 'price'
    | 'isPublic'
    | 'isAccepted'
    | 'thumbnail'
    | 'requirement'
    | 'targetAudience',
    ExtArgs['result']['course']
  >;
  export type CourseInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Cart?: boolean | Course$CartArgs<ExtArgs>;
    Certificate?: boolean | Course$CertificateArgs<ExtArgs>;
    CouponCourse?: boolean | Course$CouponCourseArgs<ExtArgs>;
    User?: boolean | Course$UserArgs<ExtArgs>;
    CourseCategory?: boolean | Course$CourseCategoryArgs<ExtArgs>;
    CourseObjective?: boolean | Course$CourseObjectiveArgs<ExtArgs>;
    Enrollment?: boolean | Course$EnrollmentArgs<ExtArgs>;
    PaymentDetail?: boolean | Course$PaymentDetailArgs<ExtArgs>;
    Review?: boolean | Course$ReviewArgs<ExtArgs>;
    Section?: boolean | Course$SectionArgs<ExtArgs>;
    StudyRemind?: boolean | Course$StudyRemindArgs<ExtArgs>;
    Wishlist?: boolean | Course$WishlistArgs<ExtArgs>;
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $CoursePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Course';
    objects: {
      Cart: Prisma.$CartPayload<ExtArgs>[];
      Certificate: Prisma.$CertificatePayload<ExtArgs> | null;
      CouponCourse: Prisma.$CouponCoursePayload<ExtArgs>[];
      User: Prisma.$UserPayload<ExtArgs> | null;
      CourseCategory: Prisma.$CourseCategoryPayload<ExtArgs>[];
      CourseObjective: Prisma.$CourseObjectivePayload<ExtArgs>[];
      Enrollment: Prisma.$EnrollmentPayload<ExtArgs>[];
      PaymentDetail: Prisma.$PaymentDetailPayload<ExtArgs>[];
      Review: Prisma.$ReviewPayload<ExtArgs>[];
      Section: Prisma.$SectionPayload<ExtArgs>[];
      StudyRemind: Prisma.$StudyRemindPayload<ExtArgs>[];
      Wishlist: Prisma.$WishlistPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idCourse: number;
        idUser: number | null;
        title: string | null;
        subTitle: string | null;
        description: string | null;
        price: Prisma.Decimal | null;
        isPublic: boolean | null;
        isAccepted: boolean | null;
        thumbnail: string | null;
        requirement: string | null;
        targetAudience: string | null;
      },
      ExtArgs['result']['course']
    >;
    composites: {};
  };

  type CourseGetPayload<
    S extends boolean | null | undefined | CourseDefaultArgs
  > = $Result.GetResult<Prisma.$CoursePayload, S>;

  type CourseCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: CourseCountAggregateInputType | true;
  };

  export interface CourseDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Course'];
      meta: { name: 'Course' };
    };
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(
      args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>
    ): Prisma__CourseClient<
      $Result.GetResult<
        Prisma.$CoursePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CourseClient<
      $Result.GetResult<
        Prisma.$CoursePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(
      args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>
    ): Prisma__CourseClient<
      $Result.GetResult<
        Prisma.$CoursePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CourseClient<
      $Result.GetResult<
        Prisma.$CoursePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     *
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     *
     * // Only select the `idCourse`
     * const courseWithIdCourseOnly = await prisma.course.findMany({ select: { idCourse: true } })
     *
     */
    findMany<T extends CourseFindManyArgs>(
      args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CoursePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     *
     */
    create<T extends CourseCreateArgs>(
      args: SelectSubset<T, CourseCreateArgs<ExtArgs>>
    ): Prisma__CourseClient<
      $Result.GetResult<
        Prisma.$CoursePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CourseCreateManyArgs>(
      args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     *
     */
    delete<T extends CourseDeleteArgs>(
      args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>
    ): Prisma__CourseClient<
      $Result.GetResult<
        Prisma.$CoursePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CourseUpdateArgs>(
      args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>
    ): Prisma__CourseClient<
      $Result.GetResult<
        Prisma.$CoursePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CourseDeleteManyArgs>(
      args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CourseUpdateManyArgs>(
      args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(
      args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>
    ): Prisma__CourseClient<
      $Result.GetResult<
        Prisma.$CoursePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
     **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CourseAggregateArgs>(
      args: Subset<T, CourseAggregateArgs>
    ): Prisma.PrismaPromise<GetCourseAggregateType<T>>;

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetCourseGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Course model
     */
    readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Cart<T extends Course$CartArgs<ExtArgs> = {}>(
      args?: Subset<T, Course$CartArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CartPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Certificate<T extends Course$CertificateArgs<ExtArgs> = {}>(
      args?: Subset<T, Course$CertificateArgs<ExtArgs>>
    ): Prisma__CertificateClient<
      $Result.GetResult<
        Prisma.$CertificatePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    CouponCourse<T extends Course$CouponCourseArgs<ExtArgs> = {}>(
      args?: Subset<T, Course$CouponCourseArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CouponCoursePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    User<T extends Course$UserArgs<ExtArgs> = {}>(
      args?: Subset<T, Course$UserArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    CourseCategory<T extends Course$CourseCategoryArgs<ExtArgs> = {}>(
      args?: Subset<T, Course$CourseCategoryArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CourseCategoryPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    CourseObjective<T extends Course$CourseObjectiveArgs<ExtArgs> = {}>(
      args?: Subset<T, Course$CourseObjectiveArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CourseObjectivePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Enrollment<T extends Course$EnrollmentArgs<ExtArgs> = {}>(
      args?: Subset<T, Course$EnrollmentArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$EnrollmentPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    PaymentDetail<T extends Course$PaymentDetailArgs<ExtArgs> = {}>(
      args?: Subset<T, Course$PaymentDetailArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PaymentDetailPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Review<T extends Course$ReviewArgs<ExtArgs> = {}>(
      args?: Subset<T, Course$ReviewArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ReviewPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Section<T extends Course$SectionArgs<ExtArgs> = {}>(
      args?: Subset<T, Course$SectionArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$SectionPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    StudyRemind<T extends Course$StudyRemindArgs<ExtArgs> = {}>(
      args?: Subset<T, Course$StudyRemindArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$StudyRemindPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Wishlist<T extends Course$WishlistArgs<ExtArgs> = {}>(
      args?: Subset<T, Course$WishlistArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$WishlistPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly idCourse: FieldRef<'Course', 'Int'>;
    readonly idUser: FieldRef<'Course', 'Int'>;
    readonly title: FieldRef<'Course', 'String'>;
    readonly subTitle: FieldRef<'Course', 'String'>;
    readonly description: FieldRef<'Course', 'String'>;
    readonly price: FieldRef<'Course', 'Decimal'>;
    readonly isPublic: FieldRef<'Course', 'Boolean'>;
    readonly isAccepted: FieldRef<'Course', 'Boolean'>;
    readonly thumbnail: FieldRef<'Course', 'String'>;
    readonly requirement: FieldRef<'Course', 'String'>;
    readonly targetAudience: FieldRef<'Course', 'String'>;
  }

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null;
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput;
  };

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null;
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput;
  };

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null;
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Courses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[];
  };

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null;
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Courses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[];
  };

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null;
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Courses.
     */
    skip?: number;
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[];
  };

  /**
   * Course create
   */
  export type CourseCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null;
    /**
     * The data needed to create a Course.
     */
    data?: XOR<CourseCreateInput, CourseUncheckedCreateInput>;
  };

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Course update
   */
  export type CourseUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null;
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>;
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput;
  };

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>;
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput;
    /**
     * Limit how many Courses to update.
     */
    limit?: number;
  };

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null;
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput;
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>;
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>;
  };

  /**
   * Course delete
   */
  export type CourseDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null;
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput;
  };

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput;
    /**
     * Limit how many Courses to delete.
     */
    limit?: number;
  };

  /**
   * Course.Cart
   */
  export type Course$CartArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    where?: CartWhereInput;
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[];
    cursor?: CartWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[];
  };

  /**
   * Course.Certificate
   */
  export type Course$CertificateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null;
    where?: CertificateWhereInput;
  };

  /**
   * Course.CouponCourse
   */
  export type Course$CouponCourseArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CouponCourse
     */
    select?: CouponCourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CouponCourse
     */
    omit?: CouponCourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponCourseInclude<ExtArgs> | null;
    where?: CouponCourseWhereInput;
    orderBy?:
      | CouponCourseOrderByWithRelationInput
      | CouponCourseOrderByWithRelationInput[];
    cursor?: CouponCourseWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CouponCourseScalarFieldEnum | CouponCourseScalarFieldEnum[];
  };

  /**
   * Course.User
   */
  export type Course$UserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Course.CourseCategory
   */
  export type Course$CourseCategoryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null;
    where?: CourseCategoryWhereInput;
    orderBy?:
      | CourseCategoryOrderByWithRelationInput
      | CourseCategoryOrderByWithRelationInput[];
    cursor?: CourseCategoryWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CourseCategoryScalarFieldEnum | CourseCategoryScalarFieldEnum[];
  };

  /**
   * Course.CourseObjective
   */
  export type Course$CourseObjectiveArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null;
    where?: CourseObjectiveWhereInput;
    orderBy?:
      | CourseObjectiveOrderByWithRelationInput
      | CourseObjectiveOrderByWithRelationInput[];
    cursor?: CourseObjectiveWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | CourseObjectiveScalarFieldEnum
      | CourseObjectiveScalarFieldEnum[];
  };

  /**
   * Course.Enrollment
   */
  export type Course$EnrollmentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null;
    where?: EnrollmentWhereInput;
    orderBy?:
      | EnrollmentOrderByWithRelationInput
      | EnrollmentOrderByWithRelationInput[];
    cursor?: EnrollmentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[];
  };

  /**
   * Course.PaymentDetail
   */
  export type Course$PaymentDetailArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null;
    where?: PaymentDetailWhereInput;
    orderBy?:
      | PaymentDetailOrderByWithRelationInput
      | PaymentDetailOrderByWithRelationInput[];
    cursor?: PaymentDetailWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PaymentDetailScalarFieldEnum | PaymentDetailScalarFieldEnum[];
  };

  /**
   * Course.Review
   */
  export type Course$ReviewArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    cursor?: ReviewWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * Course.Section
   */
  export type Course$SectionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null;
    where?: SectionWhereInput;
    orderBy?:
      | SectionOrderByWithRelationInput
      | SectionOrderByWithRelationInput[];
    cursor?: SectionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[];
  };

  /**
   * Course.StudyRemind
   */
  export type Course$StudyRemindArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the StudyRemind
     */
    select?: StudyRemindSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudyRemind
     */
    omit?: StudyRemindOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRemindInclude<ExtArgs> | null;
    where?: StudyRemindWhereInput;
    orderBy?:
      | StudyRemindOrderByWithRelationInput
      | StudyRemindOrderByWithRelationInput[];
    cursor?: StudyRemindWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: StudyRemindScalarFieldEnum | StudyRemindScalarFieldEnum[];
  };

  /**
   * Course.Wishlist
   */
  export type Course$WishlistArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    where?: WishlistWhereInput;
    orderBy?:
      | WishlistOrderByWithRelationInput
      | WishlistOrderByWithRelationInput[];
    cursor?: WishlistWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[];
  };

  /**
   * Course without action
   */
  export type CourseDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null;
  };

  /**
   * Model CourseCategory
   */

  export type AggregateCourseCategory = {
    _count: CourseCategoryCountAggregateOutputType | null;
    _avg: CourseCategoryAvgAggregateOutputType | null;
    _sum: CourseCategorySumAggregateOutputType | null;
    _min: CourseCategoryMinAggregateOutputType | null;
    _max: CourseCategoryMaxAggregateOutputType | null;
  };

  export type CourseCategoryAvgAggregateOutputType = {
    idCourse: number | null;
    idCategory: number | null;
  };

  export type CourseCategorySumAggregateOutputType = {
    idCourse: number | null;
    idCategory: number | null;
  };

  export type CourseCategoryMinAggregateOutputType = {
    idCourse: number | null;
    idCategory: number | null;
  };

  export type CourseCategoryMaxAggregateOutputType = {
    idCourse: number | null;
    idCategory: number | null;
  };

  export type CourseCategoryCountAggregateOutputType = {
    idCourse: number;
    idCategory: number;
    _all: number;
  };

  export type CourseCategoryAvgAggregateInputType = {
    idCourse?: true;
    idCategory?: true;
  };

  export type CourseCategorySumAggregateInputType = {
    idCourse?: true;
    idCategory?: true;
  };

  export type CourseCategoryMinAggregateInputType = {
    idCourse?: true;
    idCategory?: true;
  };

  export type CourseCategoryMaxAggregateInputType = {
    idCourse?: true;
    idCategory?: true;
  };

  export type CourseCategoryCountAggregateInputType = {
    idCourse?: true;
    idCategory?: true;
    _all?: true;
  };

  export type CourseCategoryAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which CourseCategory to aggregate.
     */
    where?: CourseCategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CourseCategories to fetch.
     */
    orderBy?:
      | CourseCategoryOrderByWithRelationInput
      | CourseCategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CourseCategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CourseCategories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CourseCategories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CourseCategories
     **/
    _count?: true | CourseCategoryCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CourseCategoryAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CourseCategorySumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CourseCategoryMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CourseCategoryMaxAggregateInputType;
  };

  export type GetCourseCategoryAggregateType<
    T extends CourseCategoryAggregateArgs
  > = {
    [P in keyof T & keyof AggregateCourseCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseCategory[P]>
      : GetScalarType<T[P], AggregateCourseCategory[P]>;
  };

  export type CourseCategoryGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CourseCategoryWhereInput;
    orderBy?:
      | CourseCategoryOrderByWithAggregationInput
      | CourseCategoryOrderByWithAggregationInput[];
    by: CourseCategoryScalarFieldEnum[] | CourseCategoryScalarFieldEnum;
    having?: CourseCategoryScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CourseCategoryCountAggregateInputType | true;
    _avg?: CourseCategoryAvgAggregateInputType;
    _sum?: CourseCategorySumAggregateInputType;
    _min?: CourseCategoryMinAggregateInputType;
    _max?: CourseCategoryMaxAggregateInputType;
  };

  export type CourseCategoryGroupByOutputType = {
    idCourse: number;
    idCategory: number;
    _count: CourseCategoryCountAggregateOutputType | null;
    _avg: CourseCategoryAvgAggregateOutputType | null;
    _sum: CourseCategorySumAggregateOutputType | null;
    _min: CourseCategoryMinAggregateOutputType | null;
    _max: CourseCategoryMaxAggregateOutputType | null;
  };

  type GetCourseCategoryGroupByPayload<T extends CourseCategoryGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CourseCategoryGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof CourseCategoryGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CourseCategoryGroupByOutputType[P]>;
        }
      >
    >;

  export type CourseCategorySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idCourse?: boolean;
      idCategory?: boolean;
      Category?: boolean | CategoryDefaultArgs<ExtArgs>;
      Course?: boolean | CourseDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['courseCategory']
  >;

  export type CourseCategorySelectScalar = {
    idCourse?: boolean;
    idCategory?: boolean;
  };

  export type CourseCategoryOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idCourse' | 'idCategory',
    ExtArgs['result']['courseCategory']
  >;
  export type CourseCategoryInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Category?: boolean | CategoryDefaultArgs<ExtArgs>;
    Course?: boolean | CourseDefaultArgs<ExtArgs>;
  };

  export type $CourseCategoryPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'CourseCategory';
    objects: {
      Category: Prisma.$CategoryPayload<ExtArgs>;
      Course: Prisma.$CoursePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idCourse: number;
        idCategory: number;
      },
      ExtArgs['result']['courseCategory']
    >;
    composites: {};
  };

  type CourseCategoryGetPayload<
    S extends boolean | null | undefined | CourseCategoryDefaultArgs
  > = $Result.GetResult<Prisma.$CourseCategoryPayload, S>;

  type CourseCategoryCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    CourseCategoryFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: CourseCategoryCountAggregateInputType | true;
  };

  export interface CourseCategoryDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['CourseCategory'];
      meta: { name: 'CourseCategory' };
    };
    /**
     * Find zero or one CourseCategory that matches the filter.
     * @param {CourseCategoryFindUniqueArgs} args - Arguments to find a CourseCategory
     * @example
     * // Get one CourseCategory
     * const courseCategory = await prisma.courseCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseCategoryFindUniqueArgs>(
      args: SelectSubset<T, CourseCategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__CourseCategoryClient<
      $Result.GetResult<
        Prisma.$CourseCategoryPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one CourseCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseCategoryFindUniqueOrThrowArgs} args - Arguments to find a CourseCategory
     * @example
     * // Get one CourseCategory
     * const courseCategory = await prisma.courseCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseCategoryFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CourseCategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CourseCategoryClient<
      $Result.GetResult<
        Prisma.$CourseCategoryPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CourseCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCategoryFindFirstArgs} args - Arguments to find a CourseCategory
     * @example
     * // Get one CourseCategory
     * const courseCategory = await prisma.courseCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseCategoryFindFirstArgs>(
      args?: SelectSubset<T, CourseCategoryFindFirstArgs<ExtArgs>>
    ): Prisma__CourseCategoryClient<
      $Result.GetResult<
        Prisma.$CourseCategoryPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CourseCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCategoryFindFirstOrThrowArgs} args - Arguments to find a CourseCategory
     * @example
     * // Get one CourseCategory
     * const courseCategory = await prisma.courseCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CourseCategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CourseCategoryClient<
      $Result.GetResult<
        Prisma.$CourseCategoryPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more CourseCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseCategories
     * const courseCategories = await prisma.courseCategory.findMany()
     *
     * // Get first 10 CourseCategories
     * const courseCategories = await prisma.courseCategory.findMany({ take: 10 })
     *
     * // Only select the `idCourse`
     * const courseCategoryWithIdCourseOnly = await prisma.courseCategory.findMany({ select: { idCourse: true } })
     *
     */
    findMany<T extends CourseCategoryFindManyArgs>(
      args?: SelectSubset<T, CourseCategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CourseCategoryPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a CourseCategory.
     * @param {CourseCategoryCreateArgs} args - Arguments to create a CourseCategory.
     * @example
     * // Create one CourseCategory
     * const CourseCategory = await prisma.courseCategory.create({
     *   data: {
     *     // ... data to create a CourseCategory
     *   }
     * })
     *
     */
    create<T extends CourseCategoryCreateArgs>(
      args: SelectSubset<T, CourseCategoryCreateArgs<ExtArgs>>
    ): Prisma__CourseCategoryClient<
      $Result.GetResult<
        Prisma.$CourseCategoryPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many CourseCategories.
     * @param {CourseCategoryCreateManyArgs} args - Arguments to create many CourseCategories.
     * @example
     * // Create many CourseCategories
     * const courseCategory = await prisma.courseCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CourseCategoryCreateManyArgs>(
      args?: SelectSubset<T, CourseCategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a CourseCategory.
     * @param {CourseCategoryDeleteArgs} args - Arguments to delete one CourseCategory.
     * @example
     * // Delete one CourseCategory
     * const CourseCategory = await prisma.courseCategory.delete({
     *   where: {
     *     // ... filter to delete one CourseCategory
     *   }
     * })
     *
     */
    delete<T extends CourseCategoryDeleteArgs>(
      args: SelectSubset<T, CourseCategoryDeleteArgs<ExtArgs>>
    ): Prisma__CourseCategoryClient<
      $Result.GetResult<
        Prisma.$CourseCategoryPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one CourseCategory.
     * @param {CourseCategoryUpdateArgs} args - Arguments to update one CourseCategory.
     * @example
     * // Update one CourseCategory
     * const courseCategory = await prisma.courseCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CourseCategoryUpdateArgs>(
      args: SelectSubset<T, CourseCategoryUpdateArgs<ExtArgs>>
    ): Prisma__CourseCategoryClient<
      $Result.GetResult<
        Prisma.$CourseCategoryPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more CourseCategories.
     * @param {CourseCategoryDeleteManyArgs} args - Arguments to filter CourseCategories to delete.
     * @example
     * // Delete a few CourseCategories
     * const { count } = await prisma.courseCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CourseCategoryDeleteManyArgs>(
      args?: SelectSubset<T, CourseCategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more CourseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseCategories
     * const courseCategory = await prisma.courseCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CourseCategoryUpdateManyArgs>(
      args: SelectSubset<T, CourseCategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one CourseCategory.
     * @param {CourseCategoryUpsertArgs} args - Arguments to update or create a CourseCategory.
     * @example
     * // Update or create a CourseCategory
     * const courseCategory = await prisma.courseCategory.upsert({
     *   create: {
     *     // ... data to create a CourseCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseCategory we want to update
     *   }
     * })
     */
    upsert<T extends CourseCategoryUpsertArgs>(
      args: SelectSubset<T, CourseCategoryUpsertArgs<ExtArgs>>
    ): Prisma__CourseCategoryClient<
      $Result.GetResult<
        Prisma.$CourseCategoryPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of CourseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCategoryCountArgs} args - Arguments to filter CourseCategories to count.
     * @example
     * // Count the number of CourseCategories
     * const count = await prisma.courseCategory.count({
     *   where: {
     *     // ... the filter for the CourseCategories we want to count
     *   }
     * })
     **/
    count<T extends CourseCategoryCountArgs>(
      args?: Subset<T, CourseCategoryCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCategoryCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a CourseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CourseCategoryAggregateArgs>(
      args: Subset<T, CourseCategoryAggregateArgs>
    ): Prisma.PrismaPromise<GetCourseCategoryAggregateType<T>>;

    /**
     * Group by CourseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CourseCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseCategoryGroupByArgs['orderBy'] }
        : { orderBy?: CourseCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, CourseCategoryGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetCourseCategoryGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the CourseCategory model
     */
    readonly fields: CourseCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseCategoryClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Category<T extends CategoryDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CategoryDefaultArgs<ExtArgs>>
    ): Prisma__CategoryClient<
      | $Result.GetResult<
          Prisma.$CategoryPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    Course<T extends CourseDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CourseDefaultArgs<ExtArgs>>
    ): Prisma__CourseClient<
      | $Result.GetResult<
          Prisma.$CoursePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the CourseCategory model
   */
  interface CourseCategoryFieldRefs {
    readonly idCourse: FieldRef<'CourseCategory', 'Int'>;
    readonly idCategory: FieldRef<'CourseCategory', 'Int'>;
  }

  // Custom InputTypes
  /**
   * CourseCategory findUnique
   */
  export type CourseCategoryFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null;
    /**
     * Filter, which CourseCategory to fetch.
     */
    where: CourseCategoryWhereUniqueInput;
  };

  /**
   * CourseCategory findUniqueOrThrow
   */
  export type CourseCategoryFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null;
    /**
     * Filter, which CourseCategory to fetch.
     */
    where: CourseCategoryWhereUniqueInput;
  };

  /**
   * CourseCategory findFirst
   */
  export type CourseCategoryFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null;
    /**
     * Filter, which CourseCategory to fetch.
     */
    where?: CourseCategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CourseCategories to fetch.
     */
    orderBy?:
      | CourseCategoryOrderByWithRelationInput
      | CourseCategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CourseCategories.
     */
    cursor?: CourseCategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CourseCategories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CourseCategories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CourseCategories.
     */
    distinct?: CourseCategoryScalarFieldEnum | CourseCategoryScalarFieldEnum[];
  };

  /**
   * CourseCategory findFirstOrThrow
   */
  export type CourseCategoryFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null;
    /**
     * Filter, which CourseCategory to fetch.
     */
    where?: CourseCategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CourseCategories to fetch.
     */
    orderBy?:
      | CourseCategoryOrderByWithRelationInput
      | CourseCategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CourseCategories.
     */
    cursor?: CourseCategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CourseCategories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CourseCategories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CourseCategories.
     */
    distinct?: CourseCategoryScalarFieldEnum | CourseCategoryScalarFieldEnum[];
  };

  /**
   * CourseCategory findMany
   */
  export type CourseCategoryFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null;
    /**
     * Filter, which CourseCategories to fetch.
     */
    where?: CourseCategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CourseCategories to fetch.
     */
    orderBy?:
      | CourseCategoryOrderByWithRelationInput
      | CourseCategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CourseCategories.
     */
    cursor?: CourseCategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CourseCategories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CourseCategories.
     */
    skip?: number;
    distinct?: CourseCategoryScalarFieldEnum | CourseCategoryScalarFieldEnum[];
  };

  /**
   * CourseCategory create
   */
  export type CourseCategoryCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null;
    /**
     * The data needed to create a CourseCategory.
     */
    data: XOR<CourseCategoryCreateInput, CourseCategoryUncheckedCreateInput>;
  };

  /**
   * CourseCategory createMany
   */
  export type CourseCategoryCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many CourseCategories.
     */
    data: CourseCategoryCreateManyInput | CourseCategoryCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * CourseCategory update
   */
  export type CourseCategoryUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null;
    /**
     * The data needed to update a CourseCategory.
     */
    data: XOR<CourseCategoryUpdateInput, CourseCategoryUncheckedUpdateInput>;
    /**
     * Choose, which CourseCategory to update.
     */
    where: CourseCategoryWhereUniqueInput;
  };

  /**
   * CourseCategory updateMany
   */
  export type CourseCategoryUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update CourseCategories.
     */
    data: XOR<
      CourseCategoryUpdateManyMutationInput,
      CourseCategoryUncheckedUpdateManyInput
    >;
    /**
     * Filter which CourseCategories to update
     */
    where?: CourseCategoryWhereInput;
    /**
     * Limit how many CourseCategories to update.
     */
    limit?: number;
  };

  /**
   * CourseCategory upsert
   */
  export type CourseCategoryUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null;
    /**
     * The filter to search for the CourseCategory to update in case it exists.
     */
    where: CourseCategoryWhereUniqueInput;
    /**
     * In case the CourseCategory found by the `where` argument doesn't exist, create a new CourseCategory with this data.
     */
    create: XOR<CourseCategoryCreateInput, CourseCategoryUncheckedCreateInput>;
    /**
     * In case the CourseCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseCategoryUpdateInput, CourseCategoryUncheckedUpdateInput>;
  };

  /**
   * CourseCategory delete
   */
  export type CourseCategoryDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null;
    /**
     * Filter which CourseCategory to delete.
     */
    where: CourseCategoryWhereUniqueInput;
  };

  /**
   * CourseCategory deleteMany
   */
  export type CourseCategoryDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which CourseCategories to delete
     */
    where?: CourseCategoryWhereInput;
    /**
     * Limit how many CourseCategories to delete.
     */
    limit?: number;
  };

  /**
   * CourseCategory without action
   */
  export type CourseCategoryDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null;
  };

  /**
   * Model CourseObjective
   */

  export type AggregateCourseObjective = {
    _count: CourseObjectiveCountAggregateOutputType | null;
    _avg: CourseObjectiveAvgAggregateOutputType | null;
    _sum: CourseObjectiveSumAggregateOutputType | null;
    _min: CourseObjectiveMinAggregateOutputType | null;
    _max: CourseObjectiveMaxAggregateOutputType | null;
  };

  export type CourseObjectiveAvgAggregateOutputType = {
    idCourse: number | null;
    idCourseObjective: number | null;
  };

  export type CourseObjectiveSumAggregateOutputType = {
    idCourse: number | null;
    idCourseObjective: number | null;
  };

  export type CourseObjectiveMinAggregateOutputType = {
    idCourse: number | null;
    idCourseObjective: number | null;
    content: string | null;
  };

  export type CourseObjectiveMaxAggregateOutputType = {
    idCourse: number | null;
    idCourseObjective: number | null;
    content: string | null;
  };

  export type CourseObjectiveCountAggregateOutputType = {
    idCourse: number;
    idCourseObjective: number;
    content: number;
    _all: number;
  };

  export type CourseObjectiveAvgAggregateInputType = {
    idCourse?: true;
    idCourseObjective?: true;
  };

  export type CourseObjectiveSumAggregateInputType = {
    idCourse?: true;
    idCourseObjective?: true;
  };

  export type CourseObjectiveMinAggregateInputType = {
    idCourse?: true;
    idCourseObjective?: true;
    content?: true;
  };

  export type CourseObjectiveMaxAggregateInputType = {
    idCourse?: true;
    idCourseObjective?: true;
    content?: true;
  };

  export type CourseObjectiveCountAggregateInputType = {
    idCourse?: true;
    idCourseObjective?: true;
    content?: true;
    _all?: true;
  };

  export type CourseObjectiveAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which CourseObjective to aggregate.
     */
    where?: CourseObjectiveWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CourseObjectives to fetch.
     */
    orderBy?:
      | CourseObjectiveOrderByWithRelationInput
      | CourseObjectiveOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CourseObjectiveWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CourseObjectives from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CourseObjectives.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CourseObjectives
     **/
    _count?: true | CourseObjectiveCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CourseObjectiveAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CourseObjectiveSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CourseObjectiveMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CourseObjectiveMaxAggregateInputType;
  };

  export type GetCourseObjectiveAggregateType<
    T extends CourseObjectiveAggregateArgs
  > = {
    [P in keyof T & keyof AggregateCourseObjective]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseObjective[P]>
      : GetScalarType<T[P], AggregateCourseObjective[P]>;
  };

  export type CourseObjectiveGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CourseObjectiveWhereInput;
    orderBy?:
      | CourseObjectiveOrderByWithAggregationInput
      | CourseObjectiveOrderByWithAggregationInput[];
    by: CourseObjectiveScalarFieldEnum[] | CourseObjectiveScalarFieldEnum;
    having?: CourseObjectiveScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CourseObjectiveCountAggregateInputType | true;
    _avg?: CourseObjectiveAvgAggregateInputType;
    _sum?: CourseObjectiveSumAggregateInputType;
    _min?: CourseObjectiveMinAggregateInputType;
    _max?: CourseObjectiveMaxAggregateInputType;
  };

  export type CourseObjectiveGroupByOutputType = {
    idCourse: number;
    idCourseObjective: number;
    content: string | null;
    _count: CourseObjectiveCountAggregateOutputType | null;
    _avg: CourseObjectiveAvgAggregateOutputType | null;
    _sum: CourseObjectiveSumAggregateOutputType | null;
    _min: CourseObjectiveMinAggregateOutputType | null;
    _max: CourseObjectiveMaxAggregateOutputType | null;
  };

  type GetCourseObjectiveGroupByPayload<T extends CourseObjectiveGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CourseObjectiveGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof CourseObjectiveGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseObjectiveGroupByOutputType[P]>
            : GetScalarType<T[P], CourseObjectiveGroupByOutputType[P]>;
        }
      >
    >;

  export type CourseObjectiveSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idCourse?: boolean;
      idCourseObjective?: boolean;
      content?: boolean;
      Course?: boolean | CourseDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['courseObjective']
  >;

  export type CourseObjectiveSelectScalar = {
    idCourse?: boolean;
    idCourseObjective?: boolean;
    content?: boolean;
  };

  export type CourseObjectiveOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idCourse' | 'idCourseObjective' | 'content',
    ExtArgs['result']['courseObjective']
  >;
  export type CourseObjectiveInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Course?: boolean | CourseDefaultArgs<ExtArgs>;
  };

  export type $CourseObjectivePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'CourseObjective';
    objects: {
      Course: Prisma.$CoursePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idCourse: number;
        idCourseObjective: number;
        content: string | null;
      },
      ExtArgs['result']['courseObjective']
    >;
    composites: {};
  };

  type CourseObjectiveGetPayload<
    S extends boolean | null | undefined | CourseObjectiveDefaultArgs
  > = $Result.GetResult<Prisma.$CourseObjectivePayload, S>;

  type CourseObjectiveCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    CourseObjectiveFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: CourseObjectiveCountAggregateInputType | true;
  };

  export interface CourseObjectiveDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['CourseObjective'];
      meta: { name: 'CourseObjective' };
    };
    /**
     * Find zero or one CourseObjective that matches the filter.
     * @param {CourseObjectiveFindUniqueArgs} args - Arguments to find a CourseObjective
     * @example
     * // Get one CourseObjective
     * const courseObjective = await prisma.courseObjective.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseObjectiveFindUniqueArgs>(
      args: SelectSubset<T, CourseObjectiveFindUniqueArgs<ExtArgs>>
    ): Prisma__CourseObjectiveClient<
      $Result.GetResult<
        Prisma.$CourseObjectivePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one CourseObjective that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseObjectiveFindUniqueOrThrowArgs} args - Arguments to find a CourseObjective
     * @example
     * // Get one CourseObjective
     * const courseObjective = await prisma.courseObjective.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseObjectiveFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CourseObjectiveFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CourseObjectiveClient<
      $Result.GetResult<
        Prisma.$CourseObjectivePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CourseObjective that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseObjectiveFindFirstArgs} args - Arguments to find a CourseObjective
     * @example
     * // Get one CourseObjective
     * const courseObjective = await prisma.courseObjective.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseObjectiveFindFirstArgs>(
      args?: SelectSubset<T, CourseObjectiveFindFirstArgs<ExtArgs>>
    ): Prisma__CourseObjectiveClient<
      $Result.GetResult<
        Prisma.$CourseObjectivePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CourseObjective that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseObjectiveFindFirstOrThrowArgs} args - Arguments to find a CourseObjective
     * @example
     * // Get one CourseObjective
     * const courseObjective = await prisma.courseObjective.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseObjectiveFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CourseObjectiveFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CourseObjectiveClient<
      $Result.GetResult<
        Prisma.$CourseObjectivePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more CourseObjectives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseObjectiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseObjectives
     * const courseObjectives = await prisma.courseObjective.findMany()
     *
     * // Get first 10 CourseObjectives
     * const courseObjectives = await prisma.courseObjective.findMany({ take: 10 })
     *
     * // Only select the `idCourse`
     * const courseObjectiveWithIdCourseOnly = await prisma.courseObjective.findMany({ select: { idCourse: true } })
     *
     */
    findMany<T extends CourseObjectiveFindManyArgs>(
      args?: SelectSubset<T, CourseObjectiveFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CourseObjectivePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a CourseObjective.
     * @param {CourseObjectiveCreateArgs} args - Arguments to create a CourseObjective.
     * @example
     * // Create one CourseObjective
     * const CourseObjective = await prisma.courseObjective.create({
     *   data: {
     *     // ... data to create a CourseObjective
     *   }
     * })
     *
     */
    create<T extends CourseObjectiveCreateArgs>(
      args: SelectSubset<T, CourseObjectiveCreateArgs<ExtArgs>>
    ): Prisma__CourseObjectiveClient<
      $Result.GetResult<
        Prisma.$CourseObjectivePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many CourseObjectives.
     * @param {CourseObjectiveCreateManyArgs} args - Arguments to create many CourseObjectives.
     * @example
     * // Create many CourseObjectives
     * const courseObjective = await prisma.courseObjective.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CourseObjectiveCreateManyArgs>(
      args?: SelectSubset<T, CourseObjectiveCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a CourseObjective.
     * @param {CourseObjectiveDeleteArgs} args - Arguments to delete one CourseObjective.
     * @example
     * // Delete one CourseObjective
     * const CourseObjective = await prisma.courseObjective.delete({
     *   where: {
     *     // ... filter to delete one CourseObjective
     *   }
     * })
     *
     */
    delete<T extends CourseObjectiveDeleteArgs>(
      args: SelectSubset<T, CourseObjectiveDeleteArgs<ExtArgs>>
    ): Prisma__CourseObjectiveClient<
      $Result.GetResult<
        Prisma.$CourseObjectivePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one CourseObjective.
     * @param {CourseObjectiveUpdateArgs} args - Arguments to update one CourseObjective.
     * @example
     * // Update one CourseObjective
     * const courseObjective = await prisma.courseObjective.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CourseObjectiveUpdateArgs>(
      args: SelectSubset<T, CourseObjectiveUpdateArgs<ExtArgs>>
    ): Prisma__CourseObjectiveClient<
      $Result.GetResult<
        Prisma.$CourseObjectivePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more CourseObjectives.
     * @param {CourseObjectiveDeleteManyArgs} args - Arguments to filter CourseObjectives to delete.
     * @example
     * // Delete a few CourseObjectives
     * const { count } = await prisma.courseObjective.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CourseObjectiveDeleteManyArgs>(
      args?: SelectSubset<T, CourseObjectiveDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more CourseObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseObjectiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseObjectives
     * const courseObjective = await prisma.courseObjective.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CourseObjectiveUpdateManyArgs>(
      args: SelectSubset<T, CourseObjectiveUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one CourseObjective.
     * @param {CourseObjectiveUpsertArgs} args - Arguments to update or create a CourseObjective.
     * @example
     * // Update or create a CourseObjective
     * const courseObjective = await prisma.courseObjective.upsert({
     *   create: {
     *     // ... data to create a CourseObjective
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseObjective we want to update
     *   }
     * })
     */
    upsert<T extends CourseObjectiveUpsertArgs>(
      args: SelectSubset<T, CourseObjectiveUpsertArgs<ExtArgs>>
    ): Prisma__CourseObjectiveClient<
      $Result.GetResult<
        Prisma.$CourseObjectivePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of CourseObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseObjectiveCountArgs} args - Arguments to filter CourseObjectives to count.
     * @example
     * // Count the number of CourseObjectives
     * const count = await prisma.courseObjective.count({
     *   where: {
     *     // ... the filter for the CourseObjectives we want to count
     *   }
     * })
     **/
    count<T extends CourseObjectiveCountArgs>(
      args?: Subset<T, CourseObjectiveCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseObjectiveCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a CourseObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseObjectiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CourseObjectiveAggregateArgs>(
      args: Subset<T, CourseObjectiveAggregateArgs>
    ): Prisma.PrismaPromise<GetCourseObjectiveAggregateType<T>>;

    /**
     * Group by CourseObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseObjectiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CourseObjectiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseObjectiveGroupByArgs['orderBy'] }
        : { orderBy?: CourseObjectiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, CourseObjectiveGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetCourseObjectiveGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the CourseObjective model
     */
    readonly fields: CourseObjectiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseObjective.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseObjectiveClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Course<T extends CourseDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CourseDefaultArgs<ExtArgs>>
    ): Prisma__CourseClient<
      | $Result.GetResult<
          Prisma.$CoursePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the CourseObjective model
   */
  interface CourseObjectiveFieldRefs {
    readonly idCourse: FieldRef<'CourseObjective', 'Int'>;
    readonly idCourseObjective: FieldRef<'CourseObjective', 'Int'>;
    readonly content: FieldRef<'CourseObjective', 'String'>;
  }

  // Custom InputTypes
  /**
   * CourseObjective findUnique
   */
  export type CourseObjectiveFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null;
    /**
     * Filter, which CourseObjective to fetch.
     */
    where: CourseObjectiveWhereUniqueInput;
  };

  /**
   * CourseObjective findUniqueOrThrow
   */
  export type CourseObjectiveFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null;
    /**
     * Filter, which CourseObjective to fetch.
     */
    where: CourseObjectiveWhereUniqueInput;
  };

  /**
   * CourseObjective findFirst
   */
  export type CourseObjectiveFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null;
    /**
     * Filter, which CourseObjective to fetch.
     */
    where?: CourseObjectiveWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CourseObjectives to fetch.
     */
    orderBy?:
      | CourseObjectiveOrderByWithRelationInput
      | CourseObjectiveOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CourseObjectives.
     */
    cursor?: CourseObjectiveWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CourseObjectives from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CourseObjectives.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CourseObjectives.
     */
    distinct?:
      | CourseObjectiveScalarFieldEnum
      | CourseObjectiveScalarFieldEnum[];
  };

  /**
   * CourseObjective findFirstOrThrow
   */
  export type CourseObjectiveFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null;
    /**
     * Filter, which CourseObjective to fetch.
     */
    where?: CourseObjectiveWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CourseObjectives to fetch.
     */
    orderBy?:
      | CourseObjectiveOrderByWithRelationInput
      | CourseObjectiveOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CourseObjectives.
     */
    cursor?: CourseObjectiveWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CourseObjectives from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CourseObjectives.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CourseObjectives.
     */
    distinct?:
      | CourseObjectiveScalarFieldEnum
      | CourseObjectiveScalarFieldEnum[];
  };

  /**
   * CourseObjective findMany
   */
  export type CourseObjectiveFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null;
    /**
     * Filter, which CourseObjectives to fetch.
     */
    where?: CourseObjectiveWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CourseObjectives to fetch.
     */
    orderBy?:
      | CourseObjectiveOrderByWithRelationInput
      | CourseObjectiveOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CourseObjectives.
     */
    cursor?: CourseObjectiveWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CourseObjectives from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CourseObjectives.
     */
    skip?: number;
    distinct?:
      | CourseObjectiveScalarFieldEnum
      | CourseObjectiveScalarFieldEnum[];
  };

  /**
   * CourseObjective create
   */
  export type CourseObjectiveCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null;
    /**
     * The data needed to create a CourseObjective.
     */
    data: XOR<CourseObjectiveCreateInput, CourseObjectiveUncheckedCreateInput>;
  };

  /**
   * CourseObjective createMany
   */
  export type CourseObjectiveCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many CourseObjectives.
     */
    data: CourseObjectiveCreateManyInput | CourseObjectiveCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * CourseObjective update
   */
  export type CourseObjectiveUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null;
    /**
     * The data needed to update a CourseObjective.
     */
    data: XOR<CourseObjectiveUpdateInput, CourseObjectiveUncheckedUpdateInput>;
    /**
     * Choose, which CourseObjective to update.
     */
    where: CourseObjectiveWhereUniqueInput;
  };

  /**
   * CourseObjective updateMany
   */
  export type CourseObjectiveUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update CourseObjectives.
     */
    data: XOR<
      CourseObjectiveUpdateManyMutationInput,
      CourseObjectiveUncheckedUpdateManyInput
    >;
    /**
     * Filter which CourseObjectives to update
     */
    where?: CourseObjectiveWhereInput;
    /**
     * Limit how many CourseObjectives to update.
     */
    limit?: number;
  };

  /**
   * CourseObjective upsert
   */
  export type CourseObjectiveUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null;
    /**
     * The filter to search for the CourseObjective to update in case it exists.
     */
    where: CourseObjectiveWhereUniqueInput;
    /**
     * In case the CourseObjective found by the `where` argument doesn't exist, create a new CourseObjective with this data.
     */
    create: XOR<
      CourseObjectiveCreateInput,
      CourseObjectiveUncheckedCreateInput
    >;
    /**
     * In case the CourseObjective was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      CourseObjectiveUpdateInput,
      CourseObjectiveUncheckedUpdateInput
    >;
  };

  /**
   * CourseObjective delete
   */
  export type CourseObjectiveDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null;
    /**
     * Filter which CourseObjective to delete.
     */
    where: CourseObjectiveWhereUniqueInput;
  };

  /**
   * CourseObjective deleteMany
   */
  export type CourseObjectiveDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which CourseObjectives to delete
     */
    where?: CourseObjectiveWhereInput;
    /**
     * Limit how many CourseObjectives to delete.
     */
    limit?: number;
  };

  /**
   * CourseObjective without action
   */
  export type CourseObjectiveDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null;
  };

  /**
   * Model Enrollment
   */

  export type AggregateEnrollment = {
    _count: EnrollmentCountAggregateOutputType | null;
    _avg: EnrollmentAvgAggregateOutputType | null;
    _sum: EnrollmentSumAggregateOutputType | null;
    _min: EnrollmentMinAggregateOutputType | null;
    _max: EnrollmentMaxAggregateOutputType | null;
  };

  export type EnrollmentAvgAggregateOutputType = {
    idUser: number | null;
    idCourse: number | null;
    progress: Decimal | null;
  };

  export type EnrollmentSumAggregateOutputType = {
    idUser: number | null;
    idCourse: number | null;
    progress: Decimal | null;
  };

  export type EnrollmentMinAggregateOutputType = {
    idUser: number | null;
    idCourse: number | null;
    dateRegister: Date | null;
    finishStatus: boolean | null;
    progress: Decimal | null;
  };

  export type EnrollmentMaxAggregateOutputType = {
    idUser: number | null;
    idCourse: number | null;
    dateRegister: Date | null;
    finishStatus: boolean | null;
    progress: Decimal | null;
  };

  export type EnrollmentCountAggregateOutputType = {
    idUser: number;
    idCourse: number;
    dateRegister: number;
    finishStatus: number;
    progress: number;
    _all: number;
  };

  export type EnrollmentAvgAggregateInputType = {
    idUser?: true;
    idCourse?: true;
    progress?: true;
  };

  export type EnrollmentSumAggregateInputType = {
    idUser?: true;
    idCourse?: true;
    progress?: true;
  };

  export type EnrollmentMinAggregateInputType = {
    idUser?: true;
    idCourse?: true;
    dateRegister?: true;
    finishStatus?: true;
    progress?: true;
  };

  export type EnrollmentMaxAggregateInputType = {
    idUser?: true;
    idCourse?: true;
    dateRegister?: true;
    finishStatus?: true;
    progress?: true;
  };

  export type EnrollmentCountAggregateInputType = {
    idUser?: true;
    idCourse?: true;
    dateRegister?: true;
    finishStatus?: true;
    progress?: true;
    _all?: true;
  };

  export type EnrollmentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Enrollment to aggregate.
     */
    where?: EnrollmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Enrollments to fetch.
     */
    orderBy?:
      | EnrollmentOrderByWithRelationInput
      | EnrollmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: EnrollmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Enrollments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Enrollments
     **/
    _count?: true | EnrollmentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: EnrollmentAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: EnrollmentSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: EnrollmentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: EnrollmentMaxAggregateInputType;
  };

  export type GetEnrollmentAggregateType<T extends EnrollmentAggregateArgs> = {
    [P in keyof T & keyof AggregateEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollment[P]>
      : GetScalarType<T[P], AggregateEnrollment[P]>;
  };

  export type EnrollmentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: EnrollmentWhereInput;
    orderBy?:
      | EnrollmentOrderByWithAggregationInput
      | EnrollmentOrderByWithAggregationInput[];
    by: EnrollmentScalarFieldEnum[] | EnrollmentScalarFieldEnum;
    having?: EnrollmentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: EnrollmentCountAggregateInputType | true;
    _avg?: EnrollmentAvgAggregateInputType;
    _sum?: EnrollmentSumAggregateInputType;
    _min?: EnrollmentMinAggregateInputType;
    _max?: EnrollmentMaxAggregateInputType;
  };

  export type EnrollmentGroupByOutputType = {
    idUser: number;
    idCourse: number;
    dateRegister: Date | null;
    finishStatus: boolean | null;
    progress: Decimal | null;
    _count: EnrollmentCountAggregateOutputType | null;
    _avg: EnrollmentAvgAggregateOutputType | null;
    _sum: EnrollmentSumAggregateOutputType | null;
    _min: EnrollmentMinAggregateOutputType | null;
    _max: EnrollmentMaxAggregateOutputType | null;
  };

  type GetEnrollmentGroupByPayload<T extends EnrollmentGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<EnrollmentGroupByOutputType, T['by']> & {
          [P in keyof T & keyof EnrollmentGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>;
        }
      >
    >;

  export type EnrollmentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idUser?: boolean;
      idCourse?: boolean;
      dateRegister?: boolean;
      finishStatus?: boolean;
      progress?: boolean;
      Course?: boolean | CourseDefaultArgs<ExtArgs>;
      User?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['enrollment']
  >;

  export type EnrollmentSelectScalar = {
    idUser?: boolean;
    idCourse?: boolean;
    dateRegister?: boolean;
    finishStatus?: boolean;
    progress?: boolean;
  };

  export type EnrollmentOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idUser' | 'idCourse' | 'dateRegister' | 'finishStatus' | 'progress',
    ExtArgs['result']['enrollment']
  >;
  export type EnrollmentInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Course?: boolean | CourseDefaultArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $EnrollmentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Enrollment';
    objects: {
      Course: Prisma.$CoursePayload<ExtArgs>;
      User: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idUser: number;
        idCourse: number;
        dateRegister: Date | null;
        finishStatus: boolean | null;
        progress: Prisma.Decimal | null;
      },
      ExtArgs['result']['enrollment']
    >;
    composites: {};
  };

  type EnrollmentGetPayload<
    S extends boolean | null | undefined | EnrollmentDefaultArgs
  > = $Result.GetResult<Prisma.$EnrollmentPayload, S>;

  type EnrollmentCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    EnrollmentFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: EnrollmentCountAggregateInputType | true;
  };

  export interface EnrollmentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Enrollment'];
      meta: { name: 'Enrollment' };
    };
    /**
     * Find zero or one Enrollment that matches the filter.
     * @param {EnrollmentFindUniqueArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnrollmentFindUniqueArgs>(
      args: SelectSubset<T, EnrollmentFindUniqueArgs<ExtArgs>>
    ): Prisma__EnrollmentClient<
      $Result.GetResult<
        Prisma.$EnrollmentPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Enrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnrollmentFindUniqueOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnrollmentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, EnrollmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EnrollmentClient<
      $Result.GetResult<
        Prisma.$EnrollmentPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Enrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnrollmentFindFirstArgs>(
      args?: SelectSubset<T, EnrollmentFindFirstArgs<ExtArgs>>
    ): Prisma__EnrollmentClient<
      $Result.GetResult<
        Prisma.$EnrollmentPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Enrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnrollmentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EnrollmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EnrollmentClient<
      $Result.GetResult<
        Prisma.$EnrollmentPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollment.findMany()
     *
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollment.findMany({ take: 10 })
     *
     * // Only select the `idUser`
     * const enrollmentWithIdUserOnly = await prisma.enrollment.findMany({ select: { idUser: true } })
     *
     */
    findMany<T extends EnrollmentFindManyArgs>(
      args?: SelectSubset<T, EnrollmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EnrollmentPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Enrollment.
     * @param {EnrollmentCreateArgs} args - Arguments to create a Enrollment.
     * @example
     * // Create one Enrollment
     * const Enrollment = await prisma.enrollment.create({
     *   data: {
     *     // ... data to create a Enrollment
     *   }
     * })
     *
     */
    create<T extends EnrollmentCreateArgs>(
      args: SelectSubset<T, EnrollmentCreateArgs<ExtArgs>>
    ): Prisma__EnrollmentClient<
      $Result.GetResult<
        Prisma.$EnrollmentPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Enrollments.
     * @param {EnrollmentCreateManyArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends EnrollmentCreateManyArgs>(
      args?: SelectSubset<T, EnrollmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Enrollment.
     * @param {EnrollmentDeleteArgs} args - Arguments to delete one Enrollment.
     * @example
     * // Delete one Enrollment
     * const Enrollment = await prisma.enrollment.delete({
     *   where: {
     *     // ... filter to delete one Enrollment
     *   }
     * })
     *
     */
    delete<T extends EnrollmentDeleteArgs>(
      args: SelectSubset<T, EnrollmentDeleteArgs<ExtArgs>>
    ): Prisma__EnrollmentClient<
      $Result.GetResult<
        Prisma.$EnrollmentPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Enrollment.
     * @param {EnrollmentUpdateArgs} args - Arguments to update one Enrollment.
     * @example
     * // Update one Enrollment
     * const enrollment = await prisma.enrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends EnrollmentUpdateArgs>(
      args: SelectSubset<T, EnrollmentUpdateArgs<ExtArgs>>
    ): Prisma__EnrollmentClient<
      $Result.GetResult<
        Prisma.$EnrollmentPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Enrollments.
     * @param {EnrollmentDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends EnrollmentDeleteManyArgs>(
      args?: SelectSubset<T, EnrollmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends EnrollmentUpdateManyArgs>(
      args: SelectSubset<T, EnrollmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Enrollment.
     * @param {EnrollmentUpsertArgs} args - Arguments to update or create a Enrollment.
     * @example
     * // Update or create a Enrollment
     * const enrollment = await prisma.enrollment.upsert({
     *   create: {
     *     // ... data to create a Enrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollment we want to update
     *   }
     * })
     */
    upsert<T extends EnrollmentUpsertArgs>(
      args: SelectSubset<T, EnrollmentUpsertArgs<ExtArgs>>
    ): Prisma__EnrollmentClient<
      $Result.GetResult<
        Prisma.$EnrollmentPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollment.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
     **/
    count<T extends EnrollmentCountArgs>(
      args?: Subset<T, EnrollmentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends EnrollmentAggregateArgs>(
      args: Subset<T, EnrollmentAggregateArgs>
    ): Prisma.PrismaPromise<GetEnrollmentAggregateType<T>>;

    /**
     * Group by Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends EnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: EnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, EnrollmentGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetEnrollmentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Enrollment model
     */
    readonly fields: EnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnrollmentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Course<T extends CourseDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CourseDefaultArgs<ExtArgs>>
    ): Prisma__CourseClient<
      | $Result.GetResult<
          Prisma.$CoursePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    User<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Enrollment model
   */
  interface EnrollmentFieldRefs {
    readonly idUser: FieldRef<'Enrollment', 'Int'>;
    readonly idCourse: FieldRef<'Enrollment', 'Int'>;
    readonly dateRegister: FieldRef<'Enrollment', 'DateTime'>;
    readonly finishStatus: FieldRef<'Enrollment', 'Boolean'>;
    readonly progress: FieldRef<'Enrollment', 'Decimal'>;
  }

  // Custom InputTypes
  /**
   * Enrollment findUnique
   */
  export type EnrollmentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null;
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput;
  };

  /**
   * Enrollment findUniqueOrThrow
   */
  export type EnrollmentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null;
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput;
  };

  /**
   * Enrollment findFirst
   */
  export type EnrollmentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null;
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Enrollments to fetch.
     */
    orderBy?:
      | EnrollmentOrderByWithRelationInput
      | EnrollmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Enrollments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[];
  };

  /**
   * Enrollment findFirstOrThrow
   */
  export type EnrollmentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null;
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Enrollments to fetch.
     */
    orderBy?:
      | EnrollmentOrderByWithRelationInput
      | EnrollmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Enrollments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[];
  };

  /**
   * Enrollment findMany
   */
  export type EnrollmentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null;
    /**
     * Filter, which Enrollments to fetch.
     */
    where?: EnrollmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Enrollments to fetch.
     */
    orderBy?:
      | EnrollmentOrderByWithRelationInput
      | EnrollmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Enrollments.
     */
    skip?: number;
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[];
  };

  /**
   * Enrollment create
   */
  export type EnrollmentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null;
    /**
     * The data needed to create a Enrollment.
     */
    data: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>;
  };

  /**
   * Enrollment createMany
   */
  export type EnrollmentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Enrollment update
   */
  export type EnrollmentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null;
    /**
     * The data needed to update a Enrollment.
     */
    data: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>;
    /**
     * Choose, which Enrollment to update.
     */
    where: EnrollmentWhereUniqueInput;
  };

  /**
   * Enrollment updateMany
   */
  export type EnrollmentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Enrollments.
     */
    data: XOR<
      EnrollmentUpdateManyMutationInput,
      EnrollmentUncheckedUpdateManyInput
    >;
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput;
    /**
     * Limit how many Enrollments to update.
     */
    limit?: number;
  };

  /**
   * Enrollment upsert
   */
  export type EnrollmentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null;
    /**
     * The filter to search for the Enrollment to update in case it exists.
     */
    where: EnrollmentWhereUniqueInput;
    /**
     * In case the Enrollment found by the `where` argument doesn't exist, create a new Enrollment with this data.
     */
    create: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>;
    /**
     * In case the Enrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>;
  };

  /**
   * Enrollment delete
   */
  export type EnrollmentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null;
    /**
     * Filter which Enrollment to delete.
     */
    where: EnrollmentWhereUniqueInput;
  };

  /**
   * Enrollment deleteMany
   */
  export type EnrollmentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Enrollments to delete
     */
    where?: EnrollmentWhereInput;
    /**
     * Limit how many Enrollments to delete.
     */
    limit?: number;
  };

  /**
   * Enrollment without action
   */
  export type EnrollmentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null;
  };

  /**
   * Model Follow
   */

  export type AggregateFollow = {
    _count: FollowCountAggregateOutputType | null;
    _avg: FollowAvgAggregateOutputType | null;
    _sum: FollowSumAggregateOutputType | null;
    _min: FollowMinAggregateOutputType | null;
    _max: FollowMaxAggregateOutputType | null;
  };

  export type FollowAvgAggregateOutputType = {
    idFollower: number | null;
    idFollowing: number | null;
  };

  export type FollowSumAggregateOutputType = {
    idFollower: number | null;
    idFollowing: number | null;
  };

  export type FollowMinAggregateOutputType = {
    idFollower: number | null;
    idFollowing: number | null;
  };

  export type FollowMaxAggregateOutputType = {
    idFollower: number | null;
    idFollowing: number | null;
  };

  export type FollowCountAggregateOutputType = {
    idFollower: number;
    idFollowing: number;
    _all: number;
  };

  export type FollowAvgAggregateInputType = {
    idFollower?: true;
    idFollowing?: true;
  };

  export type FollowSumAggregateInputType = {
    idFollower?: true;
    idFollowing?: true;
  };

  export type FollowMinAggregateInputType = {
    idFollower?: true;
    idFollowing?: true;
  };

  export type FollowMaxAggregateInputType = {
    idFollower?: true;
    idFollowing?: true;
  };

  export type FollowCountAggregateInputType = {
    idFollower?: true;
    idFollowing?: true;
    _all?: true;
  };

  export type FollowAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Follow to aggregate.
     */
    where?: FollowWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FollowWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Follows.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Follows
     **/
    _count?: true | FollowCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FollowAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FollowSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FollowMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FollowMaxAggregateInputType;
  };

  export type GetFollowAggregateType<T extends FollowAggregateArgs> = {
    [P in keyof T & keyof AggregateFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollow[P]>
      : GetScalarType<T[P], AggregateFollow[P]>;
  };

  export type FollowGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: FollowWhereInput;
    orderBy?:
      | FollowOrderByWithAggregationInput
      | FollowOrderByWithAggregationInput[];
    by: FollowScalarFieldEnum[] | FollowScalarFieldEnum;
    having?: FollowScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FollowCountAggregateInputType | true;
    _avg?: FollowAvgAggregateInputType;
    _sum?: FollowSumAggregateInputType;
    _min?: FollowMinAggregateInputType;
    _max?: FollowMaxAggregateInputType;
  };

  export type FollowGroupByOutputType = {
    idFollower: number;
    idFollowing: number;
    _count: FollowCountAggregateOutputType | null;
    _avg: FollowAvgAggregateOutputType | null;
    _sum: FollowSumAggregateOutputType | null;
    _min: FollowMinAggregateOutputType | null;
    _max: FollowMaxAggregateOutputType | null;
  };

  type GetFollowGroupByPayload<T extends FollowGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FollowGroupByOutputType, T['by']> & {
          [P in keyof T & keyof FollowGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowGroupByOutputType[P]>
            : GetScalarType<T[P], FollowGroupByOutputType[P]>;
        }
      >
    >;

  export type FollowSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idFollower?: boolean;
      idFollowing?: boolean;
      User_Follow_idFollowerToUser?: boolean | UserDefaultArgs<ExtArgs>;
      User_Follow_idFollowingToUser?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['follow']
  >;

  export type FollowSelectScalar = {
    idFollower?: boolean;
    idFollowing?: boolean;
  };

  export type FollowOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idFollower' | 'idFollowing',
    ExtArgs['result']['follow']
  >;
  export type FollowInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    User_Follow_idFollowerToUser?: boolean | UserDefaultArgs<ExtArgs>;
    User_Follow_idFollowingToUser?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $FollowPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Follow';
    objects: {
      User_Follow_idFollowerToUser: Prisma.$UserPayload<ExtArgs>;
      User_Follow_idFollowingToUser: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idFollower: number;
        idFollowing: number;
      },
      ExtArgs['result']['follow']
    >;
    composites: {};
  };

  type FollowGetPayload<
    S extends boolean | null | undefined | FollowDefaultArgs
  > = $Result.GetResult<Prisma.$FollowPayload, S>;

  type FollowCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<FollowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: FollowCountAggregateInputType | true;
  };

  export interface FollowDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Follow'];
      meta: { name: 'Follow' };
    };
    /**
     * Find zero or one Follow that matches the filter.
     * @param {FollowFindUniqueArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowFindUniqueArgs>(
      args: SelectSubset<T, FollowFindUniqueArgs<ExtArgs>>
    ): Prisma__FollowClient<
      $Result.GetResult<
        Prisma.$FollowPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Follow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowFindUniqueOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FollowFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FollowClient<
      $Result.GetResult<
        Prisma.$FollowPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Follow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowFindFirstArgs>(
      args?: SelectSubset<T, FollowFindFirstArgs<ExtArgs>>
    ): Prisma__FollowClient<
      $Result.GetResult<
        Prisma.$FollowPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Follow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FollowFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FollowClient<
      $Result.GetResult<
        Prisma.$FollowPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follow.findMany()
     *
     * // Get first 10 Follows
     * const follows = await prisma.follow.findMany({ take: 10 })
     *
     * // Only select the `idFollower`
     * const followWithIdFollowerOnly = await prisma.follow.findMany({ select: { idFollower: true } })
     *
     */
    findMany<T extends FollowFindManyArgs>(
      args?: SelectSubset<T, FollowFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FollowPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Follow.
     * @param {FollowCreateArgs} args - Arguments to create a Follow.
     * @example
     * // Create one Follow
     * const Follow = await prisma.follow.create({
     *   data: {
     *     // ... data to create a Follow
     *   }
     * })
     *
     */
    create<T extends FollowCreateArgs>(
      args: SelectSubset<T, FollowCreateArgs<ExtArgs>>
    ): Prisma__FollowClient<
      $Result.GetResult<
        Prisma.$FollowPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Follows.
     * @param {FollowCreateManyArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FollowCreateManyArgs>(
      args?: SelectSubset<T, FollowCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Follow.
     * @param {FollowDeleteArgs} args - Arguments to delete one Follow.
     * @example
     * // Delete one Follow
     * const Follow = await prisma.follow.delete({
     *   where: {
     *     // ... filter to delete one Follow
     *   }
     * })
     *
     */
    delete<T extends FollowDeleteArgs>(
      args: SelectSubset<T, FollowDeleteArgs<ExtArgs>>
    ): Prisma__FollowClient<
      $Result.GetResult<
        Prisma.$FollowPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Follow.
     * @param {FollowUpdateArgs} args - Arguments to update one Follow.
     * @example
     * // Update one Follow
     * const follow = await prisma.follow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FollowUpdateArgs>(
      args: SelectSubset<T, FollowUpdateArgs<ExtArgs>>
    ): Prisma__FollowClient<
      $Result.GetResult<
        Prisma.$FollowPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Follows.
     * @param {FollowDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FollowDeleteManyArgs>(
      args?: SelectSubset<T, FollowDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FollowUpdateManyArgs>(
      args: SelectSubset<T, FollowUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Follow.
     * @param {FollowUpsertArgs} args - Arguments to update or create a Follow.
     * @example
     * // Update or create a Follow
     * const follow = await prisma.follow.upsert({
     *   create: {
     *     // ... data to create a Follow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follow we want to update
     *   }
     * })
     */
    upsert<T extends FollowUpsertArgs>(
      args: SelectSubset<T, FollowUpsertArgs<ExtArgs>>
    ): Prisma__FollowClient<
      $Result.GetResult<
        Prisma.$FollowPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follow.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
     **/
    count<T extends FollowCountArgs>(
      args?: Subset<T, FollowCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FollowAggregateArgs>(
      args: Subset<T, FollowAggregateArgs>
    ): Prisma.PrismaPromise<GetFollowAggregateType<T>>;

    /**
     * Group by Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowGroupByArgs['orderBy'] }
        : { orderBy?: FollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, FollowGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetFollowGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Follow model
     */
    readonly fields: FollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Follow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    User_Follow_idFollowerToUser<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    User_Follow_idFollowingToUser<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Follow model
   */
  interface FollowFieldRefs {
    readonly idFollower: FieldRef<'Follow', 'Int'>;
    readonly idFollowing: FieldRef<'Follow', 'Int'>;
  }

  // Custom InputTypes
  /**
   * Follow findUnique
   */
  export type FollowFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null;
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput;
  };

  /**
   * Follow findUniqueOrThrow
   */
  export type FollowFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null;
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput;
  };

  /**
   * Follow findFirst
   */
  export type FollowFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null;
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Follows.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[];
  };

  /**
   * Follow findFirstOrThrow
   */
  export type FollowFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null;
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Follows.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[];
  };

  /**
   * Follow findMany
   */
  export type FollowFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null;
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Follows.
     */
    cursor?: FollowWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Follows.
     */
    skip?: number;
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[];
  };

  /**
   * Follow create
   */
  export type FollowCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null;
    /**
     * The data needed to create a Follow.
     */
    data: XOR<FollowCreateInput, FollowUncheckedCreateInput>;
  };

  /**
   * Follow createMany
   */
  export type FollowCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Follow update
   */
  export type FollowUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null;
    /**
     * The data needed to update a Follow.
     */
    data: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>;
    /**
     * Choose, which Follow to update.
     */
    where: FollowWhereUniqueInput;
  };

  /**
   * Follow updateMany
   */
  export type FollowUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>;
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput;
    /**
     * Limit how many Follows to update.
     */
    limit?: number;
  };

  /**
   * Follow upsert
   */
  export type FollowUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null;
    /**
     * The filter to search for the Follow to update in case it exists.
     */
    where: FollowWhereUniqueInput;
    /**
     * In case the Follow found by the `where` argument doesn't exist, create a new Follow with this data.
     */
    create: XOR<FollowCreateInput, FollowUncheckedCreateInput>;
    /**
     * In case the Follow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>;
  };

  /**
   * Follow delete
   */
  export type FollowDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null;
    /**
     * Filter which Follow to delete.
     */
    where: FollowWhereUniqueInput;
  };

  /**
   * Follow deleteMany
   */
  export type FollowDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Follows to delete
     */
    where?: FollowWhereInput;
    /**
     * Limit how many Follows to delete.
     */
    limit?: number;
  };

  /**
   * Follow without action
   */
  export type FollowDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null;
  };

  /**
   * Model Lecture
   */

  export type AggregateLecture = {
    _count: LectureCountAggregateOutputType | null;
    _avg: LectureAvgAggregateOutputType | null;
    _sum: LectureSumAggregateOutputType | null;
    _min: LectureMinAggregateOutputType | null;
    _max: LectureMaxAggregateOutputType | null;
  };

  export type LectureAvgAggregateOutputType = {
    idCourse: number | null;
    idSection: number | null;
    idLecture: number | null;
  };

  export type LectureSumAggregateOutputType = {
    idCourse: number | null;
    idSection: number | null;
    idLecture: number | null;
  };

  export type LectureMinAggregateOutputType = {
    idCourse: number | null;
    idSection: number | null;
    idLecture: number | null;
    nameLecture: string | null;
    isDone: boolean | null;
  };

  export type LectureMaxAggregateOutputType = {
    idCourse: number | null;
    idSection: number | null;
    idLecture: number | null;
    nameLecture: string | null;
    isDone: boolean | null;
  };

  export type LectureCountAggregateOutputType = {
    idCourse: number;
    idSection: number;
    idLecture: number;
    nameLecture: number;
    isDone: number;
    _all: number;
  };

  export type LectureAvgAggregateInputType = {
    idCourse?: true;
    idSection?: true;
    idLecture?: true;
  };

  export type LectureSumAggregateInputType = {
    idCourse?: true;
    idSection?: true;
    idLecture?: true;
  };

  export type LectureMinAggregateInputType = {
    idCourse?: true;
    idSection?: true;
    idLecture?: true;
    nameLecture?: true;
    isDone?: true;
  };

  export type LectureMaxAggregateInputType = {
    idCourse?: true;
    idSection?: true;
    idLecture?: true;
    nameLecture?: true;
    isDone?: true;
  };

  export type LectureCountAggregateInputType = {
    idCourse?: true;
    idSection?: true;
    idLecture?: true;
    nameLecture?: true;
    isDone?: true;
    _all?: true;
  };

  export type LectureAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Lecture to aggregate.
     */
    where?: LectureWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Lectures to fetch.
     */
    orderBy?:
      | LectureOrderByWithRelationInput
      | LectureOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: LectureWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Lectures from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Lectures.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Lectures
     **/
    _count?: true | LectureCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: LectureAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: LectureSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: LectureMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: LectureMaxAggregateInputType;
  };

  export type GetLectureAggregateType<T extends LectureAggregateArgs> = {
    [P in keyof T & keyof AggregateLecture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLecture[P]>
      : GetScalarType<T[P], AggregateLecture[P]>;
  };

  export type LectureGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: LectureWhereInput;
    orderBy?:
      | LectureOrderByWithAggregationInput
      | LectureOrderByWithAggregationInput[];
    by: LectureScalarFieldEnum[] | LectureScalarFieldEnum;
    having?: LectureScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: LectureCountAggregateInputType | true;
    _avg?: LectureAvgAggregateInputType;
    _sum?: LectureSumAggregateInputType;
    _min?: LectureMinAggregateInputType;
    _max?: LectureMaxAggregateInputType;
  };

  export type LectureGroupByOutputType = {
    idCourse: number;
    idSection: number;
    idLecture: number;
    nameLecture: string | null;
    isDone: boolean | null;
    _count: LectureCountAggregateOutputType | null;
    _avg: LectureAvgAggregateOutputType | null;
    _sum: LectureSumAggregateOutputType | null;
    _min: LectureMinAggregateOutputType | null;
    _max: LectureMaxAggregateOutputType | null;
  };

  type GetLectureGroupByPayload<T extends LectureGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<LectureGroupByOutputType, T['by']> & {
          [P in keyof T & keyof LectureGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LectureGroupByOutputType[P]>
            : GetScalarType<T[P], LectureGroupByOutputType[P]>;
        }
      >
    >;

  export type LectureSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idCourse?: boolean;
      idSection?: boolean;
      idLecture?: boolean;
      nameLecture?: boolean;
      isDone?: boolean;
      Section?: boolean | SectionDefaultArgs<ExtArgs>;
      Note?: boolean | Lecture$NoteArgs<ExtArgs>;
      Question?: boolean | Lecture$QuestionArgs<ExtArgs>;
      _count?: boolean | LectureCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['lecture']
  >;

  export type LectureSelectScalar = {
    idCourse?: boolean;
    idSection?: boolean;
    idLecture?: boolean;
    nameLecture?: boolean;
    isDone?: boolean;
  };

  export type LectureOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idCourse' | 'idSection' | 'idLecture' | 'nameLecture' | 'isDone',
    ExtArgs['result']['lecture']
  >;
  export type LectureInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Section?: boolean | SectionDefaultArgs<ExtArgs>;
    Note?: boolean | Lecture$NoteArgs<ExtArgs>;
    Question?: boolean | Lecture$QuestionArgs<ExtArgs>;
    _count?: boolean | LectureCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $LecturePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Lecture';
    objects: {
      Section: Prisma.$SectionPayload<ExtArgs>;
      Note: Prisma.$NotePayload<ExtArgs>[];
      Question: Prisma.$QuestionPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idCourse: number;
        idSection: number;
        idLecture: number;
        nameLecture: string | null;
        isDone: boolean | null;
      },
      ExtArgs['result']['lecture']
    >;
    composites: {};
  };

  type LectureGetPayload<
    S extends boolean | null | undefined | LectureDefaultArgs
  > = $Result.GetResult<Prisma.$LecturePayload, S>;

  type LectureCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<LectureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: LectureCountAggregateInputType | true;
  };

  export interface LectureDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Lecture'];
      meta: { name: 'Lecture' };
    };
    /**
     * Find zero or one Lecture that matches the filter.
     * @param {LectureFindUniqueArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LectureFindUniqueArgs>(
      args: SelectSubset<T, LectureFindUniqueArgs<ExtArgs>>
    ): Prisma__LectureClient<
      $Result.GetResult<
        Prisma.$LecturePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Lecture that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LectureFindUniqueOrThrowArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LectureFindUniqueOrThrowArgs>(
      args: SelectSubset<T, LectureFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LectureClient<
      $Result.GetResult<
        Prisma.$LecturePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Lecture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureFindFirstArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LectureFindFirstArgs>(
      args?: SelectSubset<T, LectureFindFirstArgs<ExtArgs>>
    ): Prisma__LectureClient<
      $Result.GetResult<
        Prisma.$LecturePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Lecture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureFindFirstOrThrowArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LectureFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LectureFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LectureClient<
      $Result.GetResult<
        Prisma.$LecturePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Lectures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lectures
     * const lectures = await prisma.lecture.findMany()
     *
     * // Get first 10 Lectures
     * const lectures = await prisma.lecture.findMany({ take: 10 })
     *
     * // Only select the `idCourse`
     * const lectureWithIdCourseOnly = await prisma.lecture.findMany({ select: { idCourse: true } })
     *
     */
    findMany<T extends LectureFindManyArgs>(
      args?: SelectSubset<T, LectureFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LecturePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Lecture.
     * @param {LectureCreateArgs} args - Arguments to create a Lecture.
     * @example
     * // Create one Lecture
     * const Lecture = await prisma.lecture.create({
     *   data: {
     *     // ... data to create a Lecture
     *   }
     * })
     *
     */
    create<T extends LectureCreateArgs>(
      args: SelectSubset<T, LectureCreateArgs<ExtArgs>>
    ): Prisma__LectureClient<
      $Result.GetResult<
        Prisma.$LecturePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Lectures.
     * @param {LectureCreateManyArgs} args - Arguments to create many Lectures.
     * @example
     * // Create many Lectures
     * const lecture = await prisma.lecture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends LectureCreateManyArgs>(
      args?: SelectSubset<T, LectureCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Lecture.
     * @param {LectureDeleteArgs} args - Arguments to delete one Lecture.
     * @example
     * // Delete one Lecture
     * const Lecture = await prisma.lecture.delete({
     *   where: {
     *     // ... filter to delete one Lecture
     *   }
     * })
     *
     */
    delete<T extends LectureDeleteArgs>(
      args: SelectSubset<T, LectureDeleteArgs<ExtArgs>>
    ): Prisma__LectureClient<
      $Result.GetResult<
        Prisma.$LecturePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Lecture.
     * @param {LectureUpdateArgs} args - Arguments to update one Lecture.
     * @example
     * // Update one Lecture
     * const lecture = await prisma.lecture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends LectureUpdateArgs>(
      args: SelectSubset<T, LectureUpdateArgs<ExtArgs>>
    ): Prisma__LectureClient<
      $Result.GetResult<
        Prisma.$LecturePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Lectures.
     * @param {LectureDeleteManyArgs} args - Arguments to filter Lectures to delete.
     * @example
     * // Delete a few Lectures
     * const { count } = await prisma.lecture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends LectureDeleteManyArgs>(
      args?: SelectSubset<T, LectureDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Lectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lectures
     * const lecture = await prisma.lecture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends LectureUpdateManyArgs>(
      args: SelectSubset<T, LectureUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Lecture.
     * @param {LectureUpsertArgs} args - Arguments to update or create a Lecture.
     * @example
     * // Update or create a Lecture
     * const lecture = await prisma.lecture.upsert({
     *   create: {
     *     // ... data to create a Lecture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lecture we want to update
     *   }
     * })
     */
    upsert<T extends LectureUpsertArgs>(
      args: SelectSubset<T, LectureUpsertArgs<ExtArgs>>
    ): Prisma__LectureClient<
      $Result.GetResult<
        Prisma.$LecturePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Lectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureCountArgs} args - Arguments to filter Lectures to count.
     * @example
     * // Count the number of Lectures
     * const count = await prisma.lecture.count({
     *   where: {
     *     // ... the filter for the Lectures we want to count
     *   }
     * })
     **/
    count<T extends LectureCountArgs>(
      args?: Subset<T, LectureCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LectureCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Lecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends LectureAggregateArgs>(
      args: Subset<T, LectureAggregateArgs>
    ): Prisma.PrismaPromise<GetLectureAggregateType<T>>;

    /**
     * Group by Lecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends LectureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LectureGroupByArgs['orderBy'] }
        : { orderBy?: LectureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, LectureGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetLectureGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Lecture model
     */
    readonly fields: LectureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lecture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LectureClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Section<T extends SectionDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, SectionDefaultArgs<ExtArgs>>
    ): Prisma__SectionClient<
      | $Result.GetResult<
          Prisma.$SectionPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    Note<T extends Lecture$NoteArgs<ExtArgs> = {}>(
      args?: Subset<T, Lecture$NoteArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$NotePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Question<T extends Lecture$QuestionArgs<ExtArgs> = {}>(
      args?: Subset<T, Lecture$QuestionArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$QuestionPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Lecture model
   */
  interface LectureFieldRefs {
    readonly idCourse: FieldRef<'Lecture', 'Int'>;
    readonly idSection: FieldRef<'Lecture', 'Int'>;
    readonly idLecture: FieldRef<'Lecture', 'Int'>;
    readonly nameLecture: FieldRef<'Lecture', 'String'>;
    readonly isDone: FieldRef<'Lecture', 'Boolean'>;
  }

  // Custom InputTypes
  /**
   * Lecture findUnique
   */
  export type LectureFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    /**
     * Filter, which Lecture to fetch.
     */
    where: LectureWhereUniqueInput;
  };

  /**
   * Lecture findUniqueOrThrow
   */
  export type LectureFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    /**
     * Filter, which Lecture to fetch.
     */
    where: LectureWhereUniqueInput;
  };

  /**
   * Lecture findFirst
   */
  export type LectureFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    /**
     * Filter, which Lecture to fetch.
     */
    where?: LectureWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Lectures to fetch.
     */
    orderBy?:
      | LectureOrderByWithRelationInput
      | LectureOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Lectures.
     */
    cursor?: LectureWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Lectures from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Lectures.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Lectures.
     */
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[];
  };

  /**
   * Lecture findFirstOrThrow
   */
  export type LectureFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    /**
     * Filter, which Lecture to fetch.
     */
    where?: LectureWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Lectures to fetch.
     */
    orderBy?:
      | LectureOrderByWithRelationInput
      | LectureOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Lectures.
     */
    cursor?: LectureWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Lectures from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Lectures.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Lectures.
     */
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[];
  };

  /**
   * Lecture findMany
   */
  export type LectureFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    /**
     * Filter, which Lectures to fetch.
     */
    where?: LectureWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Lectures to fetch.
     */
    orderBy?:
      | LectureOrderByWithRelationInput
      | LectureOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Lectures.
     */
    cursor?: LectureWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Lectures from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Lectures.
     */
    skip?: number;
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[];
  };

  /**
   * Lecture create
   */
  export type LectureCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    /**
     * The data needed to create a Lecture.
     */
    data: XOR<LectureCreateInput, LectureUncheckedCreateInput>;
  };

  /**
   * Lecture createMany
   */
  export type LectureCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Lectures.
     */
    data: LectureCreateManyInput | LectureCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Lecture update
   */
  export type LectureUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    /**
     * The data needed to update a Lecture.
     */
    data: XOR<LectureUpdateInput, LectureUncheckedUpdateInput>;
    /**
     * Choose, which Lecture to update.
     */
    where: LectureWhereUniqueInput;
  };

  /**
   * Lecture updateMany
   */
  export type LectureUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Lectures.
     */
    data: XOR<LectureUpdateManyMutationInput, LectureUncheckedUpdateManyInput>;
    /**
     * Filter which Lectures to update
     */
    where?: LectureWhereInput;
    /**
     * Limit how many Lectures to update.
     */
    limit?: number;
  };

  /**
   * Lecture upsert
   */
  export type LectureUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    /**
     * The filter to search for the Lecture to update in case it exists.
     */
    where: LectureWhereUniqueInput;
    /**
     * In case the Lecture found by the `where` argument doesn't exist, create a new Lecture with this data.
     */
    create: XOR<LectureCreateInput, LectureUncheckedCreateInput>;
    /**
     * In case the Lecture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LectureUpdateInput, LectureUncheckedUpdateInput>;
  };

  /**
   * Lecture delete
   */
  export type LectureDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    /**
     * Filter which Lecture to delete.
     */
    where: LectureWhereUniqueInput;
  };

  /**
   * Lecture deleteMany
   */
  export type LectureDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Lectures to delete
     */
    where?: LectureWhereInput;
    /**
     * Limit how many Lectures to delete.
     */
    limit?: number;
  };

  /**
   * Lecture.Note
   */
  export type Lecture$NoteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null;
    where?: NoteWhereInput;
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[];
    cursor?: NoteWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[];
  };

  /**
   * Lecture.Question
   */
  export type Lecture$QuestionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null;
    where?: QuestionWhereInput;
    orderBy?:
      | QuestionOrderByWithRelationInput
      | QuestionOrderByWithRelationInput[];
    cursor?: QuestionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[];
  };

  /**
   * Lecture without action
   */
  export type LectureDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
  };

  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null;
    _avg: MessageAvgAggregateOutputType | null;
    _sum: MessageSumAggregateOutputType | null;
    _min: MessageMinAggregateOutputType | null;
    _max: MessageMaxAggregateOutputType | null;
  };

  export type MessageAvgAggregateOutputType = {
    idMessage: number | null;
    idUserSender: number | null;
    idUserReceiver: number | null;
  };

  export type MessageSumAggregateOutputType = {
    idMessage: number | null;
    idUserSender: number | null;
    idUserReceiver: number | null;
  };

  export type MessageMinAggregateOutputType = {
    idMessage: number | null;
    idUserSender: number | null;
    idUserReceiver: number | null;
    message: string | null;
    timeSend: Date | null;
  };

  export type MessageMaxAggregateOutputType = {
    idMessage: number | null;
    idUserSender: number | null;
    idUserReceiver: number | null;
    message: string | null;
    timeSend: Date | null;
  };

  export type MessageCountAggregateOutputType = {
    idMessage: number;
    idUserSender: number;
    idUserReceiver: number;
    message: number;
    timeSend: number;
    _all: number;
  };

  export type MessageAvgAggregateInputType = {
    idMessage?: true;
    idUserSender?: true;
    idUserReceiver?: true;
  };

  export type MessageSumAggregateInputType = {
    idMessage?: true;
    idUserSender?: true;
    idUserReceiver?: true;
  };

  export type MessageMinAggregateInputType = {
    idMessage?: true;
    idUserSender?: true;
    idUserReceiver?: true;
    message?: true;
    timeSend?: true;
  };

  export type MessageMaxAggregateInputType = {
    idMessage?: true;
    idUserSender?: true;
    idUserReceiver?: true;
    message?: true;
    timeSend?: true;
  };

  export type MessageCountAggregateInputType = {
    idMessage?: true;
    idUserSender?: true;
    idUserReceiver?: true;
    message?: true;
    timeSend?: true;
    _all?: true;
  };

  export type MessageAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Messages to fetch.
     */
    orderBy?:
      | MessageOrderByWithRelationInput
      | MessageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Messages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Messages
     **/
    _count?: true | MessageCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: MessageAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: MessageSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MessageMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MessageMaxAggregateInputType;
  };

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
    [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>;
  };

  export type MessageGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: MessageWhereInput;
    orderBy?:
      | MessageOrderByWithAggregationInput
      | MessageOrderByWithAggregationInput[];
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum;
    having?: MessageScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MessageCountAggregateInputType | true;
    _avg?: MessageAvgAggregateInputType;
    _sum?: MessageSumAggregateInputType;
    _min?: MessageMinAggregateInputType;
    _max?: MessageMaxAggregateInputType;
  };

  export type MessageGroupByOutputType = {
    idMessage: number;
    idUserSender: number | null;
    idUserReceiver: number | null;
    message: string | null;
    timeSend: Date | null;
    _count: MessageCountAggregateOutputType | null;
    _avg: MessageAvgAggregateOutputType | null;
    _sum: MessageSumAggregateOutputType | null;
    _min: MessageMinAggregateOutputType | null;
    _max: MessageMaxAggregateOutputType | null;
  };

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<MessageGroupByOutputType, T['by']> & {
          [P in keyof T & keyof MessageGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>;
        }
      >
    >;

  export type MessageSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idMessage?: boolean;
      idUserSender?: boolean;
      idUserReceiver?: boolean;
      message?: boolean;
      timeSend?: boolean;
      User_Message_idUserReceiverToUser?:
        | boolean
        | Message$User_Message_idUserReceiverToUserArgs<ExtArgs>;
      User_Message_idUserSenderToUser?:
        | boolean
        | Message$User_Message_idUserSenderToUserArgs<ExtArgs>;
    },
    ExtArgs['result']['message']
  >;

  export type MessageSelectScalar = {
    idMessage?: boolean;
    idUserSender?: boolean;
    idUserReceiver?: boolean;
    message?: boolean;
    timeSend?: boolean;
  };

  export type MessageOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idMessage' | 'idUserSender' | 'idUserReceiver' | 'message' | 'timeSend',
    ExtArgs['result']['message']
  >;
  export type MessageInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    User_Message_idUserReceiverToUser?:
      | boolean
      | Message$User_Message_idUserReceiverToUserArgs<ExtArgs>;
    User_Message_idUserSenderToUser?:
      | boolean
      | Message$User_Message_idUserSenderToUserArgs<ExtArgs>;
  };

  export type $MessagePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Message';
    objects: {
      User_Message_idUserReceiverToUser: Prisma.$UserPayload<ExtArgs> | null;
      User_Message_idUserSenderToUser: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idMessage: number;
        idUserSender: number | null;
        idUserReceiver: number | null;
        message: string | null;
        timeSend: Date | null;
      },
      ExtArgs['result']['message']
    >;
    composites: {};
  };

  type MessageGetPayload<
    S extends boolean | null | undefined | MessageDefaultArgs
  > = $Result.GetResult<Prisma.$MessagePayload, S>;

  type MessageCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: MessageCountAggregateInputType | true;
  };

  export interface MessageDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Message'];
      meta: { name: 'Message' };
    };
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(
      args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(
      args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(
      args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     *
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     *
     * // Only select the `idMessage`
     * const messageWithIdMessageOnly = await prisma.message.findMany({ select: { idMessage: true } })
     *
     */
    findMany<T extends MessageFindManyArgs>(
      args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     *
     */
    create<T extends MessageCreateArgs>(
      args: SelectSubset<T, MessageCreateArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends MessageCreateManyArgs>(
      args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     *
     */
    delete<T extends MessageDeleteArgs>(
      args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends MessageUpdateArgs>(
      args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends MessageDeleteManyArgs>(
      args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends MessageUpdateManyArgs>(
      args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(
      args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
     **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MessageAggregateArgs>(
      args: Subset<T, MessageAggregateArgs>
    ): Prisma.PrismaPromise<GetMessageAggregateType<T>>;

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetMessageGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Message model
     */
    readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    User_Message_idUserReceiverToUser<
      T extends Message$User_Message_idUserReceiverToUserArgs<ExtArgs> = {}
    >(
      args?: Subset<T, Message$User_Message_idUserReceiverToUserArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    User_Message_idUserSenderToUser<
      T extends Message$User_Message_idUserSenderToUserArgs<ExtArgs> = {}
    >(
      args?: Subset<T, Message$User_Message_idUserSenderToUserArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly idMessage: FieldRef<'Message', 'Int'>;
    readonly idUserSender: FieldRef<'Message', 'Int'>;
    readonly idUserReceiver: FieldRef<'Message', 'Int'>;
    readonly message: FieldRef<'Message', 'String'>;
    readonly timeSend: FieldRef<'Message', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput;
  };

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput;
  };

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Messages to fetch.
     */
    orderBy?:
      | MessageOrderByWithRelationInput
      | MessageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Messages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[];
  };

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Messages to fetch.
     */
    orderBy?:
      | MessageOrderByWithRelationInput
      | MessageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Messages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[];
  };

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Messages to fetch.
     */
    orderBy?:
      | MessageOrderByWithRelationInput
      | MessageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Messages.
     */
    skip?: number;
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[];
  };

  /**
   * Message create
   */
  export type MessageCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * The data needed to create a Message.
     */
    data?: XOR<MessageCreateInput, MessageUncheckedCreateInput>;
  };

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Message update
   */
  export type MessageUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>;
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput;
  };

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>;
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput;
    /**
     * Limit how many Messages to update.
     */
    limit?: number;
  };

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput;
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>;
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>;
  };

  /**
   * Message delete
   */
  export type MessageDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput;
  };

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput;
    /**
     * Limit how many Messages to delete.
     */
    limit?: number;
  };

  /**
   * Message.User_Message_idUserReceiverToUser
   */
  export type Message$User_Message_idUserReceiverToUserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Message.User_Message_idUserSenderToUser
   */
  export type Message$User_Message_idUserSenderToUserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Message without action
   */
  export type MessageDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
  };

  /**
   * Model Note
   */

  export type AggregateNote = {
    _count: NoteCountAggregateOutputType | null;
    _avg: NoteAvgAggregateOutputType | null;
    _sum: NoteSumAggregateOutputType | null;
    _min: NoteMinAggregateOutputType | null;
    _max: NoteMaxAggregateOutputType | null;
  };

  export type NoteAvgAggregateOutputType = {
    idNote: number | null;
    idUser: number | null;
    idCourse: number | null;
    idSection: number | null;
    idLecture: number | null;
  };

  export type NoteSumAggregateOutputType = {
    idNote: number | null;
    idUser: number | null;
    idCourse: number | null;
    idSection: number | null;
    idLecture: number | null;
  };

  export type NoteMinAggregateOutputType = {
    idNote: number | null;
    timeNote: Date | null;
    note: string | null;
    idUser: number | null;
    idCourse: number | null;
    idSection: number | null;
    idLecture: number | null;
  };

  export type NoteMaxAggregateOutputType = {
    idNote: number | null;
    timeNote: Date | null;
    note: string | null;
    idUser: number | null;
    idCourse: number | null;
    idSection: number | null;
    idLecture: number | null;
  };

  export type NoteCountAggregateOutputType = {
    idNote: number;
    timeNote: number;
    note: number;
    idUser: number;
    idCourse: number;
    idSection: number;
    idLecture: number;
    _all: number;
  };

  export type NoteAvgAggregateInputType = {
    idNote?: true;
    idUser?: true;
    idCourse?: true;
    idSection?: true;
    idLecture?: true;
  };

  export type NoteSumAggregateInputType = {
    idNote?: true;
    idUser?: true;
    idCourse?: true;
    idSection?: true;
    idLecture?: true;
  };

  export type NoteMinAggregateInputType = {
    idNote?: true;
    timeNote?: true;
    note?: true;
    idUser?: true;
    idCourse?: true;
    idSection?: true;
    idLecture?: true;
  };

  export type NoteMaxAggregateInputType = {
    idNote?: true;
    timeNote?: true;
    note?: true;
    idUser?: true;
    idCourse?: true;
    idSection?: true;
    idLecture?: true;
  };

  export type NoteCountAggregateInputType = {
    idNote?: true;
    timeNote?: true;
    note?: true;
    idUser?: true;
    idCourse?: true;
    idSection?: true;
    idLecture?: true;
    _all?: true;
  };

  export type NoteAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Note to aggregate.
     */
    where?: NoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Notes
     **/
    _count?: true | NoteCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: NoteAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: NoteSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NoteMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NoteMaxAggregateInputType;
  };

  export type GetNoteAggregateType<T extends NoteAggregateArgs> = {
    [P in keyof T & keyof AggregateNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNote[P]>
      : GetScalarType<T[P], AggregateNote[P]>;
  };

  export type NoteGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: NoteWhereInput;
    orderBy?:
      | NoteOrderByWithAggregationInput
      | NoteOrderByWithAggregationInput[];
    by: NoteScalarFieldEnum[] | NoteScalarFieldEnum;
    having?: NoteScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NoteCountAggregateInputType | true;
    _avg?: NoteAvgAggregateInputType;
    _sum?: NoteSumAggregateInputType;
    _min?: NoteMinAggregateInputType;
    _max?: NoteMaxAggregateInputType;
  };

  export type NoteGroupByOutputType = {
    idNote: number;
    timeNote: Date | null;
    note: string | null;
    idUser: number | null;
    idCourse: number | null;
    idSection: number | null;
    idLecture: number | null;
    _count: NoteCountAggregateOutputType | null;
    _avg: NoteAvgAggregateOutputType | null;
    _sum: NoteSumAggregateOutputType | null;
    _min: NoteMinAggregateOutputType | null;
    _max: NoteMaxAggregateOutputType | null;
  };

  type GetNoteGroupByPayload<T extends NoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteGroupByOutputType, T['by']> & {
        [P in keyof T & keyof NoteGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], NoteGroupByOutputType[P]>
          : GetScalarType<T[P], NoteGroupByOutputType[P]>;
      }
    >
  >;

  export type NoteSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idNote?: boolean;
      timeNote?: boolean;
      note?: boolean;
      idUser?: boolean;
      idCourse?: boolean;
      idSection?: boolean;
      idLecture?: boolean;
      Lecture?: boolean | Note$LectureArgs<ExtArgs>;
      User?: boolean | Note$UserArgs<ExtArgs>;
    },
    ExtArgs['result']['note']
  >;

  export type NoteSelectScalar = {
    idNote?: boolean;
    timeNote?: boolean;
    note?: boolean;
    idUser?: boolean;
    idCourse?: boolean;
    idSection?: boolean;
    idLecture?: boolean;
  };

  export type NoteOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'idNote'
    | 'timeNote'
    | 'note'
    | 'idUser'
    | 'idCourse'
    | 'idSection'
    | 'idLecture',
    ExtArgs['result']['note']
  >;
  export type NoteInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Lecture?: boolean | Note$LectureArgs<ExtArgs>;
    User?: boolean | Note$UserArgs<ExtArgs>;
  };

  export type $NotePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Note';
    objects: {
      Lecture: Prisma.$LecturePayload<ExtArgs> | null;
      User: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idNote: number;
        timeNote: Date | null;
        note: string | null;
        idUser: number | null;
        idCourse: number | null;
        idSection: number | null;
        idLecture: number | null;
      },
      ExtArgs['result']['note']
    >;
    composites: {};
  };

  type NoteGetPayload<S extends boolean | null | undefined | NoteDefaultArgs> =
    $Result.GetResult<Prisma.$NotePayload, S>;

  type NoteCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<NoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: NoteCountAggregateInputType | true;
  };

  export interface NoteDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Note'];
      meta: { name: 'Note' };
    };
    /**
     * Find zero or one Note that matches the filter.
     * @param {NoteFindUniqueArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoteFindUniqueArgs>(
      args: SelectSubset<T, NoteFindUniqueArgs<ExtArgs>>
    ): Prisma__NoteClient<
      $Result.GetResult<
        Prisma.$NotePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Note that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoteFindUniqueOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoteFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NoteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NoteClient<
      $Result.GetResult<
        Prisma.$NotePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoteFindFirstArgs>(
      args?: SelectSubset<T, NoteFindFirstArgs<ExtArgs>>
    ): Prisma__NoteClient<
      $Result.GetResult<
        Prisma.$NotePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Note that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NoteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NoteClient<
      $Result.GetResult<
        Prisma.$NotePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.note.findMany()
     *
     * // Get first 10 Notes
     * const notes = await prisma.note.findMany({ take: 10 })
     *
     * // Only select the `idNote`
     * const noteWithIdNoteOnly = await prisma.note.findMany({ select: { idNote: true } })
     *
     */
    findMany<T extends NoteFindManyArgs>(
      args?: SelectSubset<T, NoteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Note.
     * @param {NoteCreateArgs} args - Arguments to create a Note.
     * @example
     * // Create one Note
     * const Note = await prisma.note.create({
     *   data: {
     *     // ... data to create a Note
     *   }
     * })
     *
     */
    create<T extends NoteCreateArgs>(
      args: SelectSubset<T, NoteCreateArgs<ExtArgs>>
    ): Prisma__NoteClient<
      $Result.GetResult<
        Prisma.$NotePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Notes.
     * @param {NoteCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NoteCreateManyArgs>(
      args?: SelectSubset<T, NoteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Note.
     * @param {NoteDeleteArgs} args - Arguments to delete one Note.
     * @example
     * // Delete one Note
     * const Note = await prisma.note.delete({
     *   where: {
     *     // ... filter to delete one Note
     *   }
     * })
     *
     */
    delete<T extends NoteDeleteArgs>(
      args: SelectSubset<T, NoteDeleteArgs<ExtArgs>>
    ): Prisma__NoteClient<
      $Result.GetResult<
        Prisma.$NotePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Note.
     * @param {NoteUpdateArgs} args - Arguments to update one Note.
     * @example
     * // Update one Note
     * const note = await prisma.note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NoteUpdateArgs>(
      args: SelectSubset<T, NoteUpdateArgs<ExtArgs>>
    ): Prisma__NoteClient<
      $Result.GetResult<
        Prisma.$NotePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Notes.
     * @param {NoteDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NoteDeleteManyArgs>(
      args?: SelectSubset<T, NoteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NoteUpdateManyArgs>(
      args: SelectSubset<T, NoteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Note.
     * @param {NoteUpsertArgs} args - Arguments to update or create a Note.
     * @example
     * // Update or create a Note
     * const note = await prisma.note.upsert({
     *   create: {
     *     // ... data to create a Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Note we want to update
     *   }
     * })
     */
    upsert<T extends NoteUpsertArgs>(
      args: SelectSubset<T, NoteUpsertArgs<ExtArgs>>
    ): Prisma__NoteClient<
      $Result.GetResult<
        Prisma.$NotePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.note.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
     **/
    count<T extends NoteCountArgs>(
      args?: Subset<T, NoteCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NoteAggregateArgs>(
      args: Subset<T, NoteAggregateArgs>
    ): Prisma.PrismaPromise<GetNoteAggregateType<T>>;

    /**
     * Group by Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteGroupByArgs['orderBy'] }
        : { orderBy?: NoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, NoteGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetNoteGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Note model
     */
    readonly fields: NoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Lecture<T extends Note$LectureArgs<ExtArgs> = {}>(
      args?: Subset<T, Note$LectureArgs<ExtArgs>>
    ): Prisma__LectureClient<
      $Result.GetResult<
        Prisma.$LecturePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    User<T extends Note$UserArgs<ExtArgs> = {}>(
      args?: Subset<T, Note$UserArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Note model
   */
  interface NoteFieldRefs {
    readonly idNote: FieldRef<'Note', 'Int'>;
    readonly timeNote: FieldRef<'Note', 'DateTime'>;
    readonly note: FieldRef<'Note', 'String'>;
    readonly idUser: FieldRef<'Note', 'Int'>;
    readonly idCourse: FieldRef<'Note', 'Int'>;
    readonly idSection: FieldRef<'Note', 'Int'>;
    readonly idLecture: FieldRef<'Note', 'Int'>;
  }

  // Custom InputTypes
  /**
   * Note findUnique
   */
  export type NoteFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null;
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput;
  };

  /**
   * Note findUniqueOrThrow
   */
  export type NoteFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null;
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput;
  };

  /**
   * Note findFirst
   */
  export type NoteFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null;
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[];
  };

  /**
   * Note findFirstOrThrow
   */
  export type NoteFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null;
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[];
  };

  /**
   * Note findMany
   */
  export type NoteFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null;
    /**
     * Filter, which Notes to fetch.
     */
    where?: NoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Notes.
     */
    cursor?: NoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notes.
     */
    skip?: number;
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[];
  };

  /**
   * Note create
   */
  export type NoteCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null;
    /**
     * The data needed to create a Note.
     */
    data?: XOR<NoteCreateInput, NoteUncheckedCreateInput>;
  };

  /**
   * Note createMany
   */
  export type NoteCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Note update
   */
  export type NoteUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null;
    /**
     * The data needed to update a Note.
     */
    data: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>;
    /**
     * Choose, which Note to update.
     */
    where: NoteWhereUniqueInput;
  };

  /**
   * Note updateMany
   */
  export type NoteUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Notes.
     */
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyInput>;
    /**
     * Filter which Notes to update
     */
    where?: NoteWhereInput;
    /**
     * Limit how many Notes to update.
     */
    limit?: number;
  };

  /**
   * Note upsert
   */
  export type NoteUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null;
    /**
     * The filter to search for the Note to update in case it exists.
     */
    where: NoteWhereUniqueInput;
    /**
     * In case the Note found by the `where` argument doesn't exist, create a new Note with this data.
     */
    create: XOR<NoteCreateInput, NoteUncheckedCreateInput>;
    /**
     * In case the Note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>;
  };

  /**
   * Note delete
   */
  export type NoteDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null;
    /**
     * Filter which Note to delete.
     */
    where: NoteWhereUniqueInput;
  };

  /**
   * Note deleteMany
   */
  export type NoteDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Notes to delete
     */
    where?: NoteWhereInput;
    /**
     * Limit how many Notes to delete.
     */
    limit?: number;
  };

  /**
   * Note.Lecture
   */
  export type Note$LectureArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    where?: LectureWhereInput;
  };

  /**
   * Note.User
   */
  export type Note$UserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Note without action
   */
  export type NoteDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null;
  };

  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null;
    _avg: NotificationAvgAggregateOutputType | null;
    _sum: NotificationSumAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
  };

  export type NotificationAvgAggregateOutputType = {
    idNotification: number | null;
    idUser: number | null;
  };

  export type NotificationSumAggregateOutputType = {
    idNotification: number | null;
    idUser: number | null;
  };

  export type NotificationMinAggregateOutputType = {
    idNotification: number | null;
    contentNotification: string | null;
    idUser: number | null;
  };

  export type NotificationMaxAggregateOutputType = {
    idNotification: number | null;
    contentNotification: string | null;
    idUser: number | null;
  };

  export type NotificationCountAggregateOutputType = {
    idNotification: number;
    contentNotification: number;
    idUser: number;
    _all: number;
  };

  export type NotificationAvgAggregateInputType = {
    idNotification?: true;
    idUser?: true;
  };

  export type NotificationSumAggregateInputType = {
    idNotification?: true;
    idUser?: true;
  };

  export type NotificationMinAggregateInputType = {
    idNotification?: true;
    contentNotification?: true;
    idUser?: true;
  };

  export type NotificationMaxAggregateInputType = {
    idNotification?: true;
    contentNotification?: true;
    idUser?: true;
  };

  export type NotificationCountAggregateInputType = {
    idNotification?: true;
    contentNotification?: true;
    idUser?: true;
    _all?: true;
  };

  export type NotificationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Notifications
     **/
    _count?: true | NotificationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: NotificationAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: NotificationSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationMaxAggregateInputType;
  };

  export type GetNotificationAggregateType<
    T extends NotificationAggregateArgs
  > = {
    [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>;
  };

  export type NotificationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: NotificationWhereInput;
    orderBy?:
      | NotificationOrderByWithAggregationInput
      | NotificationOrderByWithAggregationInput[];
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum;
    having?: NotificationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationCountAggregateInputType | true;
    _avg?: NotificationAvgAggregateInputType;
    _sum?: NotificationSumAggregateInputType;
    _min?: NotificationMinAggregateInputType;
    _max?: NotificationMaxAggregateInputType;
  };

  export type NotificationGroupByOutputType = {
    idNotification: number;
    contentNotification: string | null;
    idUser: number | null;
    _count: NotificationCountAggregateOutputType | null;
    _avg: NotificationAvgAggregateOutputType | null;
    _sum: NotificationSumAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
  };

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<NotificationGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof NotificationGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>;
        }
      >
    >;

  export type NotificationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idNotification?: boolean;
      contentNotification?: boolean;
      idUser?: boolean;
      User?: boolean | Notification$UserArgs<ExtArgs>;
      NotificationReceiver?:
        | boolean
        | Notification$NotificationReceiverArgs<ExtArgs>;
      _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectScalar = {
    idNotification?: boolean;
    contentNotification?: boolean;
    idUser?: boolean;
  };

  export type NotificationOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idNotification' | 'contentNotification' | 'idUser',
    ExtArgs['result']['notification']
  >;
  export type NotificationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    User?: boolean | Notification$UserArgs<ExtArgs>;
    NotificationReceiver?:
      | boolean
      | Notification$NotificationReceiverArgs<ExtArgs>;
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $NotificationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Notification';
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null;
      NotificationReceiver: Prisma.$NotificationReceiverPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idNotification: number;
        contentNotification: string | null;
        idUser: number | null;
      },
      ExtArgs['result']['notification']
    >;
    composites: {};
  };

  type NotificationGetPayload<
    S extends boolean | null | undefined | NotificationDefaultArgs
  > = $Result.GetResult<Prisma.$NotificationPayload, S>;

  type NotificationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    NotificationFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: NotificationCountAggregateInputType | true;
  };

  export interface NotificationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Notification'];
      meta: { name: 'Notification' };
    };
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     *
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     *
     * // Only select the `idNotification`
     * const notificationWithIdNotificationOnly = await prisma.notification.findMany({ select: { idNotification: true } })
     *
     */
    findMany<T extends NotificationFindManyArgs>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     *
     */
    create<T extends NotificationCreateArgs>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationCreateManyArgs>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     *
     */
    delete<T extends NotificationDeleteArgs>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationUpdateArgs>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationDeleteManyArgs>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationUpdateManyArgs>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
     **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationAggregateArgs>(
      args: Subset<T, NotificationAggregateArgs>
    ): Prisma.PrismaPromise<GetNotificationAggregateType<T>>;

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetNotificationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Notification model
     */
    readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    User<T extends Notification$UserArgs<ExtArgs> = {}>(
      args?: Subset<T, Notification$UserArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    NotificationReceiver<
      T extends Notification$NotificationReceiverArgs<ExtArgs> = {}
    >(
      args?: Subset<T, Notification$NotificationReceiverArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$NotificationReceiverPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly idNotification: FieldRef<'Notification', 'Int'>;
    readonly contentNotification: FieldRef<'Notification', 'String'>;
    readonly idUser: FieldRef<'Notification', 'Int'>;
  }

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification create
   */
  export type NotificationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Notification.
     */
    data?: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
  };

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<
      NotificationUpdateManyMutationInput,
      NotificationUncheckedUpdateManyInput
    >;
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to update.
     */
    limit?: number;
  };

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput;
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
  };

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number;
  };

  /**
   * Notification.User
   */
  export type Notification$UserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Notification.NotificationReceiver
   */
  export type Notification$NotificationReceiverArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the NotificationReceiver
     */
    select?: NotificationReceiverSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationReceiver
     */
    omit?: NotificationReceiverOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReceiverInclude<ExtArgs> | null;
    where?: NotificationReceiverWhereInput;
    orderBy?:
      | NotificationReceiverOrderByWithRelationInput
      | NotificationReceiverOrderByWithRelationInput[];
    cursor?: NotificationReceiverWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | NotificationReceiverScalarFieldEnum
      | NotificationReceiverScalarFieldEnum[];
  };

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
  };

  /**
   * Model NotificationReceiver
   */

  export type AggregateNotificationReceiver = {
    _count: NotificationReceiverCountAggregateOutputType | null;
    _avg: NotificationReceiverAvgAggregateOutputType | null;
    _sum: NotificationReceiverSumAggregateOutputType | null;
    _min: NotificationReceiverMinAggregateOutputType | null;
    _max: NotificationReceiverMaxAggregateOutputType | null;
  };

  export type NotificationReceiverAvgAggregateOutputType = {
    idNotification: number | null;
    idUser: number | null;
  };

  export type NotificationReceiverSumAggregateOutputType = {
    idNotification: number | null;
    idUser: number | null;
  };

  export type NotificationReceiverMinAggregateOutputType = {
    idNotification: number | null;
    idUser: number | null;
    timeGetNotification: Date | null;
  };

  export type NotificationReceiverMaxAggregateOutputType = {
    idNotification: number | null;
    idUser: number | null;
    timeGetNotification: Date | null;
  };

  export type NotificationReceiverCountAggregateOutputType = {
    idNotification: number;
    idUser: number;
    timeGetNotification: number;
    _all: number;
  };

  export type NotificationReceiverAvgAggregateInputType = {
    idNotification?: true;
    idUser?: true;
  };

  export type NotificationReceiverSumAggregateInputType = {
    idNotification?: true;
    idUser?: true;
  };

  export type NotificationReceiverMinAggregateInputType = {
    idNotification?: true;
    idUser?: true;
    timeGetNotification?: true;
  };

  export type NotificationReceiverMaxAggregateInputType = {
    idNotification?: true;
    idUser?: true;
    timeGetNotification?: true;
  };

  export type NotificationReceiverCountAggregateInputType = {
    idNotification?: true;
    idUser?: true;
    timeGetNotification?: true;
    _all?: true;
  };

  export type NotificationReceiverAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which NotificationReceiver to aggregate.
     */
    where?: NotificationReceiverWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationReceivers to fetch.
     */
    orderBy?:
      | NotificationReceiverOrderByWithRelationInput
      | NotificationReceiverOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationReceiverWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationReceivers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationReceivers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned NotificationReceivers
     **/
    _count?: true | NotificationReceiverCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: NotificationReceiverAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: NotificationReceiverSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationReceiverMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationReceiverMaxAggregateInputType;
  };

  export type GetNotificationReceiverAggregateType<
    T extends NotificationReceiverAggregateArgs
  > = {
    [P in keyof T & keyof AggregateNotificationReceiver]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationReceiver[P]>
      : GetScalarType<T[P], AggregateNotificationReceiver[P]>;
  };

  export type NotificationReceiverGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: NotificationReceiverWhereInput;
    orderBy?:
      | NotificationReceiverOrderByWithAggregationInput
      | NotificationReceiverOrderByWithAggregationInput[];
    by:
      | NotificationReceiverScalarFieldEnum[]
      | NotificationReceiverScalarFieldEnum;
    having?: NotificationReceiverScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationReceiverCountAggregateInputType | true;
    _avg?: NotificationReceiverAvgAggregateInputType;
    _sum?: NotificationReceiverSumAggregateInputType;
    _min?: NotificationReceiverMinAggregateInputType;
    _max?: NotificationReceiverMaxAggregateInputType;
  };

  export type NotificationReceiverGroupByOutputType = {
    idNotification: number;
    idUser: number;
    timeGetNotification: Date | null;
    _count: NotificationReceiverCountAggregateOutputType | null;
    _avg: NotificationReceiverAvgAggregateOutputType | null;
    _sum: NotificationReceiverSumAggregateOutputType | null;
    _min: NotificationReceiverMinAggregateOutputType | null;
    _max: NotificationReceiverMaxAggregateOutputType | null;
  };

  type GetNotificationReceiverGroupByPayload<
    T extends NotificationReceiverGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationReceiverGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof NotificationReceiverGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], NotificationReceiverGroupByOutputType[P]>
          : GetScalarType<T[P], NotificationReceiverGroupByOutputType[P]>;
      }
    >
  >;

  export type NotificationReceiverSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idNotification?: boolean;
      idUser?: boolean;
      timeGetNotification?: boolean;
      Notification?: boolean | NotificationDefaultArgs<ExtArgs>;
      User?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notificationReceiver']
  >;

  export type NotificationReceiverSelectScalar = {
    idNotification?: boolean;
    idUser?: boolean;
    timeGetNotification?: boolean;
  };

  export type NotificationReceiverOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idNotification' | 'idUser' | 'timeGetNotification',
    ExtArgs['result']['notificationReceiver']
  >;
  export type NotificationReceiverInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Notification?: boolean | NotificationDefaultArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $NotificationReceiverPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'NotificationReceiver';
    objects: {
      Notification: Prisma.$NotificationPayload<ExtArgs>;
      User: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idNotification: number;
        idUser: number;
        timeGetNotification: Date | null;
      },
      ExtArgs['result']['notificationReceiver']
    >;
    composites: {};
  };

  type NotificationReceiverGetPayload<
    S extends boolean | null | undefined | NotificationReceiverDefaultArgs
  > = $Result.GetResult<Prisma.$NotificationReceiverPayload, S>;

  type NotificationReceiverCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    NotificationReceiverFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: NotificationReceiverCountAggregateInputType | true;
  };

  export interface NotificationReceiverDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['NotificationReceiver'];
      meta: { name: 'NotificationReceiver' };
    };
    /**
     * Find zero or one NotificationReceiver that matches the filter.
     * @param {NotificationReceiverFindUniqueArgs} args - Arguments to find a NotificationReceiver
     * @example
     * // Get one NotificationReceiver
     * const notificationReceiver = await prisma.notificationReceiver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationReceiverFindUniqueArgs>(
      args: SelectSubset<T, NotificationReceiverFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationReceiverClient<
      $Result.GetResult<
        Prisma.$NotificationReceiverPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one NotificationReceiver that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationReceiverFindUniqueOrThrowArgs} args - Arguments to find a NotificationReceiver
     * @example
     * // Get one NotificationReceiver
     * const notificationReceiver = await prisma.notificationReceiver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationReceiverFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationReceiverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationReceiverClient<
      $Result.GetResult<
        Prisma.$NotificationReceiverPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationReceiver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReceiverFindFirstArgs} args - Arguments to find a NotificationReceiver
     * @example
     * // Get one NotificationReceiver
     * const notificationReceiver = await prisma.notificationReceiver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationReceiverFindFirstArgs>(
      args?: SelectSubset<T, NotificationReceiverFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationReceiverClient<
      $Result.GetResult<
        Prisma.$NotificationReceiverPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationReceiver that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReceiverFindFirstOrThrowArgs} args - Arguments to find a NotificationReceiver
     * @example
     * // Get one NotificationReceiver
     * const notificationReceiver = await prisma.notificationReceiver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationReceiverFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationReceiverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationReceiverClient<
      $Result.GetResult<
        Prisma.$NotificationReceiverPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more NotificationReceivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReceiverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationReceivers
     * const notificationReceivers = await prisma.notificationReceiver.findMany()
     *
     * // Get first 10 NotificationReceivers
     * const notificationReceivers = await prisma.notificationReceiver.findMany({ take: 10 })
     *
     * // Only select the `idNotification`
     * const notificationReceiverWithIdNotificationOnly = await prisma.notificationReceiver.findMany({ select: { idNotification: true } })
     *
     */
    findMany<T extends NotificationReceiverFindManyArgs>(
      args?: SelectSubset<T, NotificationReceiverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationReceiverPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a NotificationReceiver.
     * @param {NotificationReceiverCreateArgs} args - Arguments to create a NotificationReceiver.
     * @example
     * // Create one NotificationReceiver
     * const NotificationReceiver = await prisma.notificationReceiver.create({
     *   data: {
     *     // ... data to create a NotificationReceiver
     *   }
     * })
     *
     */
    create<T extends NotificationReceiverCreateArgs>(
      args: SelectSubset<T, NotificationReceiverCreateArgs<ExtArgs>>
    ): Prisma__NotificationReceiverClient<
      $Result.GetResult<
        Prisma.$NotificationReceiverPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many NotificationReceivers.
     * @param {NotificationReceiverCreateManyArgs} args - Arguments to create many NotificationReceivers.
     * @example
     * // Create many NotificationReceivers
     * const notificationReceiver = await prisma.notificationReceiver.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationReceiverCreateManyArgs>(
      args?: SelectSubset<T, NotificationReceiverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a NotificationReceiver.
     * @param {NotificationReceiverDeleteArgs} args - Arguments to delete one NotificationReceiver.
     * @example
     * // Delete one NotificationReceiver
     * const NotificationReceiver = await prisma.notificationReceiver.delete({
     *   where: {
     *     // ... filter to delete one NotificationReceiver
     *   }
     * })
     *
     */
    delete<T extends NotificationReceiverDeleteArgs>(
      args: SelectSubset<T, NotificationReceiverDeleteArgs<ExtArgs>>
    ): Prisma__NotificationReceiverClient<
      $Result.GetResult<
        Prisma.$NotificationReceiverPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one NotificationReceiver.
     * @param {NotificationReceiverUpdateArgs} args - Arguments to update one NotificationReceiver.
     * @example
     * // Update one NotificationReceiver
     * const notificationReceiver = await prisma.notificationReceiver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationReceiverUpdateArgs>(
      args: SelectSubset<T, NotificationReceiverUpdateArgs<ExtArgs>>
    ): Prisma__NotificationReceiverClient<
      $Result.GetResult<
        Prisma.$NotificationReceiverPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more NotificationReceivers.
     * @param {NotificationReceiverDeleteManyArgs} args - Arguments to filter NotificationReceivers to delete.
     * @example
     * // Delete a few NotificationReceivers
     * const { count } = await prisma.notificationReceiver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationReceiverDeleteManyArgs>(
      args?: SelectSubset<T, NotificationReceiverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationReceivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReceiverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationReceivers
     * const notificationReceiver = await prisma.notificationReceiver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationReceiverUpdateManyArgs>(
      args: SelectSubset<T, NotificationReceiverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one NotificationReceiver.
     * @param {NotificationReceiverUpsertArgs} args - Arguments to update or create a NotificationReceiver.
     * @example
     * // Update or create a NotificationReceiver
     * const notificationReceiver = await prisma.notificationReceiver.upsert({
     *   create: {
     *     // ... data to create a NotificationReceiver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationReceiver we want to update
     *   }
     * })
     */
    upsert<T extends NotificationReceiverUpsertArgs>(
      args: SelectSubset<T, NotificationReceiverUpsertArgs<ExtArgs>>
    ): Prisma__NotificationReceiverClient<
      $Result.GetResult<
        Prisma.$NotificationReceiverPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of NotificationReceivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReceiverCountArgs} args - Arguments to filter NotificationReceivers to count.
     * @example
     * // Count the number of NotificationReceivers
     * const count = await prisma.notificationReceiver.count({
     *   where: {
     *     // ... the filter for the NotificationReceivers we want to count
     *   }
     * })
     **/
    count<T extends NotificationReceiverCountArgs>(
      args?: Subset<T, NotificationReceiverCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              NotificationReceiverCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a NotificationReceiver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReceiverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationReceiverAggregateArgs>(
      args: Subset<T, NotificationReceiverAggregateArgs>
    ): Prisma.PrismaPromise<GetNotificationReceiverAggregateType<T>>;

    /**
     * Group by NotificationReceiver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReceiverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationReceiverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationReceiverGroupByArgs['orderBy'] }
        : { orderBy?: NotificationReceiverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, NotificationReceiverGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetNotificationReceiverGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the NotificationReceiver model
     */
    readonly fields: NotificationReceiverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationReceiver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationReceiverClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Notification<T extends NotificationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, NotificationDefaultArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      | $Result.GetResult<
          Prisma.$NotificationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    User<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the NotificationReceiver model
   */
  interface NotificationReceiverFieldRefs {
    readonly idNotification: FieldRef<'NotificationReceiver', 'Int'>;
    readonly idUser: FieldRef<'NotificationReceiver', 'Int'>;
    readonly timeGetNotification: FieldRef<'NotificationReceiver', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * NotificationReceiver findUnique
   */
  export type NotificationReceiverFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the NotificationReceiver
     */
    select?: NotificationReceiverSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationReceiver
     */
    omit?: NotificationReceiverOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReceiverInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationReceiver to fetch.
     */
    where: NotificationReceiverWhereUniqueInput;
  };

  /**
   * NotificationReceiver findUniqueOrThrow
   */
  export type NotificationReceiverFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the NotificationReceiver
     */
    select?: NotificationReceiverSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationReceiver
     */
    omit?: NotificationReceiverOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReceiverInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationReceiver to fetch.
     */
    where: NotificationReceiverWhereUniqueInput;
  };

  /**
   * NotificationReceiver findFirst
   */
  export type NotificationReceiverFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the NotificationReceiver
     */
    select?: NotificationReceiverSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationReceiver
     */
    omit?: NotificationReceiverOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReceiverInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationReceiver to fetch.
     */
    where?: NotificationReceiverWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationReceivers to fetch.
     */
    orderBy?:
      | NotificationReceiverOrderByWithRelationInput
      | NotificationReceiverOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationReceivers.
     */
    cursor?: NotificationReceiverWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationReceivers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationReceivers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationReceivers.
     */
    distinct?:
      | NotificationReceiverScalarFieldEnum
      | NotificationReceiverScalarFieldEnum[];
  };

  /**
   * NotificationReceiver findFirstOrThrow
   */
  export type NotificationReceiverFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the NotificationReceiver
     */
    select?: NotificationReceiverSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationReceiver
     */
    omit?: NotificationReceiverOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReceiverInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationReceiver to fetch.
     */
    where?: NotificationReceiverWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationReceivers to fetch.
     */
    orderBy?:
      | NotificationReceiverOrderByWithRelationInput
      | NotificationReceiverOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationReceivers.
     */
    cursor?: NotificationReceiverWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationReceivers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationReceivers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationReceivers.
     */
    distinct?:
      | NotificationReceiverScalarFieldEnum
      | NotificationReceiverScalarFieldEnum[];
  };

  /**
   * NotificationReceiver findMany
   */
  export type NotificationReceiverFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the NotificationReceiver
     */
    select?: NotificationReceiverSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationReceiver
     */
    omit?: NotificationReceiverOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReceiverInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationReceivers to fetch.
     */
    where?: NotificationReceiverWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationReceivers to fetch.
     */
    orderBy?:
      | NotificationReceiverOrderByWithRelationInput
      | NotificationReceiverOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing NotificationReceivers.
     */
    cursor?: NotificationReceiverWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationReceivers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationReceivers.
     */
    skip?: number;
    distinct?:
      | NotificationReceiverScalarFieldEnum
      | NotificationReceiverScalarFieldEnum[];
  };

  /**
   * NotificationReceiver create
   */
  export type NotificationReceiverCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the NotificationReceiver
     */
    select?: NotificationReceiverSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationReceiver
     */
    omit?: NotificationReceiverOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReceiverInclude<ExtArgs> | null;
    /**
     * The data needed to create a NotificationReceiver.
     */
    data: XOR<
      NotificationReceiverCreateInput,
      NotificationReceiverUncheckedCreateInput
    >;
  };

  /**
   * NotificationReceiver createMany
   */
  export type NotificationReceiverCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many NotificationReceivers.
     */
    data:
      | NotificationReceiverCreateManyInput
      | NotificationReceiverCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * NotificationReceiver update
   */
  export type NotificationReceiverUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the NotificationReceiver
     */
    select?: NotificationReceiverSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationReceiver
     */
    omit?: NotificationReceiverOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReceiverInclude<ExtArgs> | null;
    /**
     * The data needed to update a NotificationReceiver.
     */
    data: XOR<
      NotificationReceiverUpdateInput,
      NotificationReceiverUncheckedUpdateInput
    >;
    /**
     * Choose, which NotificationReceiver to update.
     */
    where: NotificationReceiverWhereUniqueInput;
  };

  /**
   * NotificationReceiver updateMany
   */
  export type NotificationReceiverUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update NotificationReceivers.
     */
    data: XOR<
      NotificationReceiverUpdateManyMutationInput,
      NotificationReceiverUncheckedUpdateManyInput
    >;
    /**
     * Filter which NotificationReceivers to update
     */
    where?: NotificationReceiverWhereInput;
    /**
     * Limit how many NotificationReceivers to update.
     */
    limit?: number;
  };

  /**
   * NotificationReceiver upsert
   */
  export type NotificationReceiverUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the NotificationReceiver
     */
    select?: NotificationReceiverSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationReceiver
     */
    omit?: NotificationReceiverOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReceiverInclude<ExtArgs> | null;
    /**
     * The filter to search for the NotificationReceiver to update in case it exists.
     */
    where: NotificationReceiverWhereUniqueInput;
    /**
     * In case the NotificationReceiver found by the `where` argument doesn't exist, create a new NotificationReceiver with this data.
     */
    create: XOR<
      NotificationReceiverCreateInput,
      NotificationReceiverUncheckedCreateInput
    >;
    /**
     * In case the NotificationReceiver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      NotificationReceiverUpdateInput,
      NotificationReceiverUncheckedUpdateInput
    >;
  };

  /**
   * NotificationReceiver delete
   */
  export type NotificationReceiverDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the NotificationReceiver
     */
    select?: NotificationReceiverSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationReceiver
     */
    omit?: NotificationReceiverOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReceiverInclude<ExtArgs> | null;
    /**
     * Filter which NotificationReceiver to delete.
     */
    where: NotificationReceiverWhereUniqueInput;
  };

  /**
   * NotificationReceiver deleteMany
   */
  export type NotificationReceiverDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which NotificationReceivers to delete
     */
    where?: NotificationReceiverWhereInput;
    /**
     * Limit how many NotificationReceivers to delete.
     */
    limit?: number;
  };

  /**
   * NotificationReceiver without action
   */
  export type NotificationReceiverDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the NotificationReceiver
     */
    select?: NotificationReceiverSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationReceiver
     */
    omit?: NotificationReceiverOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReceiverInclude<ExtArgs> | null;
  };

  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null;
    _avg: PaymentAvgAggregateOutputType | null;
    _sum: PaymentSumAggregateOutputType | null;
    _min: PaymentMinAggregateOutputType | null;
    _max: PaymentMaxAggregateOutputType | null;
  };

  export type PaymentAvgAggregateOutputType = {
    idPayment: number | null;
    totalPrice: Decimal | null;
    idUser: number | null;
  };

  export type PaymentSumAggregateOutputType = {
    idPayment: number | null;
    totalPrice: Decimal | null;
    idUser: number | null;
  };

  export type PaymentMinAggregateOutputType = {
    idPayment: number | null;
    timePayment: Date | null;
    totalPrice: Decimal | null;
    idUser: number | null;
  };

  export type PaymentMaxAggregateOutputType = {
    idPayment: number | null;
    timePayment: Date | null;
    totalPrice: Decimal | null;
    idUser: number | null;
  };

  export type PaymentCountAggregateOutputType = {
    idPayment: number;
    timePayment: number;
    totalPrice: number;
    idUser: number;
    _all: number;
  };

  export type PaymentAvgAggregateInputType = {
    idPayment?: true;
    totalPrice?: true;
    idUser?: true;
  };

  export type PaymentSumAggregateInputType = {
    idPayment?: true;
    totalPrice?: true;
    idUser?: true;
  };

  export type PaymentMinAggregateInputType = {
    idPayment?: true;
    timePayment?: true;
    totalPrice?: true;
    idUser?: true;
  };

  export type PaymentMaxAggregateInputType = {
    idPayment?: true;
    timePayment?: true;
    totalPrice?: true;
    idUser?: true;
  };

  export type PaymentCountAggregateInputType = {
    idPayment?: true;
    timePayment?: true;
    totalPrice?: true;
    idUser?: true;
    _all?: true;
  };

  export type PaymentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?:
      | PaymentOrderByWithRelationInput
      | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Payments
     **/
    _count?: true | PaymentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: PaymentAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: PaymentSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PaymentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PaymentMaxAggregateInputType;
  };

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
    [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>;
  };

  export type PaymentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: PaymentWhereInput;
    orderBy?:
      | PaymentOrderByWithAggregationInput
      | PaymentOrderByWithAggregationInput[];
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum;
    having?: PaymentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PaymentCountAggregateInputType | true;
    _avg?: PaymentAvgAggregateInputType;
    _sum?: PaymentSumAggregateInputType;
    _min?: PaymentMinAggregateInputType;
    _max?: PaymentMaxAggregateInputType;
  };

  export type PaymentGroupByOutputType = {
    idPayment: number;
    timePayment: Date | null;
    totalPrice: Decimal | null;
    idUser: number | null;
    _count: PaymentCountAggregateOutputType | null;
    _avg: PaymentAvgAggregateOutputType | null;
    _sum: PaymentSumAggregateOutputType | null;
    _min: PaymentMinAggregateOutputType | null;
    _max: PaymentMaxAggregateOutputType | null;
  };

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PaymentGroupByOutputType, T['by']> & {
          [P in keyof T & keyof PaymentGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>;
        }
      >
    >;

  export type PaymentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idPayment?: boolean;
      timePayment?: boolean;
      totalPrice?: boolean;
      idUser?: boolean;
      User?: boolean | Payment$UserArgs<ExtArgs>;
      PaymentDetail?: boolean | Payment$PaymentDetailArgs<ExtArgs>;
      _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['payment']
  >;

  export type PaymentSelectScalar = {
    idPayment?: boolean;
    timePayment?: boolean;
    totalPrice?: boolean;
    idUser?: boolean;
  };

  export type PaymentOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idPayment' | 'timePayment' | 'totalPrice' | 'idUser',
    ExtArgs['result']['payment']
  >;
  export type PaymentInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    User?: boolean | Payment$UserArgs<ExtArgs>;
    PaymentDetail?: boolean | Payment$PaymentDetailArgs<ExtArgs>;
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $PaymentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Payment';
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null;
      PaymentDetail: Prisma.$PaymentDetailPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idPayment: number;
        timePayment: Date | null;
        totalPrice: Prisma.Decimal | null;
        idUser: number | null;
      },
      ExtArgs['result']['payment']
    >;
    composites: {};
  };

  type PaymentGetPayload<
    S extends boolean | null | undefined | PaymentDefaultArgs
  > = $Result.GetResult<Prisma.$PaymentPayload, S>;

  type PaymentCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PaymentCountAggregateInputType | true;
  };

  export interface PaymentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Payment'];
      meta: { name: 'Payment' };
    };
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(
      args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(
      args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     *
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     *
     * // Only select the `idPayment`
     * const paymentWithIdPaymentOnly = await prisma.payment.findMany({ select: { idPayment: true } })
     *
     */
    findMany<T extends PaymentFindManyArgs>(
      args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     *
     */
    create<T extends PaymentCreateArgs>(
      args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PaymentCreateManyArgs>(
      args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     *
     */
    delete<T extends PaymentDeleteArgs>(
      args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PaymentUpdateArgs>(
      args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PaymentDeleteManyArgs>(
      args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PaymentUpdateManyArgs>(
      args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(
      args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
     **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PaymentAggregateArgs>(
      args: Subset<T, PaymentAggregateArgs>
    ): Prisma.PrismaPromise<GetPaymentAggregateType<T>>;

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetPaymentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Payment model
     */
    readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    User<T extends Payment$UserArgs<ExtArgs> = {}>(
      args?: Subset<T, Payment$UserArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    PaymentDetail<T extends Payment$PaymentDetailArgs<ExtArgs> = {}>(
      args?: Subset<T, Payment$PaymentDetailArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PaymentDetailPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly idPayment: FieldRef<'Payment', 'Int'>;
    readonly timePayment: FieldRef<'Payment', 'DateTime'>;
    readonly totalPrice: FieldRef<'Payment', 'Decimal'>;
    readonly idUser: FieldRef<'Payment', 'Int'>;
  }

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?:
      | PaymentOrderByWithRelationInput
      | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
  };

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?:
      | PaymentOrderByWithRelationInput
      | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
  };

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?:
      | PaymentOrderByWithRelationInput
      | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
  };

  /**
   * Payment create
   */
  export type PaymentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * The data needed to create a Payment.
     */
    data?: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>;
  };

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>;
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>;
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput;
    /**
     * Limit how many Payments to update.
     */
    limit?: number;
  };

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput;
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>;
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>;
  };

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput;
    /**
     * Limit how many Payments to delete.
     */
    limit?: number;
  };

  /**
   * Payment.User
   */
  export type Payment$UserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Payment.PaymentDetail
   */
  export type Payment$PaymentDetailArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null;
    where?: PaymentDetailWhereInput;
    orderBy?:
      | PaymentDetailOrderByWithRelationInput
      | PaymentDetailOrderByWithRelationInput[];
    cursor?: PaymentDetailWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PaymentDetailScalarFieldEnum | PaymentDetailScalarFieldEnum[];
  };

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
  };

  /**
   * Model PaymentDetail
   */

  export type AggregatePaymentDetail = {
    _count: PaymentDetailCountAggregateOutputType | null;
    _avg: PaymentDetailAvgAggregateOutputType | null;
    _sum: PaymentDetailSumAggregateOutputType | null;
    _min: PaymentDetailMinAggregateOutputType | null;
    _max: PaymentDetailMaxAggregateOutputType | null;
  };

  export type PaymentDetailAvgAggregateOutputType = {
    idPayment: number | null;
    idCourse: number | null;
    price: Decimal | null;
  };

  export type PaymentDetailSumAggregateOutputType = {
    idPayment: number | null;
    idCourse: number | null;
    price: Decimal | null;
  };

  export type PaymentDetailMinAggregateOutputType = {
    idPayment: number | null;
    idCourse: number | null;
    price: Decimal | null;
  };

  export type PaymentDetailMaxAggregateOutputType = {
    idPayment: number | null;
    idCourse: number | null;
    price: Decimal | null;
  };

  export type PaymentDetailCountAggregateOutputType = {
    idPayment: number;
    idCourse: number;
    price: number;
    _all: number;
  };

  export type PaymentDetailAvgAggregateInputType = {
    idPayment?: true;
    idCourse?: true;
    price?: true;
  };

  export type PaymentDetailSumAggregateInputType = {
    idPayment?: true;
    idCourse?: true;
    price?: true;
  };

  export type PaymentDetailMinAggregateInputType = {
    idPayment?: true;
    idCourse?: true;
    price?: true;
  };

  export type PaymentDetailMaxAggregateInputType = {
    idPayment?: true;
    idCourse?: true;
    price?: true;
  };

  export type PaymentDetailCountAggregateInputType = {
    idPayment?: true;
    idCourse?: true;
    price?: true;
    _all?: true;
  };

  export type PaymentDetailAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which PaymentDetail to aggregate.
     */
    where?: PaymentDetailWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PaymentDetails to fetch.
     */
    orderBy?:
      | PaymentDetailOrderByWithRelationInput
      | PaymentDetailOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PaymentDetailWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PaymentDetails from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PaymentDetails.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PaymentDetails
     **/
    _count?: true | PaymentDetailCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: PaymentDetailAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: PaymentDetailSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PaymentDetailMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PaymentDetailMaxAggregateInputType;
  };

  export type GetPaymentDetailAggregateType<
    T extends PaymentDetailAggregateArgs
  > = {
    [P in keyof T & keyof AggregatePaymentDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentDetail[P]>
      : GetScalarType<T[P], AggregatePaymentDetail[P]>;
  };

  export type PaymentDetailGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: PaymentDetailWhereInput;
    orderBy?:
      | PaymentDetailOrderByWithAggregationInput
      | PaymentDetailOrderByWithAggregationInput[];
    by: PaymentDetailScalarFieldEnum[] | PaymentDetailScalarFieldEnum;
    having?: PaymentDetailScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PaymentDetailCountAggregateInputType | true;
    _avg?: PaymentDetailAvgAggregateInputType;
    _sum?: PaymentDetailSumAggregateInputType;
    _min?: PaymentDetailMinAggregateInputType;
    _max?: PaymentDetailMaxAggregateInputType;
  };

  export type PaymentDetailGroupByOutputType = {
    idPayment: number;
    idCourse: number;
    price: Decimal | null;
    _count: PaymentDetailCountAggregateOutputType | null;
    _avg: PaymentDetailAvgAggregateOutputType | null;
    _sum: PaymentDetailSumAggregateOutputType | null;
    _min: PaymentDetailMinAggregateOutputType | null;
    _max: PaymentDetailMaxAggregateOutputType | null;
  };

  type GetPaymentDetailGroupByPayload<T extends PaymentDetailGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PaymentDetailGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof PaymentDetailGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentDetailGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentDetailGroupByOutputType[P]>;
        }
      >
    >;

  export type PaymentDetailSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idPayment?: boolean;
      idCourse?: boolean;
      price?: boolean;
      Course?: boolean | CourseDefaultArgs<ExtArgs>;
      Payment?: boolean | PaymentDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['paymentDetail']
  >;

  export type PaymentDetailSelectScalar = {
    idPayment?: boolean;
    idCourse?: boolean;
    price?: boolean;
  };

  export type PaymentDetailOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idPayment' | 'idCourse' | 'price',
    ExtArgs['result']['paymentDetail']
  >;
  export type PaymentDetailInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Course?: boolean | CourseDefaultArgs<ExtArgs>;
    Payment?: boolean | PaymentDefaultArgs<ExtArgs>;
  };

  export type $PaymentDetailPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'PaymentDetail';
    objects: {
      Course: Prisma.$CoursePayload<ExtArgs>;
      Payment: Prisma.$PaymentPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idPayment: number;
        idCourse: number;
        price: Prisma.Decimal | null;
      },
      ExtArgs['result']['paymentDetail']
    >;
    composites: {};
  };

  type PaymentDetailGetPayload<
    S extends boolean | null | undefined | PaymentDetailDefaultArgs
  > = $Result.GetResult<Prisma.$PaymentDetailPayload, S>;

  type PaymentDetailCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    PaymentDetailFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: PaymentDetailCountAggregateInputType | true;
  };

  export interface PaymentDetailDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['PaymentDetail'];
      meta: { name: 'PaymentDetail' };
    };
    /**
     * Find zero or one PaymentDetail that matches the filter.
     * @param {PaymentDetailFindUniqueArgs} args - Arguments to find a PaymentDetail
     * @example
     * // Get one PaymentDetail
     * const paymentDetail = await prisma.paymentDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentDetailFindUniqueArgs>(
      args: SelectSubset<T, PaymentDetailFindUniqueArgs<ExtArgs>>
    ): Prisma__PaymentDetailClient<
      $Result.GetResult<
        Prisma.$PaymentDetailPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one PaymentDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentDetailFindUniqueOrThrowArgs} args - Arguments to find a PaymentDetail
     * @example
     * // Get one PaymentDetail
     * const paymentDetail = await prisma.paymentDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentDetailFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PaymentDetailFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentDetailClient<
      $Result.GetResult<
        Prisma.$PaymentDetailPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PaymentDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailFindFirstArgs} args - Arguments to find a PaymentDetail
     * @example
     * // Get one PaymentDetail
     * const paymentDetail = await prisma.paymentDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentDetailFindFirstArgs>(
      args?: SelectSubset<T, PaymentDetailFindFirstArgs<ExtArgs>>
    ): Prisma__PaymentDetailClient<
      $Result.GetResult<
        Prisma.$PaymentDetailPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PaymentDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailFindFirstOrThrowArgs} args - Arguments to find a PaymentDetail
     * @example
     * // Get one PaymentDetail
     * const paymentDetail = await prisma.paymentDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentDetailFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PaymentDetailFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentDetailClient<
      $Result.GetResult<
        Prisma.$PaymentDetailPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more PaymentDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentDetails
     * const paymentDetails = await prisma.paymentDetail.findMany()
     *
     * // Get first 10 PaymentDetails
     * const paymentDetails = await prisma.paymentDetail.findMany({ take: 10 })
     *
     * // Only select the `idPayment`
     * const paymentDetailWithIdPaymentOnly = await prisma.paymentDetail.findMany({ select: { idPayment: true } })
     *
     */
    findMany<T extends PaymentDetailFindManyArgs>(
      args?: SelectSubset<T, PaymentDetailFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PaymentDetailPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a PaymentDetail.
     * @param {PaymentDetailCreateArgs} args - Arguments to create a PaymentDetail.
     * @example
     * // Create one PaymentDetail
     * const PaymentDetail = await prisma.paymentDetail.create({
     *   data: {
     *     // ... data to create a PaymentDetail
     *   }
     * })
     *
     */
    create<T extends PaymentDetailCreateArgs>(
      args: SelectSubset<T, PaymentDetailCreateArgs<ExtArgs>>
    ): Prisma__PaymentDetailClient<
      $Result.GetResult<
        Prisma.$PaymentDetailPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many PaymentDetails.
     * @param {PaymentDetailCreateManyArgs} args - Arguments to create many PaymentDetails.
     * @example
     * // Create many PaymentDetails
     * const paymentDetail = await prisma.paymentDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PaymentDetailCreateManyArgs>(
      args?: SelectSubset<T, PaymentDetailCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a PaymentDetail.
     * @param {PaymentDetailDeleteArgs} args - Arguments to delete one PaymentDetail.
     * @example
     * // Delete one PaymentDetail
     * const PaymentDetail = await prisma.paymentDetail.delete({
     *   where: {
     *     // ... filter to delete one PaymentDetail
     *   }
     * })
     *
     */
    delete<T extends PaymentDetailDeleteArgs>(
      args: SelectSubset<T, PaymentDetailDeleteArgs<ExtArgs>>
    ): Prisma__PaymentDetailClient<
      $Result.GetResult<
        Prisma.$PaymentDetailPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one PaymentDetail.
     * @param {PaymentDetailUpdateArgs} args - Arguments to update one PaymentDetail.
     * @example
     * // Update one PaymentDetail
     * const paymentDetail = await prisma.paymentDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PaymentDetailUpdateArgs>(
      args: SelectSubset<T, PaymentDetailUpdateArgs<ExtArgs>>
    ): Prisma__PaymentDetailClient<
      $Result.GetResult<
        Prisma.$PaymentDetailPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more PaymentDetails.
     * @param {PaymentDetailDeleteManyArgs} args - Arguments to filter PaymentDetails to delete.
     * @example
     * // Delete a few PaymentDetails
     * const { count } = await prisma.paymentDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PaymentDetailDeleteManyArgs>(
      args?: SelectSubset<T, PaymentDetailDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more PaymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentDetails
     * const paymentDetail = await prisma.paymentDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PaymentDetailUpdateManyArgs>(
      args: SelectSubset<T, PaymentDetailUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one PaymentDetail.
     * @param {PaymentDetailUpsertArgs} args - Arguments to update or create a PaymentDetail.
     * @example
     * // Update or create a PaymentDetail
     * const paymentDetail = await prisma.paymentDetail.upsert({
     *   create: {
     *     // ... data to create a PaymentDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentDetail we want to update
     *   }
     * })
     */
    upsert<T extends PaymentDetailUpsertArgs>(
      args: SelectSubset<T, PaymentDetailUpsertArgs<ExtArgs>>
    ): Prisma__PaymentDetailClient<
      $Result.GetResult<
        Prisma.$PaymentDetailPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of PaymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailCountArgs} args - Arguments to filter PaymentDetails to count.
     * @example
     * // Count the number of PaymentDetails
     * const count = await prisma.paymentDetail.count({
     *   where: {
     *     // ... the filter for the PaymentDetails we want to count
     *   }
     * })
     **/
    count<T extends PaymentDetailCountArgs>(
      args?: Subset<T, PaymentDetailCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentDetailCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a PaymentDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PaymentDetailAggregateArgs>(
      args: Subset<T, PaymentDetailAggregateArgs>
    ): Prisma.PrismaPromise<GetPaymentDetailAggregateType<T>>;

    /**
     * Group by PaymentDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PaymentDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentDetailGroupByArgs['orderBy'] }
        : { orderBy?: PaymentDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, PaymentDetailGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetPaymentDetailGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the PaymentDetail model
     */
    readonly fields: PaymentDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentDetailClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Course<T extends CourseDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CourseDefaultArgs<ExtArgs>>
    ): Prisma__CourseClient<
      | $Result.GetResult<
          Prisma.$CoursePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    Payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, PaymentDefaultArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      | $Result.GetResult<
          Prisma.$PaymentPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the PaymentDetail model
   */
  interface PaymentDetailFieldRefs {
    readonly idPayment: FieldRef<'PaymentDetail', 'Int'>;
    readonly idCourse: FieldRef<'PaymentDetail', 'Int'>;
    readonly price: FieldRef<'PaymentDetail', 'Decimal'>;
  }

  // Custom InputTypes
  /**
   * PaymentDetail findUnique
   */
  export type PaymentDetailFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null;
    /**
     * Filter, which PaymentDetail to fetch.
     */
    where: PaymentDetailWhereUniqueInput;
  };

  /**
   * PaymentDetail findUniqueOrThrow
   */
  export type PaymentDetailFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null;
    /**
     * Filter, which PaymentDetail to fetch.
     */
    where: PaymentDetailWhereUniqueInput;
  };

  /**
   * PaymentDetail findFirst
   */
  export type PaymentDetailFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null;
    /**
     * Filter, which PaymentDetail to fetch.
     */
    where?: PaymentDetailWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PaymentDetails to fetch.
     */
    orderBy?:
      | PaymentDetailOrderByWithRelationInput
      | PaymentDetailOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PaymentDetails.
     */
    cursor?: PaymentDetailWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PaymentDetails from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PaymentDetails.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PaymentDetails.
     */
    distinct?: PaymentDetailScalarFieldEnum | PaymentDetailScalarFieldEnum[];
  };

  /**
   * PaymentDetail findFirstOrThrow
   */
  export type PaymentDetailFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null;
    /**
     * Filter, which PaymentDetail to fetch.
     */
    where?: PaymentDetailWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PaymentDetails to fetch.
     */
    orderBy?:
      | PaymentDetailOrderByWithRelationInput
      | PaymentDetailOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PaymentDetails.
     */
    cursor?: PaymentDetailWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PaymentDetails from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PaymentDetails.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PaymentDetails.
     */
    distinct?: PaymentDetailScalarFieldEnum | PaymentDetailScalarFieldEnum[];
  };

  /**
   * PaymentDetail findMany
   */
  export type PaymentDetailFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null;
    /**
     * Filter, which PaymentDetails to fetch.
     */
    where?: PaymentDetailWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PaymentDetails to fetch.
     */
    orderBy?:
      | PaymentDetailOrderByWithRelationInput
      | PaymentDetailOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PaymentDetails.
     */
    cursor?: PaymentDetailWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PaymentDetails from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PaymentDetails.
     */
    skip?: number;
    distinct?: PaymentDetailScalarFieldEnum | PaymentDetailScalarFieldEnum[];
  };

  /**
   * PaymentDetail create
   */
  export type PaymentDetailCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null;
    /**
     * The data needed to create a PaymentDetail.
     */
    data: XOR<PaymentDetailCreateInput, PaymentDetailUncheckedCreateInput>;
  };

  /**
   * PaymentDetail createMany
   */
  export type PaymentDetailCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many PaymentDetails.
     */
    data: PaymentDetailCreateManyInput | PaymentDetailCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * PaymentDetail update
   */
  export type PaymentDetailUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null;
    /**
     * The data needed to update a PaymentDetail.
     */
    data: XOR<PaymentDetailUpdateInput, PaymentDetailUncheckedUpdateInput>;
    /**
     * Choose, which PaymentDetail to update.
     */
    where: PaymentDetailWhereUniqueInput;
  };

  /**
   * PaymentDetail updateMany
   */
  export type PaymentDetailUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update PaymentDetails.
     */
    data: XOR<
      PaymentDetailUpdateManyMutationInput,
      PaymentDetailUncheckedUpdateManyInput
    >;
    /**
     * Filter which PaymentDetails to update
     */
    where?: PaymentDetailWhereInput;
    /**
     * Limit how many PaymentDetails to update.
     */
    limit?: number;
  };

  /**
   * PaymentDetail upsert
   */
  export type PaymentDetailUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null;
    /**
     * The filter to search for the PaymentDetail to update in case it exists.
     */
    where: PaymentDetailWhereUniqueInput;
    /**
     * In case the PaymentDetail found by the `where` argument doesn't exist, create a new PaymentDetail with this data.
     */
    create: XOR<PaymentDetailCreateInput, PaymentDetailUncheckedCreateInput>;
    /**
     * In case the PaymentDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentDetailUpdateInput, PaymentDetailUncheckedUpdateInput>;
  };

  /**
   * PaymentDetail delete
   */
  export type PaymentDetailDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null;
    /**
     * Filter which PaymentDetail to delete.
     */
    where: PaymentDetailWhereUniqueInput;
  };

  /**
   * PaymentDetail deleteMany
   */
  export type PaymentDetailDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which PaymentDetails to delete
     */
    where?: PaymentDetailWhereInput;
    /**
     * Limit how many PaymentDetails to delete.
     */
    limit?: number;
  };

  /**
   * PaymentDetail without action
   */
  export type PaymentDetailDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null;
  };

  /**
   * Model Question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null;
    _avg: QuestionAvgAggregateOutputType | null;
    _sum: QuestionSumAggregateOutputType | null;
    _min: QuestionMinAggregateOutputType | null;
    _max: QuestionMaxAggregateOutputType | null;
  };

  export type QuestionAvgAggregateOutputType = {
    idQuestion: number | null;
    idUser: number | null;
    idCourse: number | null;
    idSection: number | null;
    idLecture: number | null;
  };

  export type QuestionSumAggregateOutputType = {
    idQuestion: number | null;
    idUser: number | null;
    idCourse: number | null;
    idSection: number | null;
    idLecture: number | null;
  };

  export type QuestionMinAggregateOutputType = {
    idQuestion: number | null;
    idUser: number | null;
    idCourse: number | null;
    idSection: number | null;
    idLecture: number | null;
    contentQuestion: string | null;
  };

  export type QuestionMaxAggregateOutputType = {
    idQuestion: number | null;
    idUser: number | null;
    idCourse: number | null;
    idSection: number | null;
    idLecture: number | null;
    contentQuestion: string | null;
  };

  export type QuestionCountAggregateOutputType = {
    idQuestion: number;
    idUser: number;
    idCourse: number;
    idSection: number;
    idLecture: number;
    contentQuestion: number;
    _all: number;
  };

  export type QuestionAvgAggregateInputType = {
    idQuestion?: true;
    idUser?: true;
    idCourse?: true;
    idSection?: true;
    idLecture?: true;
  };

  export type QuestionSumAggregateInputType = {
    idQuestion?: true;
    idUser?: true;
    idCourse?: true;
    idSection?: true;
    idLecture?: true;
  };

  export type QuestionMinAggregateInputType = {
    idQuestion?: true;
    idUser?: true;
    idCourse?: true;
    idSection?: true;
    idLecture?: true;
    contentQuestion?: true;
  };

  export type QuestionMaxAggregateInputType = {
    idQuestion?: true;
    idUser?: true;
    idCourse?: true;
    idSection?: true;
    idLecture?: true;
    contentQuestion?: true;
  };

  export type QuestionCountAggregateInputType = {
    idQuestion?: true;
    idUser?: true;
    idCourse?: true;
    idSection?: true;
    idLecture?: true;
    contentQuestion?: true;
    _all?: true;
  };

  export type QuestionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Question to aggregate.
     */
    where?: QuestionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Questions to fetch.
     */
    orderBy?:
      | QuestionOrderByWithRelationInput
      | QuestionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: QuestionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Questions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Questions
     **/
    _count?: true | QuestionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: QuestionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: QuestionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: QuestionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: QuestionMaxAggregateInputType;
  };

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
    [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>;
  };

  export type QuestionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: QuestionWhereInput;
    orderBy?:
      | QuestionOrderByWithAggregationInput
      | QuestionOrderByWithAggregationInput[];
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum;
    having?: QuestionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: QuestionCountAggregateInputType | true;
    _avg?: QuestionAvgAggregateInputType;
    _sum?: QuestionSumAggregateInputType;
    _min?: QuestionMinAggregateInputType;
    _max?: QuestionMaxAggregateInputType;
  };

  export type QuestionGroupByOutputType = {
    idQuestion: number;
    idUser: number | null;
    idCourse: number | null;
    idSection: number | null;
    idLecture: number | null;
    contentQuestion: string | null;
    _count: QuestionCountAggregateOutputType | null;
    _avg: QuestionAvgAggregateOutputType | null;
    _sum: QuestionSumAggregateOutputType | null;
    _min: QuestionMinAggregateOutputType | null;
    _max: QuestionMaxAggregateOutputType | null;
  };

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<QuestionGroupByOutputType, T['by']> & {
          [P in keyof T & keyof QuestionGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>;
        }
      >
    >;

  export type QuestionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idQuestion?: boolean;
      idUser?: boolean;
      idCourse?: boolean;
      idSection?: boolean;
      idLecture?: boolean;
      contentQuestion?: boolean;
      Answer?: boolean | Question$AnswerArgs<ExtArgs>;
      Lecture?: boolean | Question$LectureArgs<ExtArgs>;
      User?: boolean | Question$UserArgs<ExtArgs>;
      _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['question']
  >;

  export type QuestionSelectScalar = {
    idQuestion?: boolean;
    idUser?: boolean;
    idCourse?: boolean;
    idSection?: boolean;
    idLecture?: boolean;
    contentQuestion?: boolean;
  };

  export type QuestionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'idQuestion'
    | 'idUser'
    | 'idCourse'
    | 'idSection'
    | 'idLecture'
    | 'contentQuestion',
    ExtArgs['result']['question']
  >;
  export type QuestionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Answer?: boolean | Question$AnswerArgs<ExtArgs>;
    Lecture?: boolean | Question$LectureArgs<ExtArgs>;
    User?: boolean | Question$UserArgs<ExtArgs>;
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $QuestionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Question';
    objects: {
      Answer: Prisma.$AnswerPayload<ExtArgs>[];
      Lecture: Prisma.$LecturePayload<ExtArgs> | null;
      User: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idQuestion: number;
        idUser: number | null;
        idCourse: number | null;
        idSection: number | null;
        idLecture: number | null;
        contentQuestion: string | null;
      },
      ExtArgs['result']['question']
    >;
    composites: {};
  };

  type QuestionGetPayload<
    S extends boolean | null | undefined | QuestionDefaultArgs
  > = $Result.GetResult<Prisma.$QuestionPayload, S>;

  type QuestionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<QuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: QuestionCountAggregateInputType | true;
  };

  export interface QuestionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Question'];
      meta: { name: 'Question' };
    };
    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionFindUniqueArgs>(
      args: SelectSubset<T, QuestionFindUniqueArgs<ExtArgs>>
    ): Prisma__QuestionClient<
      $Result.GetResult<
        Prisma.$QuestionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, QuestionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__QuestionClient<
      $Result.GetResult<
        Prisma.$QuestionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionFindFirstArgs>(
      args?: SelectSubset<T, QuestionFindFirstArgs<ExtArgs>>
    ): Prisma__QuestionClient<
      $Result.GetResult<
        Prisma.$QuestionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuestionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__QuestionClient<
      $Result.GetResult<
        Prisma.$QuestionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     *
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     *
     * // Only select the `idQuestion`
     * const questionWithIdQuestionOnly = await prisma.question.findMany({ select: { idQuestion: true } })
     *
     */
    findMany<T extends QuestionFindManyArgs>(
      args?: SelectSubset<T, QuestionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$QuestionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     *
     */
    create<T extends QuestionCreateArgs>(
      args: SelectSubset<T, QuestionCreateArgs<ExtArgs>>
    ): Prisma__QuestionClient<
      $Result.GetResult<
        Prisma.$QuestionPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Questions.
     * @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends QuestionCreateManyArgs>(
      args?: SelectSubset<T, QuestionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     *
     */
    delete<T extends QuestionDeleteArgs>(
      args: SelectSubset<T, QuestionDeleteArgs<ExtArgs>>
    ): Prisma__QuestionClient<
      $Result.GetResult<
        Prisma.$QuestionPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends QuestionUpdateArgs>(
      args: SelectSubset<T, QuestionUpdateArgs<ExtArgs>>
    ): Prisma__QuestionClient<
      $Result.GetResult<
        Prisma.$QuestionPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends QuestionDeleteManyArgs>(
      args?: SelectSubset<T, QuestionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends QuestionUpdateManyArgs>(
      args: SelectSubset<T, QuestionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends QuestionUpsertArgs>(
      args: SelectSubset<T, QuestionUpsertArgs<ExtArgs>>
    ): Prisma__QuestionClient<
      $Result.GetResult<
        Prisma.$QuestionPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
     **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends QuestionAggregateArgs>(
      args: Subset<T, QuestionAggregateArgs>
    ): Prisma.PrismaPromise<GetQuestionAggregateType<T>>;

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetQuestionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Question model
     */
    readonly fields: QuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Answer<T extends Question$AnswerArgs<ExtArgs> = {}>(
      args?: Subset<T, Question$AnswerArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AnswerPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Lecture<T extends Question$LectureArgs<ExtArgs> = {}>(
      args?: Subset<T, Question$LectureArgs<ExtArgs>>
    ): Prisma__LectureClient<
      $Result.GetResult<
        Prisma.$LecturePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    User<T extends Question$UserArgs<ExtArgs> = {}>(
      args?: Subset<T, Question$UserArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Question model
   */
  interface QuestionFieldRefs {
    readonly idQuestion: FieldRef<'Question', 'Int'>;
    readonly idUser: FieldRef<'Question', 'Int'>;
    readonly idCourse: FieldRef<'Question', 'Int'>;
    readonly idSection: FieldRef<'Question', 'Int'>;
    readonly idLecture: FieldRef<'Question', 'Int'>;
    readonly contentQuestion: FieldRef<'Question', 'String'>;
  }

  // Custom InputTypes
  /**
   * Question findUnique
   */
  export type QuestionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null;
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput;
  };

  /**
   * Question findUniqueOrThrow
   */
  export type QuestionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null;
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput;
  };

  /**
   * Question findFirst
   */
  export type QuestionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null;
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Questions to fetch.
     */
    orderBy?:
      | QuestionOrderByWithRelationInput
      | QuestionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Questions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[];
  };

  /**
   * Question findFirstOrThrow
   */
  export type QuestionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null;
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Questions to fetch.
     */
    orderBy?:
      | QuestionOrderByWithRelationInput
      | QuestionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Questions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[];
  };

  /**
   * Question findMany
   */
  export type QuestionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null;
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Questions to fetch.
     */
    orderBy?:
      | QuestionOrderByWithRelationInput
      | QuestionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Questions.
     */
    cursor?: QuestionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Questions.
     */
    skip?: number;
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[];
  };

  /**
   * Question create
   */
  export type QuestionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Question.
     */
    data?: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>;
  };

  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Question update
   */
  export type QuestionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Question.
     */
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>;
    /**
     * Choose, which Question to update.
     */
    where: QuestionWhereUniqueInput;
  };

  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Questions.
     */
    data: XOR<
      QuestionUpdateManyMutationInput,
      QuestionUncheckedUpdateManyInput
    >;
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput;
    /**
     * Limit how many Questions to update.
     */
    limit?: number;
  };

  /**
   * Question upsert
   */
  export type QuestionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Question to update in case it exists.
     */
    where: QuestionWhereUniqueInput;
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     */
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>;
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>;
  };

  /**
   * Question delete
   */
  export type QuestionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null;
    /**
     * Filter which Question to delete.
     */
    where: QuestionWhereUniqueInput;
  };

  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionWhereInput;
    /**
     * Limit how many Questions to delete.
     */
    limit?: number;
  };

  /**
   * Question.Answer
   */
  export type Question$AnswerArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null;
    where?: AnswerWhereInput;
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[];
    cursor?: AnswerWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[];
  };

  /**
   * Question.Lecture
   */
  export type Question$LectureArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    where?: LectureWhereInput;
  };

  /**
   * Question.User
   */
  export type Question$UserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Question without action
   */
  export type QuestionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null;
  };

  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null;
    _avg: ReportAvgAggregateOutputType | null;
    _sum: ReportSumAggregateOutputType | null;
    _min: ReportMinAggregateOutputType | null;
    _max: ReportMaxAggregateOutputType | null;
  };

  export type ReportAvgAggregateOutputType = {
    idReport: number | null;
    idUser: number | null;
  };

  export type ReportSumAggregateOutputType = {
    idReport: number | null;
    idUser: number | null;
  };

  export type ReportMinAggregateOutputType = {
    idReport: number | null;
    idUser: number | null;
    contentReport: string | null;
  };

  export type ReportMaxAggregateOutputType = {
    idReport: number | null;
    idUser: number | null;
    contentReport: string | null;
  };

  export type ReportCountAggregateOutputType = {
    idReport: number;
    idUser: number;
    contentReport: number;
    _all: number;
  };

  export type ReportAvgAggregateInputType = {
    idReport?: true;
    idUser?: true;
  };

  export type ReportSumAggregateInputType = {
    idReport?: true;
    idUser?: true;
  };

  export type ReportMinAggregateInputType = {
    idReport?: true;
    idUser?: true;
    contentReport?: true;
  };

  export type ReportMaxAggregateInputType = {
    idReport?: true;
    idUser?: true;
    contentReport?: true;
  };

  export type ReportCountAggregateInputType = {
    idReport?: true;
    idUser?: true;
    contentReport?: true;
    _all?: true;
  };

  export type ReportAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reports.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Reports
     **/
    _count?: true | ReportCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ReportAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ReportSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ReportMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ReportMaxAggregateInputType;
  };

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
    [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>;
  };

  export type ReportGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ReportWhereInput;
    orderBy?:
      | ReportOrderByWithAggregationInput
      | ReportOrderByWithAggregationInput[];
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum;
    having?: ReportScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ReportCountAggregateInputType | true;
    _avg?: ReportAvgAggregateInputType;
    _sum?: ReportSumAggregateInputType;
    _min?: ReportMinAggregateInputType;
    _max?: ReportMaxAggregateInputType;
  };

  export type ReportGroupByOutputType = {
    idReport: number;
    idUser: number | null;
    contentReport: string | null;
    _count: ReportCountAggregateOutputType | null;
    _avg: ReportAvgAggregateOutputType | null;
    _sum: ReportSumAggregateOutputType | null;
    _min: ReportMinAggregateOutputType | null;
    _max: ReportMaxAggregateOutputType | null;
  };

  type GetReportGroupByPayload<T extends ReportGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ReportGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ReportGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>;
        }
      >
    >;

  export type ReportSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idReport?: boolean;
      idUser?: boolean;
      contentReport?: boolean;
      User?: boolean | Report$UserArgs<ExtArgs>;
    },
    ExtArgs['result']['report']
  >;

  export type ReportSelectScalar = {
    idReport?: boolean;
    idUser?: boolean;
    contentReport?: boolean;
  };

  export type ReportOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idReport' | 'idUser' | 'contentReport',
    ExtArgs['result']['report']
  >;
  export type ReportInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    User?: boolean | Report$UserArgs<ExtArgs>;
  };

  export type $ReportPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Report';
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idReport: number;
        idUser: number | null;
        contentReport: string | null;
      },
      ExtArgs['result']['report']
    >;
    composites: {};
  };

  type ReportGetPayload<
    S extends boolean | null | undefined | ReportDefaultArgs
  > = $Result.GetResult<Prisma.$ReportPayload, S>;

  type ReportCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ReportCountAggregateInputType | true;
  };

  export interface ReportDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Report'];
      meta: { name: 'Report' };
    };
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(
      args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>
    ): Prisma__ReportClient<
      $Result.GetResult<
        Prisma.$ReportPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<
      $Result.GetResult<
        Prisma.$ReportPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(
      args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>
    ): Prisma__ReportClient<
      $Result.GetResult<
        Prisma.$ReportPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<
      $Result.GetResult<
        Prisma.$ReportPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     *
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     *
     * // Only select the `idReport`
     * const reportWithIdReportOnly = await prisma.report.findMany({ select: { idReport: true } })
     *
     */
    findMany<T extends ReportFindManyArgs>(
      args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ReportPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     *
     */
    create<T extends ReportCreateArgs>(
      args: SelectSubset<T, ReportCreateArgs<ExtArgs>>
    ): Prisma__ReportClient<
      $Result.GetResult<
        Prisma.$ReportPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ReportCreateManyArgs>(
      args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     *
     */
    delete<T extends ReportDeleteArgs>(
      args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>
    ): Prisma__ReportClient<
      $Result.GetResult<
        Prisma.$ReportPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ReportUpdateArgs>(
      args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>
    ): Prisma__ReportClient<
      $Result.GetResult<
        Prisma.$ReportPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ReportDeleteManyArgs>(
      args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ReportUpdateManyArgs>(
      args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(
      args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>
    ): Prisma__ReportClient<
      $Result.GetResult<
        Prisma.$ReportPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
     **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ReportAggregateArgs>(
      args: Subset<T, ReportAggregateArgs>
    ): Prisma.PrismaPromise<GetReportAggregateType<T>>;

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetReportGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Report model
     */
    readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    User<T extends Report$UserArgs<ExtArgs> = {}>(
      args?: Subset<T, Report$UserArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Report model
   */
  interface ReportFieldRefs {
    readonly idReport: FieldRef<'Report', 'Int'>;
    readonly idUser: FieldRef<'Report', 'Int'>;
    readonly contentReport: FieldRef<'Report', 'String'>;
  }

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null;
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput;
  };

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null;
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput;
  };

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null;
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reports.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[];
  };

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null;
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reports.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[];
  };

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null;
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reports.
     */
    skip?: number;
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[];
  };

  /**
   * Report create
   */
  export type ReportCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null;
    /**
     * The data needed to create a Report.
     */
    data?: XOR<ReportCreateInput, ReportUncheckedCreateInput>;
  };

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Report update
   */
  export type ReportUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null;
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>;
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput;
  };

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>;
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput;
    /**
     * Limit how many Reports to update.
     */
    limit?: number;
  };

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null;
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput;
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>;
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>;
  };

  /**
   * Report delete
   */
  export type ReportDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null;
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput;
  };

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput;
    /**
     * Limit how many Reports to delete.
     */
    limit?: number;
  };

  /**
   * Report.User
   */
  export type Report$UserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Report without action
   */
  export type ReportDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null;
  };

  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null;
    _avg: ReviewAvgAggregateOutputType | null;
    _sum: ReviewSumAggregateOutputType | null;
    _min: ReviewMinAggregateOutputType | null;
    _max: ReviewMaxAggregateOutputType | null;
  };

  export type ReviewAvgAggregateOutputType = {
    idReview: number | null;
    idUser: number | null;
    idCourse: number | null;
    rating: number | null;
  };

  export type ReviewSumAggregateOutputType = {
    idReview: number | null;
    idUser: number | null;
    idCourse: number | null;
    rating: number | null;
  };

  export type ReviewMinAggregateOutputType = {
    idReview: number | null;
    idUser: number | null;
    idCourse: number | null;
    rating: number | null;
    review: string | null;
  };

  export type ReviewMaxAggregateOutputType = {
    idReview: number | null;
    idUser: number | null;
    idCourse: number | null;
    rating: number | null;
    review: string | null;
  };

  export type ReviewCountAggregateOutputType = {
    idReview: number;
    idUser: number;
    idCourse: number;
    rating: number;
    review: number;
    _all: number;
  };

  export type ReviewAvgAggregateInputType = {
    idReview?: true;
    idUser?: true;
    idCourse?: true;
    rating?: true;
  };

  export type ReviewSumAggregateInputType = {
    idReview?: true;
    idUser?: true;
    idCourse?: true;
    rating?: true;
  };

  export type ReviewMinAggregateInputType = {
    idReview?: true;
    idUser?: true;
    idCourse?: true;
    rating?: true;
    review?: true;
  };

  export type ReviewMaxAggregateInputType = {
    idReview?: true;
    idUser?: true;
    idCourse?: true;
    rating?: true;
    review?: true;
  };

  export type ReviewCountAggregateInputType = {
    idReview?: true;
    idUser?: true;
    idCourse?: true;
    rating?: true;
    review?: true;
    _all?: true;
  };

  export type ReviewAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Reviews
     **/
    _count?: true | ReviewCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ReviewAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ReviewSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ReviewMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ReviewMaxAggregateInputType;
  };

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
    [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>;
  };

  export type ReviewGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ReviewWhereInput;
    orderBy?:
      | ReviewOrderByWithAggregationInput
      | ReviewOrderByWithAggregationInput[];
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum;
    having?: ReviewScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ReviewCountAggregateInputType | true;
    _avg?: ReviewAvgAggregateInputType;
    _sum?: ReviewSumAggregateInputType;
    _min?: ReviewMinAggregateInputType;
    _max?: ReviewMaxAggregateInputType;
  };

  export type ReviewGroupByOutputType = {
    idReview: number;
    idUser: number | null;
    idCourse: number | null;
    rating: number | null;
    review: string | null;
    _count: ReviewCountAggregateOutputType | null;
    _avg: ReviewAvgAggregateOutputType | null;
    _sum: ReviewSumAggregateOutputType | null;
    _min: ReviewMinAggregateOutputType | null;
    _max: ReviewMaxAggregateOutputType | null;
  };

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ReviewGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ReviewGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>;
        }
      >
    >;

  export type ReviewSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idReview?: boolean;
      idUser?: boolean;
      idCourse?: boolean;
      rating?: boolean;
      review?: boolean;
      Course?: boolean | Review$CourseArgs<ExtArgs>;
      User?: boolean | Review$UserArgs<ExtArgs>;
    },
    ExtArgs['result']['review']
  >;

  export type ReviewSelectScalar = {
    idReview?: boolean;
    idUser?: boolean;
    idCourse?: boolean;
    rating?: boolean;
    review?: boolean;
  };

  export type ReviewOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idReview' | 'idUser' | 'idCourse' | 'rating' | 'review',
    ExtArgs['result']['review']
  >;
  export type ReviewInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Course?: boolean | Review$CourseArgs<ExtArgs>;
    User?: boolean | Review$UserArgs<ExtArgs>;
  };

  export type $ReviewPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Review';
    objects: {
      Course: Prisma.$CoursePayload<ExtArgs> | null;
      User: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idReview: number;
        idUser: number | null;
        idCourse: number | null;
        rating: number | null;
        review: string | null;
      },
      ExtArgs['result']['review']
    >;
    composites: {};
  };

  type ReviewGetPayload<
    S extends boolean | null | undefined | ReviewDefaultArgs
  > = $Result.GetResult<Prisma.$ReviewPayload, S>;

  type ReviewCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ReviewCountAggregateInputType | true;
  };

  export interface ReviewDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Review'];
      meta: { name: 'Review' };
    };
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(
      args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(
      args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     *
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     *
     * // Only select the `idReview`
     * const reviewWithIdReviewOnly = await prisma.review.findMany({ select: { idReview: true } })
     *
     */
    findMany<T extends ReviewFindManyArgs>(
      args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     *
     */
    create<T extends ReviewCreateArgs>(
      args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ReviewCreateManyArgs>(
      args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     *
     */
    delete<T extends ReviewDeleteArgs>(
      args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ReviewUpdateArgs>(
      args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ReviewDeleteManyArgs>(
      args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ReviewUpdateManyArgs>(
      args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(
      args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
     **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ReviewAggregateArgs>(
      args: Subset<T, ReviewAggregateArgs>
    ): Prisma.PrismaPromise<GetReviewAggregateType<T>>;

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetReviewGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Review model
     */
    readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Course<T extends Review$CourseArgs<ExtArgs> = {}>(
      args?: Subset<T, Review$CourseArgs<ExtArgs>>
    ): Prisma__CourseClient<
      $Result.GetResult<
        Prisma.$CoursePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    User<T extends Review$UserArgs<ExtArgs> = {}>(
      args?: Subset<T, Review$UserArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly idReview: FieldRef<'Review', 'Int'>;
    readonly idUser: FieldRef<'Review', 'Int'>;
    readonly idCourse: FieldRef<'Review', 'Int'>;
    readonly rating: FieldRef<'Review', 'Int'>;
    readonly review: FieldRef<'Review', 'String'>;
  }

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput;
  };

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput;
  };

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * Review create
   */
  export type ReviewCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * The data needed to create a Review.
     */
    data?: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>;
  };

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Review update
   */
  export type ReviewUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>;
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput;
  };

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>;
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput;
    /**
     * Limit how many Reviews to update.
     */
    limit?: number;
  };

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput;
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>;
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>;
  };

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput;
  };

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput;
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number;
  };

  /**
   * Review.Course
   */
  export type Review$CourseArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null;
    where?: CourseWhereInput;
  };

  /**
   * Review.User
   */
  export type Review$UserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
  };

  /**
   * Model Section
   */

  export type AggregateSection = {
    _count: SectionCountAggregateOutputType | null;
    _avg: SectionAvgAggregateOutputType | null;
    _sum: SectionSumAggregateOutputType | null;
    _min: SectionMinAggregateOutputType | null;
    _max: SectionMaxAggregateOutputType | null;
  };

  export type SectionAvgAggregateOutputType = {
    idCourse: number | null;
    idSection: number | null;
  };

  export type SectionSumAggregateOutputType = {
    idCourse: number | null;
    idSection: number | null;
  };

  export type SectionMinAggregateOutputType = {
    idCourse: number | null;
    idSection: number | null;
    nameSection: string | null;
  };

  export type SectionMaxAggregateOutputType = {
    idCourse: number | null;
    idSection: number | null;
    nameSection: string | null;
  };

  export type SectionCountAggregateOutputType = {
    idCourse: number;
    idSection: number;
    nameSection: number;
    _all: number;
  };

  export type SectionAvgAggregateInputType = {
    idCourse?: true;
    idSection?: true;
  };

  export type SectionSumAggregateInputType = {
    idCourse?: true;
    idSection?: true;
  };

  export type SectionMinAggregateInputType = {
    idCourse?: true;
    idSection?: true;
    nameSection?: true;
  };

  export type SectionMaxAggregateInputType = {
    idCourse?: true;
    idSection?: true;
    nameSection?: true;
  };

  export type SectionCountAggregateInputType = {
    idCourse?: true;
    idSection?: true;
    nameSection?: true;
    _all?: true;
  };

  export type SectionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Section to aggregate.
     */
    where?: SectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sections to fetch.
     */
    orderBy?:
      | SectionOrderByWithRelationInput
      | SectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Sections
     **/
    _count?: true | SectionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: SectionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: SectionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SectionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SectionMaxAggregateInputType;
  };

  export type GetSectionAggregateType<T extends SectionAggregateArgs> = {
    [P in keyof T & keyof AggregateSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSection[P]>
      : GetScalarType<T[P], AggregateSection[P]>;
  };

  export type SectionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: SectionWhereInput;
    orderBy?:
      | SectionOrderByWithAggregationInput
      | SectionOrderByWithAggregationInput[];
    by: SectionScalarFieldEnum[] | SectionScalarFieldEnum;
    having?: SectionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SectionCountAggregateInputType | true;
    _avg?: SectionAvgAggregateInputType;
    _sum?: SectionSumAggregateInputType;
    _min?: SectionMinAggregateInputType;
    _max?: SectionMaxAggregateInputType;
  };

  export type SectionGroupByOutputType = {
    idCourse: number;
    idSection: number;
    nameSection: string | null;
    _count: SectionCountAggregateOutputType | null;
    _avg: SectionAvgAggregateOutputType | null;
    _sum: SectionSumAggregateOutputType | null;
    _min: SectionMinAggregateOutputType | null;
    _max: SectionMaxAggregateOutputType | null;
  };

  type GetSectionGroupByPayload<T extends SectionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SectionGroupByOutputType, T['by']> & {
          [P in keyof T & keyof SectionGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionGroupByOutputType[P]>
            : GetScalarType<T[P], SectionGroupByOutputType[P]>;
        }
      >
    >;

  export type SectionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idCourse?: boolean;
      idSection?: boolean;
      nameSection?: boolean;
      Lecture?: boolean | Section$LectureArgs<ExtArgs>;
      Course?: boolean | CourseDefaultArgs<ExtArgs>;
      _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['section']
  >;

  export type SectionSelectScalar = {
    idCourse?: boolean;
    idSection?: boolean;
    nameSection?: boolean;
  };

  export type SectionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idCourse' | 'idSection' | 'nameSection',
    ExtArgs['result']['section']
  >;
  export type SectionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Lecture?: boolean | Section$LectureArgs<ExtArgs>;
    Course?: boolean | CourseDefaultArgs<ExtArgs>;
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $SectionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Section';
    objects: {
      Lecture: Prisma.$LecturePayload<ExtArgs>[];
      Course: Prisma.$CoursePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idCourse: number;
        idSection: number;
        nameSection: string | null;
      },
      ExtArgs['result']['section']
    >;
    composites: {};
  };

  type SectionGetPayload<
    S extends boolean | null | undefined | SectionDefaultArgs
  > = $Result.GetResult<Prisma.$SectionPayload, S>;

  type SectionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<SectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: SectionCountAggregateInputType | true;
  };

  export interface SectionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Section'];
      meta: { name: 'Section' };
    };
    /**
     * Find zero or one Section that matches the filter.
     * @param {SectionFindUniqueArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectionFindUniqueArgs>(
      args: SelectSubset<T, SectionFindUniqueArgs<ExtArgs>>
    ): Prisma__SectionClient<
      $Result.GetResult<
        Prisma.$SectionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Section that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SectionFindUniqueOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SectionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SectionClient<
      $Result.GetResult<
        Prisma.$SectionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Section that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectionFindFirstArgs>(
      args?: SelectSubset<T, SectionFindFirstArgs<ExtArgs>>
    ): Prisma__SectionClient<
      $Result.GetResult<
        Prisma.$SectionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Section that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SectionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SectionClient<
      $Result.GetResult<
        Prisma.$SectionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sections
     * const sections = await prisma.section.findMany()
     *
     * // Get first 10 Sections
     * const sections = await prisma.section.findMany({ take: 10 })
     *
     * // Only select the `idCourse`
     * const sectionWithIdCourseOnly = await prisma.section.findMany({ select: { idCourse: true } })
     *
     */
    findMany<T extends SectionFindManyArgs>(
      args?: SelectSubset<T, SectionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SectionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Section.
     * @param {SectionCreateArgs} args - Arguments to create a Section.
     * @example
     * // Create one Section
     * const Section = await prisma.section.create({
     *   data: {
     *     // ... data to create a Section
     *   }
     * })
     *
     */
    create<T extends SectionCreateArgs>(
      args: SelectSubset<T, SectionCreateArgs<ExtArgs>>
    ): Prisma__SectionClient<
      $Result.GetResult<
        Prisma.$SectionPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Sections.
     * @param {SectionCreateManyArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SectionCreateManyArgs>(
      args?: SelectSubset<T, SectionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Section.
     * @param {SectionDeleteArgs} args - Arguments to delete one Section.
     * @example
     * // Delete one Section
     * const Section = await prisma.section.delete({
     *   where: {
     *     // ... filter to delete one Section
     *   }
     * })
     *
     */
    delete<T extends SectionDeleteArgs>(
      args: SelectSubset<T, SectionDeleteArgs<ExtArgs>>
    ): Prisma__SectionClient<
      $Result.GetResult<
        Prisma.$SectionPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Section.
     * @param {SectionUpdateArgs} args - Arguments to update one Section.
     * @example
     * // Update one Section
     * const section = await prisma.section.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SectionUpdateArgs>(
      args: SelectSubset<T, SectionUpdateArgs<ExtArgs>>
    ): Prisma__SectionClient<
      $Result.GetResult<
        Prisma.$SectionPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Sections.
     * @param {SectionDeleteManyArgs} args - Arguments to filter Sections to delete.
     * @example
     * // Delete a few Sections
     * const { count } = await prisma.section.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SectionDeleteManyArgs>(
      args?: SelectSubset<T, SectionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SectionUpdateManyArgs>(
      args: SelectSubset<T, SectionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Section.
     * @param {SectionUpsertArgs} args - Arguments to update or create a Section.
     * @example
     * // Update or create a Section
     * const section = await prisma.section.upsert({
     *   create: {
     *     // ... data to create a Section
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Section we want to update
     *   }
     * })
     */
    upsert<T extends SectionUpsertArgs>(
      args: SelectSubset<T, SectionUpsertArgs<ExtArgs>>
    ): Prisma__SectionClient<
      $Result.GetResult<
        Prisma.$SectionPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionCountArgs} args - Arguments to filter Sections to count.
     * @example
     * // Count the number of Sections
     * const count = await prisma.section.count({
     *   where: {
     *     // ... the filter for the Sections we want to count
     *   }
     * })
     **/
    count<T extends SectionCountArgs>(
      args?: Subset<T, SectionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SectionAggregateArgs>(
      args: Subset<T, SectionAggregateArgs>
    ): Prisma.PrismaPromise<GetSectionAggregateType<T>>;

    /**
     * Group by Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectionGroupByArgs['orderBy'] }
        : { orderBy?: SectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, SectionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetSectionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Section model
     */
    readonly fields: SectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Section.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Lecture<T extends Section$LectureArgs<ExtArgs> = {}>(
      args?: Subset<T, Section$LectureArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$LecturePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Course<T extends CourseDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CourseDefaultArgs<ExtArgs>>
    ): Prisma__CourseClient<
      | $Result.GetResult<
          Prisma.$CoursePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Section model
   */
  interface SectionFieldRefs {
    readonly idCourse: FieldRef<'Section', 'Int'>;
    readonly idSection: FieldRef<'Section', 'Int'>;
    readonly nameSection: FieldRef<'Section', 'String'>;
  }

  // Custom InputTypes
  /**
   * Section findUnique
   */
  export type SectionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null;
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput;
  };

  /**
   * Section findUniqueOrThrow
   */
  export type SectionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null;
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput;
  };

  /**
   * Section findFirst
   */
  export type SectionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null;
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sections to fetch.
     */
    orderBy?:
      | SectionOrderByWithRelationInput
      | SectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[];
  };

  /**
   * Section findFirstOrThrow
   */
  export type SectionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null;
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sections to fetch.
     */
    orderBy?:
      | SectionOrderByWithRelationInput
      | SectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[];
  };

  /**
   * Section findMany
   */
  export type SectionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null;
    /**
     * Filter, which Sections to fetch.
     */
    where?: SectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sections to fetch.
     */
    orderBy?:
      | SectionOrderByWithRelationInput
      | SectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Sections.
     */
    cursor?: SectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sections.
     */
    skip?: number;
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[];
  };

  /**
   * Section create
   */
  export type SectionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Section.
     */
    data: XOR<SectionCreateInput, SectionUncheckedCreateInput>;
  };

  /**
   * Section createMany
   */
  export type SectionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Section update
   */
  export type SectionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Section.
     */
    data: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>;
    /**
     * Choose, which Section to update.
     */
    where: SectionWhereUniqueInput;
  };

  /**
   * Section updateMany
   */
  export type SectionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Sections.
     */
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>;
    /**
     * Filter which Sections to update
     */
    where?: SectionWhereInput;
    /**
     * Limit how many Sections to update.
     */
    limit?: number;
  };

  /**
   * Section upsert
   */
  export type SectionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Section to update in case it exists.
     */
    where: SectionWhereUniqueInput;
    /**
     * In case the Section found by the `where` argument doesn't exist, create a new Section with this data.
     */
    create: XOR<SectionCreateInput, SectionUncheckedCreateInput>;
    /**
     * In case the Section was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>;
  };

  /**
   * Section delete
   */
  export type SectionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null;
    /**
     * Filter which Section to delete.
     */
    where: SectionWhereUniqueInput;
  };

  /**
   * Section deleteMany
   */
  export type SectionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Sections to delete
     */
    where?: SectionWhereInput;
    /**
     * Limit how many Sections to delete.
     */
    limit?: number;
  };

  /**
   * Section.Lecture
   */
  export type Section$LectureArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    where?: LectureWhereInput;
    orderBy?:
      | LectureOrderByWithRelationInput
      | LectureOrderByWithRelationInput[];
    cursor?: LectureWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[];
  };

  /**
   * Section without action
   */
  export type SectionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null;
  };

  /**
   * Model StudyRemind
   */

  export type AggregateStudyRemind = {
    _count: StudyRemindCountAggregateOutputType | null;
    _avg: StudyRemindAvgAggregateOutputType | null;
    _sum: StudyRemindSumAggregateOutputType | null;
    _min: StudyRemindMinAggregateOutputType | null;
    _max: StudyRemindMaxAggregateOutputType | null;
  };

  export type StudyRemindAvgAggregateOutputType = {
    idStudyRemind: number | null;
    idUser: number | null;
    idCourse: number | null;
  };

  export type StudyRemindSumAggregateOutputType = {
    idStudyRemind: number | null;
    idUser: number | null;
    idCourse: number | null;
  };

  export type StudyRemindMinAggregateOutputType = {
    idStudyRemind: number | null;
    idUser: number | null;
    idCourse: number | null;
    timeRemind: Date | null;
    typeRemind: string | null;
  };

  export type StudyRemindMaxAggregateOutputType = {
    idStudyRemind: number | null;
    idUser: number | null;
    idCourse: number | null;
    timeRemind: Date | null;
    typeRemind: string | null;
  };

  export type StudyRemindCountAggregateOutputType = {
    idStudyRemind: number;
    idUser: number;
    idCourse: number;
    timeRemind: number;
    typeRemind: number;
    _all: number;
  };

  export type StudyRemindAvgAggregateInputType = {
    idStudyRemind?: true;
    idUser?: true;
    idCourse?: true;
  };

  export type StudyRemindSumAggregateInputType = {
    idStudyRemind?: true;
    idUser?: true;
    idCourse?: true;
  };

  export type StudyRemindMinAggregateInputType = {
    idStudyRemind?: true;
    idUser?: true;
    idCourse?: true;
    timeRemind?: true;
    typeRemind?: true;
  };

  export type StudyRemindMaxAggregateInputType = {
    idStudyRemind?: true;
    idUser?: true;
    idCourse?: true;
    timeRemind?: true;
    typeRemind?: true;
  };

  export type StudyRemindCountAggregateInputType = {
    idStudyRemind?: true;
    idUser?: true;
    idCourse?: true;
    timeRemind?: true;
    typeRemind?: true;
    _all?: true;
  };

  export type StudyRemindAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which StudyRemind to aggregate.
     */
    where?: StudyRemindWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StudyReminds to fetch.
     */
    orderBy?:
      | StudyRemindOrderByWithRelationInput
      | StudyRemindOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: StudyRemindWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StudyReminds from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StudyReminds.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned StudyReminds
     **/
    _count?: true | StudyRemindCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: StudyRemindAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: StudyRemindSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: StudyRemindMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: StudyRemindMaxAggregateInputType;
  };

  export type GetStudyRemindAggregateType<T extends StudyRemindAggregateArgs> =
    {
      [P in keyof T & keyof AggregateStudyRemind]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateStudyRemind[P]>
        : GetScalarType<T[P], AggregateStudyRemind[P]>;
    };

  export type StudyRemindGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: StudyRemindWhereInput;
    orderBy?:
      | StudyRemindOrderByWithAggregationInput
      | StudyRemindOrderByWithAggregationInput[];
    by: StudyRemindScalarFieldEnum[] | StudyRemindScalarFieldEnum;
    having?: StudyRemindScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: StudyRemindCountAggregateInputType | true;
    _avg?: StudyRemindAvgAggregateInputType;
    _sum?: StudyRemindSumAggregateInputType;
    _min?: StudyRemindMinAggregateInputType;
    _max?: StudyRemindMaxAggregateInputType;
  };

  export type StudyRemindGroupByOutputType = {
    idStudyRemind: number;
    idUser: number | null;
    idCourse: number | null;
    timeRemind: Date | null;
    typeRemind: string | null;
    _count: StudyRemindCountAggregateOutputType | null;
    _avg: StudyRemindAvgAggregateOutputType | null;
    _sum: StudyRemindSumAggregateOutputType | null;
    _min: StudyRemindMinAggregateOutputType | null;
    _max: StudyRemindMaxAggregateOutputType | null;
  };

  type GetStudyRemindGroupByPayload<T extends StudyRemindGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<StudyRemindGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof StudyRemindGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudyRemindGroupByOutputType[P]>
            : GetScalarType<T[P], StudyRemindGroupByOutputType[P]>;
        }
      >
    >;

  export type StudyRemindSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idStudyRemind?: boolean;
      idUser?: boolean;
      idCourse?: boolean;
      timeRemind?: boolean;
      typeRemind?: boolean;
      Course?: boolean | StudyRemind$CourseArgs<ExtArgs>;
      User?: boolean | StudyRemind$UserArgs<ExtArgs>;
    },
    ExtArgs['result']['studyRemind']
  >;

  export type StudyRemindSelectScalar = {
    idStudyRemind?: boolean;
    idUser?: boolean;
    idCourse?: boolean;
    timeRemind?: boolean;
    typeRemind?: boolean;
  };

  export type StudyRemindOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idStudyRemind' | 'idUser' | 'idCourse' | 'timeRemind' | 'typeRemind',
    ExtArgs['result']['studyRemind']
  >;
  export type StudyRemindInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Course?: boolean | StudyRemind$CourseArgs<ExtArgs>;
    User?: boolean | StudyRemind$UserArgs<ExtArgs>;
  };

  export type $StudyRemindPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'StudyRemind';
    objects: {
      Course: Prisma.$CoursePayload<ExtArgs> | null;
      User: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idStudyRemind: number;
        idUser: number | null;
        idCourse: number | null;
        timeRemind: Date | null;
        typeRemind: string | null;
      },
      ExtArgs['result']['studyRemind']
    >;
    composites: {};
  };

  type StudyRemindGetPayload<
    S extends boolean | null | undefined | StudyRemindDefaultArgs
  > = $Result.GetResult<Prisma.$StudyRemindPayload, S>;

  type StudyRemindCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    StudyRemindFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: StudyRemindCountAggregateInputType | true;
  };

  export interface StudyRemindDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['StudyRemind'];
      meta: { name: 'StudyRemind' };
    };
    /**
     * Find zero or one StudyRemind that matches the filter.
     * @param {StudyRemindFindUniqueArgs} args - Arguments to find a StudyRemind
     * @example
     * // Get one StudyRemind
     * const studyRemind = await prisma.studyRemind.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudyRemindFindUniqueArgs>(
      args: SelectSubset<T, StudyRemindFindUniqueArgs<ExtArgs>>
    ): Prisma__StudyRemindClient<
      $Result.GetResult<
        Prisma.$StudyRemindPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one StudyRemind that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudyRemindFindUniqueOrThrowArgs} args - Arguments to find a StudyRemind
     * @example
     * // Get one StudyRemind
     * const studyRemind = await prisma.studyRemind.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudyRemindFindUniqueOrThrowArgs>(
      args: SelectSubset<T, StudyRemindFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StudyRemindClient<
      $Result.GetResult<
        Prisma.$StudyRemindPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first StudyRemind that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRemindFindFirstArgs} args - Arguments to find a StudyRemind
     * @example
     * // Get one StudyRemind
     * const studyRemind = await prisma.studyRemind.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudyRemindFindFirstArgs>(
      args?: SelectSubset<T, StudyRemindFindFirstArgs<ExtArgs>>
    ): Prisma__StudyRemindClient<
      $Result.GetResult<
        Prisma.$StudyRemindPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first StudyRemind that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRemindFindFirstOrThrowArgs} args - Arguments to find a StudyRemind
     * @example
     * // Get one StudyRemind
     * const studyRemind = await prisma.studyRemind.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudyRemindFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StudyRemindFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StudyRemindClient<
      $Result.GetResult<
        Prisma.$StudyRemindPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more StudyReminds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRemindFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudyReminds
     * const studyReminds = await prisma.studyRemind.findMany()
     *
     * // Get first 10 StudyReminds
     * const studyReminds = await prisma.studyRemind.findMany({ take: 10 })
     *
     * // Only select the `idStudyRemind`
     * const studyRemindWithIdStudyRemindOnly = await prisma.studyRemind.findMany({ select: { idStudyRemind: true } })
     *
     */
    findMany<T extends StudyRemindFindManyArgs>(
      args?: SelectSubset<T, StudyRemindFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$StudyRemindPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a StudyRemind.
     * @param {StudyRemindCreateArgs} args - Arguments to create a StudyRemind.
     * @example
     * // Create one StudyRemind
     * const StudyRemind = await prisma.studyRemind.create({
     *   data: {
     *     // ... data to create a StudyRemind
     *   }
     * })
     *
     */
    create<T extends StudyRemindCreateArgs>(
      args: SelectSubset<T, StudyRemindCreateArgs<ExtArgs>>
    ): Prisma__StudyRemindClient<
      $Result.GetResult<
        Prisma.$StudyRemindPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many StudyReminds.
     * @param {StudyRemindCreateManyArgs} args - Arguments to create many StudyReminds.
     * @example
     * // Create many StudyReminds
     * const studyRemind = await prisma.studyRemind.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends StudyRemindCreateManyArgs>(
      args?: SelectSubset<T, StudyRemindCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a StudyRemind.
     * @param {StudyRemindDeleteArgs} args - Arguments to delete one StudyRemind.
     * @example
     * // Delete one StudyRemind
     * const StudyRemind = await prisma.studyRemind.delete({
     *   where: {
     *     // ... filter to delete one StudyRemind
     *   }
     * })
     *
     */
    delete<T extends StudyRemindDeleteArgs>(
      args: SelectSubset<T, StudyRemindDeleteArgs<ExtArgs>>
    ): Prisma__StudyRemindClient<
      $Result.GetResult<
        Prisma.$StudyRemindPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one StudyRemind.
     * @param {StudyRemindUpdateArgs} args - Arguments to update one StudyRemind.
     * @example
     * // Update one StudyRemind
     * const studyRemind = await prisma.studyRemind.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends StudyRemindUpdateArgs>(
      args: SelectSubset<T, StudyRemindUpdateArgs<ExtArgs>>
    ): Prisma__StudyRemindClient<
      $Result.GetResult<
        Prisma.$StudyRemindPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more StudyReminds.
     * @param {StudyRemindDeleteManyArgs} args - Arguments to filter StudyReminds to delete.
     * @example
     * // Delete a few StudyReminds
     * const { count } = await prisma.studyRemind.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends StudyRemindDeleteManyArgs>(
      args?: SelectSubset<T, StudyRemindDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more StudyReminds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRemindUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudyReminds
     * const studyRemind = await prisma.studyRemind.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends StudyRemindUpdateManyArgs>(
      args: SelectSubset<T, StudyRemindUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one StudyRemind.
     * @param {StudyRemindUpsertArgs} args - Arguments to update or create a StudyRemind.
     * @example
     * // Update or create a StudyRemind
     * const studyRemind = await prisma.studyRemind.upsert({
     *   create: {
     *     // ... data to create a StudyRemind
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudyRemind we want to update
     *   }
     * })
     */
    upsert<T extends StudyRemindUpsertArgs>(
      args: SelectSubset<T, StudyRemindUpsertArgs<ExtArgs>>
    ): Prisma__StudyRemindClient<
      $Result.GetResult<
        Prisma.$StudyRemindPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of StudyReminds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRemindCountArgs} args - Arguments to filter StudyReminds to count.
     * @example
     * // Count the number of StudyReminds
     * const count = await prisma.studyRemind.count({
     *   where: {
     *     // ... the filter for the StudyReminds we want to count
     *   }
     * })
     **/
    count<T extends StudyRemindCountArgs>(
      args?: Subset<T, StudyRemindCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudyRemindCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a StudyRemind.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRemindAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends StudyRemindAggregateArgs>(
      args: Subset<T, StudyRemindAggregateArgs>
    ): Prisma.PrismaPromise<GetStudyRemindAggregateType<T>>;

    /**
     * Group by StudyRemind.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRemindGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends StudyRemindGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudyRemindGroupByArgs['orderBy'] }
        : { orderBy?: StudyRemindGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, StudyRemindGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetStudyRemindGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the StudyRemind model
     */
    readonly fields: StudyRemindFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudyRemind.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudyRemindClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Course<T extends StudyRemind$CourseArgs<ExtArgs> = {}>(
      args?: Subset<T, StudyRemind$CourseArgs<ExtArgs>>
    ): Prisma__CourseClient<
      $Result.GetResult<
        Prisma.$CoursePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    User<T extends StudyRemind$UserArgs<ExtArgs> = {}>(
      args?: Subset<T, StudyRemind$UserArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the StudyRemind model
   */
  interface StudyRemindFieldRefs {
    readonly idStudyRemind: FieldRef<'StudyRemind', 'Int'>;
    readonly idUser: FieldRef<'StudyRemind', 'Int'>;
    readonly idCourse: FieldRef<'StudyRemind', 'Int'>;
    readonly timeRemind: FieldRef<'StudyRemind', 'DateTime'>;
    readonly typeRemind: FieldRef<'StudyRemind', 'String'>;
  }

  // Custom InputTypes
  /**
   * StudyRemind findUnique
   */
  export type StudyRemindFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the StudyRemind
     */
    select?: StudyRemindSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudyRemind
     */
    omit?: StudyRemindOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRemindInclude<ExtArgs> | null;
    /**
     * Filter, which StudyRemind to fetch.
     */
    where: StudyRemindWhereUniqueInput;
  };

  /**
   * StudyRemind findUniqueOrThrow
   */
  export type StudyRemindFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the StudyRemind
     */
    select?: StudyRemindSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudyRemind
     */
    omit?: StudyRemindOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRemindInclude<ExtArgs> | null;
    /**
     * Filter, which StudyRemind to fetch.
     */
    where: StudyRemindWhereUniqueInput;
  };

  /**
   * StudyRemind findFirst
   */
  export type StudyRemindFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the StudyRemind
     */
    select?: StudyRemindSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudyRemind
     */
    omit?: StudyRemindOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRemindInclude<ExtArgs> | null;
    /**
     * Filter, which StudyRemind to fetch.
     */
    where?: StudyRemindWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StudyReminds to fetch.
     */
    orderBy?:
      | StudyRemindOrderByWithRelationInput
      | StudyRemindOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for StudyReminds.
     */
    cursor?: StudyRemindWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StudyReminds from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StudyReminds.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of StudyReminds.
     */
    distinct?: StudyRemindScalarFieldEnum | StudyRemindScalarFieldEnum[];
  };

  /**
   * StudyRemind findFirstOrThrow
   */
  export type StudyRemindFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the StudyRemind
     */
    select?: StudyRemindSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudyRemind
     */
    omit?: StudyRemindOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRemindInclude<ExtArgs> | null;
    /**
     * Filter, which StudyRemind to fetch.
     */
    where?: StudyRemindWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StudyReminds to fetch.
     */
    orderBy?:
      | StudyRemindOrderByWithRelationInput
      | StudyRemindOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for StudyReminds.
     */
    cursor?: StudyRemindWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StudyReminds from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StudyReminds.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of StudyReminds.
     */
    distinct?: StudyRemindScalarFieldEnum | StudyRemindScalarFieldEnum[];
  };

  /**
   * StudyRemind findMany
   */
  export type StudyRemindFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the StudyRemind
     */
    select?: StudyRemindSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudyRemind
     */
    omit?: StudyRemindOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRemindInclude<ExtArgs> | null;
    /**
     * Filter, which StudyReminds to fetch.
     */
    where?: StudyRemindWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StudyReminds to fetch.
     */
    orderBy?:
      | StudyRemindOrderByWithRelationInput
      | StudyRemindOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing StudyReminds.
     */
    cursor?: StudyRemindWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StudyReminds from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StudyReminds.
     */
    skip?: number;
    distinct?: StudyRemindScalarFieldEnum | StudyRemindScalarFieldEnum[];
  };

  /**
   * StudyRemind create
   */
  export type StudyRemindCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the StudyRemind
     */
    select?: StudyRemindSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudyRemind
     */
    omit?: StudyRemindOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRemindInclude<ExtArgs> | null;
    /**
     * The data needed to create a StudyRemind.
     */
    data?: XOR<StudyRemindCreateInput, StudyRemindUncheckedCreateInput>;
  };

  /**
   * StudyRemind createMany
   */
  export type StudyRemindCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many StudyReminds.
     */
    data: StudyRemindCreateManyInput | StudyRemindCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * StudyRemind update
   */
  export type StudyRemindUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the StudyRemind
     */
    select?: StudyRemindSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudyRemind
     */
    omit?: StudyRemindOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRemindInclude<ExtArgs> | null;
    /**
     * The data needed to update a StudyRemind.
     */
    data: XOR<StudyRemindUpdateInput, StudyRemindUncheckedUpdateInput>;
    /**
     * Choose, which StudyRemind to update.
     */
    where: StudyRemindWhereUniqueInput;
  };

  /**
   * StudyRemind updateMany
   */
  export type StudyRemindUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update StudyReminds.
     */
    data: XOR<
      StudyRemindUpdateManyMutationInput,
      StudyRemindUncheckedUpdateManyInput
    >;
    /**
     * Filter which StudyReminds to update
     */
    where?: StudyRemindWhereInput;
    /**
     * Limit how many StudyReminds to update.
     */
    limit?: number;
  };

  /**
   * StudyRemind upsert
   */
  export type StudyRemindUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the StudyRemind
     */
    select?: StudyRemindSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudyRemind
     */
    omit?: StudyRemindOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRemindInclude<ExtArgs> | null;
    /**
     * The filter to search for the StudyRemind to update in case it exists.
     */
    where: StudyRemindWhereUniqueInput;
    /**
     * In case the StudyRemind found by the `where` argument doesn't exist, create a new StudyRemind with this data.
     */
    create: XOR<StudyRemindCreateInput, StudyRemindUncheckedCreateInput>;
    /**
     * In case the StudyRemind was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudyRemindUpdateInput, StudyRemindUncheckedUpdateInput>;
  };

  /**
   * StudyRemind delete
   */
  export type StudyRemindDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the StudyRemind
     */
    select?: StudyRemindSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudyRemind
     */
    omit?: StudyRemindOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRemindInclude<ExtArgs> | null;
    /**
     * Filter which StudyRemind to delete.
     */
    where: StudyRemindWhereUniqueInput;
  };

  /**
   * StudyRemind deleteMany
   */
  export type StudyRemindDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which StudyReminds to delete
     */
    where?: StudyRemindWhereInput;
    /**
     * Limit how many StudyReminds to delete.
     */
    limit?: number;
  };

  /**
   * StudyRemind.Course
   */
  export type StudyRemind$CourseArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null;
    where?: CourseWhereInput;
  };

  /**
   * StudyRemind.User
   */
  export type StudyRemind$UserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * StudyRemind without action
   */
  export type StudyRemindDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the StudyRemind
     */
    select?: StudyRemindSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudyRemind
     */
    omit?: StudyRemindOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRemindInclude<ExtArgs> | null;
  };

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _avg: UserAvgAggregateOutputType | null;
    _sum: UserSumAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserAvgAggregateOutputType = {
    idUser: number | null;
  };

  export type UserSumAggregateOutputType = {
    idUser: number | null;
  };

  export type UserMinAggregateOutputType = {
    idUser: number | null;
    name: string | null;
    biography: string | null;
    role: string | null;
    gender: string | null;
    birthday: Date | null;
    codeExpired: string | null;
    codeId: string | null;
    email: string | null;
    password: string | null;
  };

  export type UserMaxAggregateOutputType = {
    idUser: number | null;
    name: string | null;
    biography: string | null;
    role: string | null;
    gender: string | null;
    birthday: Date | null;
    codeExpired: string | null;
    codeId: string | null;
    email: string | null;
    password: string | null;
  };

  export type UserCountAggregateOutputType = {
    idUser: number;
    name: number;
    biography: number;
    role: number;
    gender: number;
    birthday: number;
    codeExpired: number;
    codeId: number;
    email: number;
    password: number;
    _all: number;
  };

  export type UserAvgAggregateInputType = {
    idUser?: true;
  };

  export type UserSumAggregateInputType = {
    idUser?: true;
  };

  export type UserMinAggregateInputType = {
    idUser?: true;
    name?: true;
    biography?: true;
    role?: true;
    gender?: true;
    birthday?: true;
    codeExpired?: true;
    codeId?: true;
    email?: true;
    password?: true;
  };

  export type UserMaxAggregateInputType = {
    idUser?: true;
    name?: true;
    biography?: true;
    role?: true;
    gender?: true;
    birthday?: true;
    codeExpired?: true;
    codeId?: true;
    email?: true;
    password?: true;
  };

  export type UserCountAggregateInputType = {
    idUser?: true;
    name?: true;
    biography?: true;
    role?: true;
    gender?: true;
    birthday?: true;
    codeExpired?: true;
    codeId?: true;
    email?: true;
    password?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: UserAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: UserSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: UserWhereInput;
    orderBy?:
      | UserOrderByWithAggregationInput
      | UserOrderByWithAggregationInput[];
    by: UserScalarFieldEnum[] | UserScalarFieldEnum;
    having?: UserScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserCountAggregateInputType | true;
    _avg?: UserAvgAggregateInputType;
    _sum?: UserSumAggregateInputType;
    _min?: UserMinAggregateInputType;
    _max?: UserMaxAggregateInputType;
  };

  export type UserGroupByOutputType = {
    idUser: number;
    name: string | null;
    biography: string | null;
    role: string | null;
    gender: string | null;
    birthday: Date | null;
    codeExpired: string | null;
    codeId: string | null;
    email: string | null;
    password: string | null;
    _count: UserCountAggregateOutputType | null;
    _avg: UserAvgAggregateOutputType | null;
    _sum: UserSumAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idUser?: boolean;
      name?: boolean;
      biography?: boolean;
      role?: boolean;
      gender?: boolean;
      birthday?: boolean;
      codeExpired?: boolean;
      codeId?: boolean;
      email?: boolean;
      password?: boolean;
      Answer?: boolean | User$AnswerArgs<ExtArgs>;
      Cart?: boolean | User$CartArgs<ExtArgs>;
      Coupon?: boolean | User$CouponArgs<ExtArgs>;
      Course?: boolean | User$CourseArgs<ExtArgs>;
      Enrollment?: boolean | User$EnrollmentArgs<ExtArgs>;
      Follow_Follow_idFollowerToUser?:
        | boolean
        | User$Follow_Follow_idFollowerToUserArgs<ExtArgs>;
      Follow_Follow_idFollowingToUser?:
        | boolean
        | User$Follow_Follow_idFollowingToUserArgs<ExtArgs>;
      Message_Message_idUserReceiverToUser?:
        | boolean
        | User$Message_Message_idUserReceiverToUserArgs<ExtArgs>;
      Message_Message_idUserSenderToUser?:
        | boolean
        | User$Message_Message_idUserSenderToUserArgs<ExtArgs>;
      Note?: boolean | User$NoteArgs<ExtArgs>;
      Notification?: boolean | User$NotificationArgs<ExtArgs>;
      NotificationReceiver?: boolean | User$NotificationReceiverArgs<ExtArgs>;
      Payment?: boolean | User$PaymentArgs<ExtArgs>;
      Question?: boolean | User$QuestionArgs<ExtArgs>;
      Report?: boolean | User$ReportArgs<ExtArgs>;
      Review?: boolean | User$ReviewArgs<ExtArgs>;
      StudyRemind?: boolean | User$StudyRemindArgs<ExtArgs>;
      UserCertificate?: boolean | User$UserCertificateArgs<ExtArgs>;
      UserCoupon?: boolean | User$UserCouponArgs<ExtArgs>;
      Wishlist?: boolean | User$WishlistArgs<ExtArgs>;
      _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectScalar = {
    idUser?: boolean;
    name?: boolean;
    biography?: boolean;
    role?: boolean;
    gender?: boolean;
    birthday?: boolean;
    codeExpired?: boolean;
    codeId?: boolean;
    email?: boolean;
    password?: boolean;
  };

  export type UserOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'idUser'
    | 'name'
    | 'biography'
    | 'role'
    | 'gender'
    | 'birthday'
    | 'codeExpired'
    | 'codeId'
    | 'email'
    | 'password',
    ExtArgs['result']['user']
  >;
  export type UserInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Answer?: boolean | User$AnswerArgs<ExtArgs>;
    Cart?: boolean | User$CartArgs<ExtArgs>;
    Coupon?: boolean | User$CouponArgs<ExtArgs>;
    Course?: boolean | User$CourseArgs<ExtArgs>;
    Enrollment?: boolean | User$EnrollmentArgs<ExtArgs>;
    Follow_Follow_idFollowerToUser?:
      | boolean
      | User$Follow_Follow_idFollowerToUserArgs<ExtArgs>;
    Follow_Follow_idFollowingToUser?:
      | boolean
      | User$Follow_Follow_idFollowingToUserArgs<ExtArgs>;
    Message_Message_idUserReceiverToUser?:
      | boolean
      | User$Message_Message_idUserReceiverToUserArgs<ExtArgs>;
    Message_Message_idUserSenderToUser?:
      | boolean
      | User$Message_Message_idUserSenderToUserArgs<ExtArgs>;
    Note?: boolean | User$NoteArgs<ExtArgs>;
    Notification?: boolean | User$NotificationArgs<ExtArgs>;
    NotificationReceiver?: boolean | User$NotificationReceiverArgs<ExtArgs>;
    Payment?: boolean | User$PaymentArgs<ExtArgs>;
    Question?: boolean | User$QuestionArgs<ExtArgs>;
    Report?: boolean | User$ReportArgs<ExtArgs>;
    Review?: boolean | User$ReviewArgs<ExtArgs>;
    StudyRemind?: boolean | User$StudyRemindArgs<ExtArgs>;
    UserCertificate?: boolean | User$UserCertificateArgs<ExtArgs>;
    UserCoupon?: boolean | User$UserCouponArgs<ExtArgs>;
    Wishlist?: boolean | User$WishlistArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $UserPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'User';
    objects: {
      Answer: Prisma.$AnswerPayload<ExtArgs>[];
      Cart: Prisma.$CartPayload<ExtArgs>[];
      Coupon: Prisma.$CouponPayload<ExtArgs>[];
      Course: Prisma.$CoursePayload<ExtArgs>[];
      Enrollment: Prisma.$EnrollmentPayload<ExtArgs>[];
      Follow_Follow_idFollowerToUser: Prisma.$FollowPayload<ExtArgs>[];
      Follow_Follow_idFollowingToUser: Prisma.$FollowPayload<ExtArgs>[];
      Message_Message_idUserReceiverToUser: Prisma.$MessagePayload<ExtArgs>[];
      Message_Message_idUserSenderToUser: Prisma.$MessagePayload<ExtArgs>[];
      Note: Prisma.$NotePayload<ExtArgs>[];
      Notification: Prisma.$NotificationPayload<ExtArgs>[];
      NotificationReceiver: Prisma.$NotificationReceiverPayload<ExtArgs>[];
      Payment: Prisma.$PaymentPayload<ExtArgs>[];
      Question: Prisma.$QuestionPayload<ExtArgs>[];
      Report: Prisma.$ReportPayload<ExtArgs>[];
      Review: Prisma.$ReviewPayload<ExtArgs>[];
      StudyRemind: Prisma.$StudyRemindPayload<ExtArgs>[];
      UserCertificate: Prisma.$UserCertificatePayload<ExtArgs>[];
      UserCoupon: Prisma.$UserCouponPayload<ExtArgs>[];
      Wishlist: Prisma.$WishlistPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idUser: number;
        name: string | null;
        biography: string | null;
        role: string | null;
        gender: string | null;
        birthday: Date | null;
        codeExpired: string | null;
        codeId: string | null;
        email: string | null;
        password: string | null;
      },
      ExtArgs['result']['user']
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> =
    $Result.GetResult<Prisma.$UserPayload, S>;

  type UserCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['User'];
      meta: { name: 'User' };
    };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `idUser`
     * const userWithIdUserOnly = await prisma.user.findMany({ select: { idUser: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetUserGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Answer<T extends User$AnswerArgs<ExtArgs> = {}>(
      args?: Subset<T, User$AnswerArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AnswerPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Cart<T extends User$CartArgs<ExtArgs> = {}>(
      args?: Subset<T, User$CartArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CartPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Coupon<T extends User$CouponArgs<ExtArgs> = {}>(
      args?: Subset<T, User$CouponArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CouponPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Course<T extends User$CourseArgs<ExtArgs> = {}>(
      args?: Subset<T, User$CourseArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CoursePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Enrollment<T extends User$EnrollmentArgs<ExtArgs> = {}>(
      args?: Subset<T, User$EnrollmentArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$EnrollmentPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Follow_Follow_idFollowerToUser<
      T extends User$Follow_Follow_idFollowerToUserArgs<ExtArgs> = {}
    >(
      args?: Subset<T, User$Follow_Follow_idFollowerToUserArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FollowPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Follow_Follow_idFollowingToUser<
      T extends User$Follow_Follow_idFollowingToUserArgs<ExtArgs> = {}
    >(
      args?: Subset<T, User$Follow_Follow_idFollowingToUserArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FollowPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Message_Message_idUserReceiverToUser<
      T extends User$Message_Message_idUserReceiverToUserArgs<ExtArgs> = {}
    >(
      args?: Subset<T, User$Message_Message_idUserReceiverToUserArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$MessagePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Message_Message_idUserSenderToUser<
      T extends User$Message_Message_idUserSenderToUserArgs<ExtArgs> = {}
    >(
      args?: Subset<T, User$Message_Message_idUserSenderToUserArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$MessagePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Note<T extends User$NoteArgs<ExtArgs> = {}>(
      args?: Subset<T, User$NoteArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$NotePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Notification<T extends User$NotificationArgs<ExtArgs> = {}>(
      args?: Subset<T, User$NotificationArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$NotificationPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    NotificationReceiver<T extends User$NotificationReceiverArgs<ExtArgs> = {}>(
      args?: Subset<T, User$NotificationReceiverArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$NotificationReceiverPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Payment<T extends User$PaymentArgs<ExtArgs> = {}>(
      args?: Subset<T, User$PaymentArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PaymentPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Question<T extends User$QuestionArgs<ExtArgs> = {}>(
      args?: Subset<T, User$QuestionArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$QuestionPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Report<T extends User$ReportArgs<ExtArgs> = {}>(
      args?: Subset<T, User$ReportArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ReportPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Review<T extends User$ReviewArgs<ExtArgs> = {}>(
      args?: Subset<T, User$ReviewArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ReviewPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    StudyRemind<T extends User$StudyRemindArgs<ExtArgs> = {}>(
      args?: Subset<T, User$StudyRemindArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$StudyRemindPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    UserCertificate<T extends User$UserCertificateArgs<ExtArgs> = {}>(
      args?: Subset<T, User$UserCertificateArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UserCertificatePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    UserCoupon<T extends User$UserCouponArgs<ExtArgs> = {}>(
      args?: Subset<T, User$UserCouponArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UserCouponPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    Wishlist<T extends User$WishlistArgs<ExtArgs> = {}>(
      args?: Subset<T, User$WishlistArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$WishlistPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly idUser: FieldRef<'User', 'Int'>;
    readonly name: FieldRef<'User', 'String'>;
    readonly biography: FieldRef<'User', 'String'>;
    readonly role: FieldRef<'User', 'String'>;
    readonly gender: FieldRef<'User', 'String'>;
    readonly birthday: FieldRef<'User', 'DateTime'>;
    readonly codeExpired: FieldRef<'User', 'String'>;
    readonly codeId: FieldRef<'User', 'String'>;
    readonly email: FieldRef<'User', 'String'>;
    readonly password: FieldRef<'User', 'String'>;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User create
   */
  export type UserCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User.Answer
   */
  export type User$AnswerArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null;
    where?: AnswerWhereInput;
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[];
    cursor?: AnswerWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[];
  };

  /**
   * User.Cart
   */
  export type User$CartArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    where?: CartWhereInput;
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[];
    cursor?: CartWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[];
  };

  /**
   * User.Coupon
   */
  export type User$CouponArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    where?: CouponWhereInput;
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[];
    cursor?: CouponWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[];
  };

  /**
   * User.Course
   */
  export type User$CourseArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null;
    where?: CourseWhereInput;
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[];
    cursor?: CourseWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[];
  };

  /**
   * User.Enrollment
   */
  export type User$EnrollmentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null;
    where?: EnrollmentWhereInput;
    orderBy?:
      | EnrollmentOrderByWithRelationInput
      | EnrollmentOrderByWithRelationInput[];
    cursor?: EnrollmentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[];
  };

  /**
   * User.Follow_Follow_idFollowerToUser
   */
  export type User$Follow_Follow_idFollowerToUserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null;
    where?: FollowWhereInput;
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[];
    cursor?: FollowWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[];
  };

  /**
   * User.Follow_Follow_idFollowingToUser
   */
  export type User$Follow_Follow_idFollowingToUserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null;
    where?: FollowWhereInput;
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[];
    cursor?: FollowWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[];
  };

  /**
   * User.Message_Message_idUserReceiverToUser
   */
  export type User$Message_Message_idUserReceiverToUserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    where?: MessageWhereInput;
    orderBy?:
      | MessageOrderByWithRelationInput
      | MessageOrderByWithRelationInput[];
    cursor?: MessageWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[];
  };

  /**
   * User.Message_Message_idUserSenderToUser
   */
  export type User$Message_Message_idUserSenderToUserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    where?: MessageWhereInput;
    orderBy?:
      | MessageOrderByWithRelationInput
      | MessageOrderByWithRelationInput[];
    cursor?: MessageWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[];
  };

  /**
   * User.Note
   */
  export type User$NoteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null;
    where?: NoteWhereInput;
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[];
    cursor?: NoteWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[];
  };

  /**
   * User.Notification
   */
  export type User$NotificationArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    where?: NotificationWhereInput;
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    cursor?: NotificationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * User.NotificationReceiver
   */
  export type User$NotificationReceiverArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the NotificationReceiver
     */
    select?: NotificationReceiverSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationReceiver
     */
    omit?: NotificationReceiverOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReceiverInclude<ExtArgs> | null;
    where?: NotificationReceiverWhereInput;
    orderBy?:
      | NotificationReceiverOrderByWithRelationInput
      | NotificationReceiverOrderByWithRelationInput[];
    cursor?: NotificationReceiverWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | NotificationReceiverScalarFieldEnum
      | NotificationReceiverScalarFieldEnum[];
  };

  /**
   * User.Payment
   */
  export type User$PaymentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    where?: PaymentWhereInput;
    orderBy?:
      | PaymentOrderByWithRelationInput
      | PaymentOrderByWithRelationInput[];
    cursor?: PaymentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
  };

  /**
   * User.Question
   */
  export type User$QuestionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null;
    where?: QuestionWhereInput;
    orderBy?:
      | QuestionOrderByWithRelationInput
      | QuestionOrderByWithRelationInput[];
    cursor?: QuestionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[];
  };

  /**
   * User.Report
   */
  export type User$ReportArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null;
    where?: ReportWhereInput;
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[];
    cursor?: ReportWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[];
  };

  /**
   * User.Review
   */
  export type User$ReviewArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    cursor?: ReviewWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * User.StudyRemind
   */
  export type User$StudyRemindArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the StudyRemind
     */
    select?: StudyRemindSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudyRemind
     */
    omit?: StudyRemindOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRemindInclude<ExtArgs> | null;
    where?: StudyRemindWhereInput;
    orderBy?:
      | StudyRemindOrderByWithRelationInput
      | StudyRemindOrderByWithRelationInput[];
    cursor?: StudyRemindWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: StudyRemindScalarFieldEnum | StudyRemindScalarFieldEnum[];
  };

  /**
   * User.UserCertificate
   */
  export type User$UserCertificateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCertificate
     */
    select?: UserCertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCertificate
     */
    omit?: UserCertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificateInclude<ExtArgs> | null;
    where?: UserCertificateWhereInput;
    orderBy?:
      | UserCertificateOrderByWithRelationInput
      | UserCertificateOrderByWithRelationInput[];
    cursor?: UserCertificateWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | UserCertificateScalarFieldEnum
      | UserCertificateScalarFieldEnum[];
  };

  /**
   * User.UserCoupon
   */
  export type User$UserCouponArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null;
    where?: UserCouponWhereInput;
    orderBy?:
      | UserCouponOrderByWithRelationInput
      | UserCouponOrderByWithRelationInput[];
    cursor?: UserCouponWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserCouponScalarFieldEnum | UserCouponScalarFieldEnum[];
  };

  /**
   * User.Wishlist
   */
  export type User$WishlistArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    where?: WishlistWhereInput;
    orderBy?:
      | WishlistOrderByWithRelationInput
      | WishlistOrderByWithRelationInput[];
    cursor?: WishlistWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
  };

  /**
   * Model UserCertificate
   */

  export type AggregateUserCertificate = {
    _count: UserCertificateCountAggregateOutputType | null;
    _avg: UserCertificateAvgAggregateOutputType | null;
    _sum: UserCertificateSumAggregateOutputType | null;
    _min: UserCertificateMinAggregateOutputType | null;
    _max: UserCertificateMaxAggregateOutputType | null;
  };

  export type UserCertificateAvgAggregateOutputType = {
    idCourse: number | null;
    idUser: number | null;
  };

  export type UserCertificateSumAggregateOutputType = {
    idCourse: number | null;
    idUser: number | null;
  };

  export type UserCertificateMinAggregateOutputType = {
    idCourse: number | null;
    idUser: number | null;
  };

  export type UserCertificateMaxAggregateOutputType = {
    idCourse: number | null;
    idUser: number | null;
  };

  export type UserCertificateCountAggregateOutputType = {
    idCourse: number;
    idUser: number;
    _all: number;
  };

  export type UserCertificateAvgAggregateInputType = {
    idCourse?: true;
    idUser?: true;
  };

  export type UserCertificateSumAggregateInputType = {
    idCourse?: true;
    idUser?: true;
  };

  export type UserCertificateMinAggregateInputType = {
    idCourse?: true;
    idUser?: true;
  };

  export type UserCertificateMaxAggregateInputType = {
    idCourse?: true;
    idUser?: true;
  };

  export type UserCertificateCountAggregateInputType = {
    idCourse?: true;
    idUser?: true;
    _all?: true;
  };

  export type UserCertificateAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which UserCertificate to aggregate.
     */
    where?: UserCertificateWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserCertificates to fetch.
     */
    orderBy?:
      | UserCertificateOrderByWithRelationInput
      | UserCertificateOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserCertificateWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserCertificates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserCertificates.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UserCertificates
     **/
    _count?: true | UserCertificateCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: UserCertificateAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: UserCertificateSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserCertificateMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserCertificateMaxAggregateInputType;
  };

  export type GetUserCertificateAggregateType<
    T extends UserCertificateAggregateArgs
  > = {
    [P in keyof T & keyof AggregateUserCertificate]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCertificate[P]>
      : GetScalarType<T[P], AggregateUserCertificate[P]>;
  };

  export type UserCertificateGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: UserCertificateWhereInput;
    orderBy?:
      | UserCertificateOrderByWithAggregationInput
      | UserCertificateOrderByWithAggregationInput[];
    by: UserCertificateScalarFieldEnum[] | UserCertificateScalarFieldEnum;
    having?: UserCertificateScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserCertificateCountAggregateInputType | true;
    _avg?: UserCertificateAvgAggregateInputType;
    _sum?: UserCertificateSumAggregateInputType;
    _min?: UserCertificateMinAggregateInputType;
    _max?: UserCertificateMaxAggregateInputType;
  };

  export type UserCertificateGroupByOutputType = {
    idCourse: number;
    idUser: number;
    _count: UserCertificateCountAggregateOutputType | null;
    _avg: UserCertificateAvgAggregateOutputType | null;
    _sum: UserCertificateSumAggregateOutputType | null;
    _min: UserCertificateMinAggregateOutputType | null;
    _max: UserCertificateMaxAggregateOutputType | null;
  };

  type GetUserCertificateGroupByPayload<T extends UserCertificateGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<UserCertificateGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof UserCertificateGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCertificateGroupByOutputType[P]>
            : GetScalarType<T[P], UserCertificateGroupByOutputType[P]>;
        }
      >
    >;

  export type UserCertificateSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idCourse?: boolean;
      idUser?: boolean;
      Certificate?: boolean | CertificateDefaultArgs<ExtArgs>;
      User?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userCertificate']
  >;

  export type UserCertificateSelectScalar = {
    idCourse?: boolean;
    idUser?: boolean;
  };

  export type UserCertificateOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idCourse' | 'idUser',
    ExtArgs['result']['userCertificate']
  >;
  export type UserCertificateInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Certificate?: boolean | CertificateDefaultArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $UserCertificatePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'UserCertificate';
    objects: {
      Certificate: Prisma.$CertificatePayload<ExtArgs>;
      User: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idCourse: number;
        idUser: number;
      },
      ExtArgs['result']['userCertificate']
    >;
    composites: {};
  };

  type UserCertificateGetPayload<
    S extends boolean | null | undefined | UserCertificateDefaultArgs
  > = $Result.GetResult<Prisma.$UserCertificatePayload, S>;

  type UserCertificateCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    UserCertificateFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: UserCertificateCountAggregateInputType | true;
  };

  export interface UserCertificateDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['UserCertificate'];
      meta: { name: 'UserCertificate' };
    };
    /**
     * Find zero or one UserCertificate that matches the filter.
     * @param {UserCertificateFindUniqueArgs} args - Arguments to find a UserCertificate
     * @example
     * // Get one UserCertificate
     * const userCertificate = await prisma.userCertificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCertificateFindUniqueArgs>(
      args: SelectSubset<T, UserCertificateFindUniqueArgs<ExtArgs>>
    ): Prisma__UserCertificateClient<
      $Result.GetResult<
        Prisma.$UserCertificatePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UserCertificate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCertificateFindUniqueOrThrowArgs} args - Arguments to find a UserCertificate
     * @example
     * // Get one UserCertificate
     * const userCertificate = await prisma.userCertificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCertificateFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserCertificateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserCertificateClient<
      $Result.GetResult<
        Prisma.$UserCertificatePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserCertificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCertificateFindFirstArgs} args - Arguments to find a UserCertificate
     * @example
     * // Get one UserCertificate
     * const userCertificate = await prisma.userCertificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCertificateFindFirstArgs>(
      args?: SelectSubset<T, UserCertificateFindFirstArgs<ExtArgs>>
    ): Prisma__UserCertificateClient<
      $Result.GetResult<
        Prisma.$UserCertificatePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserCertificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCertificateFindFirstOrThrowArgs} args - Arguments to find a UserCertificate
     * @example
     * // Get one UserCertificate
     * const userCertificate = await prisma.userCertificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCertificateFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserCertificateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserCertificateClient<
      $Result.GetResult<
        Prisma.$UserCertificatePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UserCertificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCertificates
     * const userCertificates = await prisma.userCertificate.findMany()
     *
     * // Get first 10 UserCertificates
     * const userCertificates = await prisma.userCertificate.findMany({ take: 10 })
     *
     * // Only select the `idCourse`
     * const userCertificateWithIdCourseOnly = await prisma.userCertificate.findMany({ select: { idCourse: true } })
     *
     */
    findMany<T extends UserCertificateFindManyArgs>(
      args?: SelectSubset<T, UserCertificateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserCertificatePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a UserCertificate.
     * @param {UserCertificateCreateArgs} args - Arguments to create a UserCertificate.
     * @example
     * // Create one UserCertificate
     * const UserCertificate = await prisma.userCertificate.create({
     *   data: {
     *     // ... data to create a UserCertificate
     *   }
     * })
     *
     */
    create<T extends UserCertificateCreateArgs>(
      args: SelectSubset<T, UserCertificateCreateArgs<ExtArgs>>
    ): Prisma__UserCertificateClient<
      $Result.GetResult<
        Prisma.$UserCertificatePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UserCertificates.
     * @param {UserCertificateCreateManyArgs} args - Arguments to create many UserCertificates.
     * @example
     * // Create many UserCertificates
     * const userCertificate = await prisma.userCertificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCertificateCreateManyArgs>(
      args?: SelectSubset<T, UserCertificateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a UserCertificate.
     * @param {UserCertificateDeleteArgs} args - Arguments to delete one UserCertificate.
     * @example
     * // Delete one UserCertificate
     * const UserCertificate = await prisma.userCertificate.delete({
     *   where: {
     *     // ... filter to delete one UserCertificate
     *   }
     * })
     *
     */
    delete<T extends UserCertificateDeleteArgs>(
      args: SelectSubset<T, UserCertificateDeleteArgs<ExtArgs>>
    ): Prisma__UserCertificateClient<
      $Result.GetResult<
        Prisma.$UserCertificatePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UserCertificate.
     * @param {UserCertificateUpdateArgs} args - Arguments to update one UserCertificate.
     * @example
     * // Update one UserCertificate
     * const userCertificate = await prisma.userCertificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserCertificateUpdateArgs>(
      args: SelectSubset<T, UserCertificateUpdateArgs<ExtArgs>>
    ): Prisma__UserCertificateClient<
      $Result.GetResult<
        Prisma.$UserCertificatePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UserCertificates.
     * @param {UserCertificateDeleteManyArgs} args - Arguments to filter UserCertificates to delete.
     * @example
     * // Delete a few UserCertificates
     * const { count } = await prisma.userCertificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserCertificateDeleteManyArgs>(
      args?: SelectSubset<T, UserCertificateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserCertificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCertificates
     * const userCertificate = await prisma.userCertificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserCertificateUpdateManyArgs>(
      args: SelectSubset<T, UserCertificateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one UserCertificate.
     * @param {UserCertificateUpsertArgs} args - Arguments to update or create a UserCertificate.
     * @example
     * // Update or create a UserCertificate
     * const userCertificate = await prisma.userCertificate.upsert({
     *   create: {
     *     // ... data to create a UserCertificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCertificate we want to update
     *   }
     * })
     */
    upsert<T extends UserCertificateUpsertArgs>(
      args: SelectSubset<T, UserCertificateUpsertArgs<ExtArgs>>
    ): Prisma__UserCertificateClient<
      $Result.GetResult<
        Prisma.$UserCertificatePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UserCertificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCertificateCountArgs} args - Arguments to filter UserCertificates to count.
     * @example
     * // Count the number of UserCertificates
     * const count = await prisma.userCertificate.count({
     *   where: {
     *     // ... the filter for the UserCertificates we want to count
     *   }
     * })
     **/
    count<T extends UserCertificateCountArgs>(
      args?: Subset<T, UserCertificateCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCertificateCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserCertificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserCertificateAggregateArgs>(
      args: Subset<T, UserCertificateAggregateArgs>
    ): Prisma.PrismaPromise<GetUserCertificateAggregateType<T>>;

    /**
     * Group by UserCertificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserCertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCertificateGroupByArgs['orderBy'] }
        : { orderBy?: UserCertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, UserCertificateGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetUserCertificateGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UserCertificate model
     */
    readonly fields: UserCertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCertificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCertificateClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Certificate<T extends CertificateDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CertificateDefaultArgs<ExtArgs>>
    ): Prisma__CertificateClient<
      | $Result.GetResult<
          Prisma.$CertificatePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    User<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the UserCertificate model
   */
  interface UserCertificateFieldRefs {
    readonly idCourse: FieldRef<'UserCertificate', 'Int'>;
    readonly idUser: FieldRef<'UserCertificate', 'Int'>;
  }

  // Custom InputTypes
  /**
   * UserCertificate findUnique
   */
  export type UserCertificateFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCertificate
     */
    select?: UserCertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCertificate
     */
    omit?: UserCertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificateInclude<ExtArgs> | null;
    /**
     * Filter, which UserCertificate to fetch.
     */
    where: UserCertificateWhereUniqueInput;
  };

  /**
   * UserCertificate findUniqueOrThrow
   */
  export type UserCertificateFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCertificate
     */
    select?: UserCertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCertificate
     */
    omit?: UserCertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificateInclude<ExtArgs> | null;
    /**
     * Filter, which UserCertificate to fetch.
     */
    where: UserCertificateWhereUniqueInput;
  };

  /**
   * UserCertificate findFirst
   */
  export type UserCertificateFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCertificate
     */
    select?: UserCertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCertificate
     */
    omit?: UserCertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificateInclude<ExtArgs> | null;
    /**
     * Filter, which UserCertificate to fetch.
     */
    where?: UserCertificateWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserCertificates to fetch.
     */
    orderBy?:
      | UserCertificateOrderByWithRelationInput
      | UserCertificateOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserCertificates.
     */
    cursor?: UserCertificateWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserCertificates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserCertificates.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserCertificates.
     */
    distinct?:
      | UserCertificateScalarFieldEnum
      | UserCertificateScalarFieldEnum[];
  };

  /**
   * UserCertificate findFirstOrThrow
   */
  export type UserCertificateFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCertificate
     */
    select?: UserCertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCertificate
     */
    omit?: UserCertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificateInclude<ExtArgs> | null;
    /**
     * Filter, which UserCertificate to fetch.
     */
    where?: UserCertificateWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserCertificates to fetch.
     */
    orderBy?:
      | UserCertificateOrderByWithRelationInput
      | UserCertificateOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserCertificates.
     */
    cursor?: UserCertificateWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserCertificates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserCertificates.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserCertificates.
     */
    distinct?:
      | UserCertificateScalarFieldEnum
      | UserCertificateScalarFieldEnum[];
  };

  /**
   * UserCertificate findMany
   */
  export type UserCertificateFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCertificate
     */
    select?: UserCertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCertificate
     */
    omit?: UserCertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificateInclude<ExtArgs> | null;
    /**
     * Filter, which UserCertificates to fetch.
     */
    where?: UserCertificateWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserCertificates to fetch.
     */
    orderBy?:
      | UserCertificateOrderByWithRelationInput
      | UserCertificateOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UserCertificates.
     */
    cursor?: UserCertificateWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserCertificates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserCertificates.
     */
    skip?: number;
    distinct?:
      | UserCertificateScalarFieldEnum
      | UserCertificateScalarFieldEnum[];
  };

  /**
   * UserCertificate create
   */
  export type UserCertificateCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCertificate
     */
    select?: UserCertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCertificate
     */
    omit?: UserCertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificateInclude<ExtArgs> | null;
    /**
     * The data needed to create a UserCertificate.
     */
    data: XOR<UserCertificateCreateInput, UserCertificateUncheckedCreateInput>;
  };

  /**
   * UserCertificate createMany
   */
  export type UserCertificateCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many UserCertificates.
     */
    data: UserCertificateCreateManyInput | UserCertificateCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserCertificate update
   */
  export type UserCertificateUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCertificate
     */
    select?: UserCertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCertificate
     */
    omit?: UserCertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificateInclude<ExtArgs> | null;
    /**
     * The data needed to update a UserCertificate.
     */
    data: XOR<UserCertificateUpdateInput, UserCertificateUncheckedUpdateInput>;
    /**
     * Choose, which UserCertificate to update.
     */
    where: UserCertificateWhereUniqueInput;
  };

  /**
   * UserCertificate updateMany
   */
  export type UserCertificateUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update UserCertificates.
     */
    data: XOR<
      UserCertificateUpdateManyMutationInput,
      UserCertificateUncheckedUpdateManyInput
    >;
    /**
     * Filter which UserCertificates to update
     */
    where?: UserCertificateWhereInput;
    /**
     * Limit how many UserCertificates to update.
     */
    limit?: number;
  };

  /**
   * UserCertificate upsert
   */
  export type UserCertificateUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCertificate
     */
    select?: UserCertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCertificate
     */
    omit?: UserCertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificateInclude<ExtArgs> | null;
    /**
     * The filter to search for the UserCertificate to update in case it exists.
     */
    where: UserCertificateWhereUniqueInput;
    /**
     * In case the UserCertificate found by the `where` argument doesn't exist, create a new UserCertificate with this data.
     */
    create: XOR<
      UserCertificateCreateInput,
      UserCertificateUncheckedCreateInput
    >;
    /**
     * In case the UserCertificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      UserCertificateUpdateInput,
      UserCertificateUncheckedUpdateInput
    >;
  };

  /**
   * UserCertificate delete
   */
  export type UserCertificateDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCertificate
     */
    select?: UserCertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCertificate
     */
    omit?: UserCertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificateInclude<ExtArgs> | null;
    /**
     * Filter which UserCertificate to delete.
     */
    where: UserCertificateWhereUniqueInput;
  };

  /**
   * UserCertificate deleteMany
   */
  export type UserCertificateDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which UserCertificates to delete
     */
    where?: UserCertificateWhereInput;
    /**
     * Limit how many UserCertificates to delete.
     */
    limit?: number;
  };

  /**
   * UserCertificate without action
   */
  export type UserCertificateDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCertificate
     */
    select?: UserCertificateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCertificate
     */
    omit?: UserCertificateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificateInclude<ExtArgs> | null;
  };

  /**
   * Model UserCoupon
   */

  export type AggregateUserCoupon = {
    _count: UserCouponCountAggregateOutputType | null;
    _avg: UserCouponAvgAggregateOutputType | null;
    _sum: UserCouponSumAggregateOutputType | null;
    _min: UserCouponMinAggregateOutputType | null;
    _max: UserCouponMaxAggregateOutputType | null;
  };

  export type UserCouponAvgAggregateOutputType = {
    idUser: number | null;
    idCoupon: number | null;
  };

  export type UserCouponSumAggregateOutputType = {
    idUser: number | null;
    idCoupon: number | null;
  };

  export type UserCouponMinAggregateOutputType = {
    idUser: number | null;
    idCoupon: number | null;
  };

  export type UserCouponMaxAggregateOutputType = {
    idUser: number | null;
    idCoupon: number | null;
  };

  export type UserCouponCountAggregateOutputType = {
    idUser: number;
    idCoupon: number;
    _all: number;
  };

  export type UserCouponAvgAggregateInputType = {
    idUser?: true;
    idCoupon?: true;
  };

  export type UserCouponSumAggregateInputType = {
    idUser?: true;
    idCoupon?: true;
  };

  export type UserCouponMinAggregateInputType = {
    idUser?: true;
    idCoupon?: true;
  };

  export type UserCouponMaxAggregateInputType = {
    idUser?: true;
    idCoupon?: true;
  };

  export type UserCouponCountAggregateInputType = {
    idUser?: true;
    idCoupon?: true;
    _all?: true;
  };

  export type UserCouponAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which UserCoupon to aggregate.
     */
    where?: UserCouponWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserCoupons to fetch.
     */
    orderBy?:
      | UserCouponOrderByWithRelationInput
      | UserCouponOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserCouponWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserCoupons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserCoupons.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UserCoupons
     **/
    _count?: true | UserCouponCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: UserCouponAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: UserCouponSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserCouponMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserCouponMaxAggregateInputType;
  };

  export type GetUserCouponAggregateType<T extends UserCouponAggregateArgs> = {
    [P in keyof T & keyof AggregateUserCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCoupon[P]>
      : GetScalarType<T[P], AggregateUserCoupon[P]>;
  };

  export type UserCouponGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: UserCouponWhereInput;
    orderBy?:
      | UserCouponOrderByWithAggregationInput
      | UserCouponOrderByWithAggregationInput[];
    by: UserCouponScalarFieldEnum[] | UserCouponScalarFieldEnum;
    having?: UserCouponScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserCouponCountAggregateInputType | true;
    _avg?: UserCouponAvgAggregateInputType;
    _sum?: UserCouponSumAggregateInputType;
    _min?: UserCouponMinAggregateInputType;
    _max?: UserCouponMaxAggregateInputType;
  };

  export type UserCouponGroupByOutputType = {
    idUser: number;
    idCoupon: number;
    _count: UserCouponCountAggregateOutputType | null;
    _avg: UserCouponAvgAggregateOutputType | null;
    _sum: UserCouponSumAggregateOutputType | null;
    _min: UserCouponMinAggregateOutputType | null;
    _max: UserCouponMaxAggregateOutputType | null;
  };

  type GetUserCouponGroupByPayload<T extends UserCouponGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<UserCouponGroupByOutputType, T['by']> & {
          [P in keyof T & keyof UserCouponGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCouponGroupByOutputType[P]>
            : GetScalarType<T[P], UserCouponGroupByOutputType[P]>;
        }
      >
    >;

  export type UserCouponSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idUser?: boolean;
      idCoupon?: boolean;
      Coupon?: boolean | CouponDefaultArgs<ExtArgs>;
      User?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userCoupon']
  >;

  export type UserCouponSelectScalar = {
    idUser?: boolean;
    idCoupon?: boolean;
  };

  export type UserCouponOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'idUser' | 'idCoupon',
    ExtArgs['result']['userCoupon']
  >;
  export type UserCouponInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Coupon?: boolean | CouponDefaultArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $UserCouponPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'UserCoupon';
    objects: {
      Coupon: Prisma.$CouponPayload<ExtArgs>;
      User: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idUser: number;
        idCoupon: number;
      },
      ExtArgs['result']['userCoupon']
    >;
    composites: {};
  };

  type UserCouponGetPayload<
    S extends boolean | null | undefined | UserCouponDefaultArgs
  > = $Result.GetResult<Prisma.$UserCouponPayload, S>;

  type UserCouponCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    UserCouponFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: UserCouponCountAggregateInputType | true;
  };

  export interface UserCouponDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['UserCoupon'];
      meta: { name: 'UserCoupon' };
    };
    /**
     * Find zero or one UserCoupon that matches the filter.
     * @param {UserCouponFindUniqueArgs} args - Arguments to find a UserCoupon
     * @example
     * // Get one UserCoupon
     * const userCoupon = await prisma.userCoupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCouponFindUniqueArgs>(
      args: SelectSubset<T, UserCouponFindUniqueArgs<ExtArgs>>
    ): Prisma__UserCouponClient<
      $Result.GetResult<
        Prisma.$UserCouponPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UserCoupon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCouponFindUniqueOrThrowArgs} args - Arguments to find a UserCoupon
     * @example
     * // Get one UserCoupon
     * const userCoupon = await prisma.userCoupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCouponFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserCouponFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserCouponClient<
      $Result.GetResult<
        Prisma.$UserCouponPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserCoupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponFindFirstArgs} args - Arguments to find a UserCoupon
     * @example
     * // Get one UserCoupon
     * const userCoupon = await prisma.userCoupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCouponFindFirstArgs>(
      args?: SelectSubset<T, UserCouponFindFirstArgs<ExtArgs>>
    ): Prisma__UserCouponClient<
      $Result.GetResult<
        Prisma.$UserCouponPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserCoupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponFindFirstOrThrowArgs} args - Arguments to find a UserCoupon
     * @example
     * // Get one UserCoupon
     * const userCoupon = await prisma.userCoupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCouponFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserCouponFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserCouponClient<
      $Result.GetResult<
        Prisma.$UserCouponPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UserCoupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCoupons
     * const userCoupons = await prisma.userCoupon.findMany()
     *
     * // Get first 10 UserCoupons
     * const userCoupons = await prisma.userCoupon.findMany({ take: 10 })
     *
     * // Only select the `idUser`
     * const userCouponWithIdUserOnly = await prisma.userCoupon.findMany({ select: { idUser: true } })
     *
     */
    findMany<T extends UserCouponFindManyArgs>(
      args?: SelectSubset<T, UserCouponFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserCouponPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a UserCoupon.
     * @param {UserCouponCreateArgs} args - Arguments to create a UserCoupon.
     * @example
     * // Create one UserCoupon
     * const UserCoupon = await prisma.userCoupon.create({
     *   data: {
     *     // ... data to create a UserCoupon
     *   }
     * })
     *
     */
    create<T extends UserCouponCreateArgs>(
      args: SelectSubset<T, UserCouponCreateArgs<ExtArgs>>
    ): Prisma__UserCouponClient<
      $Result.GetResult<
        Prisma.$UserCouponPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UserCoupons.
     * @param {UserCouponCreateManyArgs} args - Arguments to create many UserCoupons.
     * @example
     * // Create many UserCoupons
     * const userCoupon = await prisma.userCoupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCouponCreateManyArgs>(
      args?: SelectSubset<T, UserCouponCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a UserCoupon.
     * @param {UserCouponDeleteArgs} args - Arguments to delete one UserCoupon.
     * @example
     * // Delete one UserCoupon
     * const UserCoupon = await prisma.userCoupon.delete({
     *   where: {
     *     // ... filter to delete one UserCoupon
     *   }
     * })
     *
     */
    delete<T extends UserCouponDeleteArgs>(
      args: SelectSubset<T, UserCouponDeleteArgs<ExtArgs>>
    ): Prisma__UserCouponClient<
      $Result.GetResult<
        Prisma.$UserCouponPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UserCoupon.
     * @param {UserCouponUpdateArgs} args - Arguments to update one UserCoupon.
     * @example
     * // Update one UserCoupon
     * const userCoupon = await prisma.userCoupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserCouponUpdateArgs>(
      args: SelectSubset<T, UserCouponUpdateArgs<ExtArgs>>
    ): Prisma__UserCouponClient<
      $Result.GetResult<
        Prisma.$UserCouponPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UserCoupons.
     * @param {UserCouponDeleteManyArgs} args - Arguments to filter UserCoupons to delete.
     * @example
     * // Delete a few UserCoupons
     * const { count } = await prisma.userCoupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserCouponDeleteManyArgs>(
      args?: SelectSubset<T, UserCouponDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserCoupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCoupons
     * const userCoupon = await prisma.userCoupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserCouponUpdateManyArgs>(
      args: SelectSubset<T, UserCouponUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one UserCoupon.
     * @param {UserCouponUpsertArgs} args - Arguments to update or create a UserCoupon.
     * @example
     * // Update or create a UserCoupon
     * const userCoupon = await prisma.userCoupon.upsert({
     *   create: {
     *     // ... data to create a UserCoupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCoupon we want to update
     *   }
     * })
     */
    upsert<T extends UserCouponUpsertArgs>(
      args: SelectSubset<T, UserCouponUpsertArgs<ExtArgs>>
    ): Prisma__UserCouponClient<
      $Result.GetResult<
        Prisma.$UserCouponPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UserCoupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponCountArgs} args - Arguments to filter UserCoupons to count.
     * @example
     * // Count the number of UserCoupons
     * const count = await prisma.userCoupon.count({
     *   where: {
     *     // ... the filter for the UserCoupons we want to count
     *   }
     * })
     **/
    count<T extends UserCouponCountArgs>(
      args?: Subset<T, UserCouponCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCouponCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserCoupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserCouponAggregateArgs>(
      args: Subset<T, UserCouponAggregateArgs>
    ): Prisma.PrismaPromise<GetUserCouponAggregateType<T>>;

    /**
     * Group by UserCoupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserCouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCouponGroupByArgs['orderBy'] }
        : { orderBy?: UserCouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, UserCouponGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetUserCouponGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UserCoupon model
     */
    readonly fields: UserCouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCoupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCouponClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Coupon<T extends CouponDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CouponDefaultArgs<ExtArgs>>
    ): Prisma__CouponClient<
      | $Result.GetResult<
          Prisma.$CouponPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    User<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the UserCoupon model
   */
  interface UserCouponFieldRefs {
    readonly idUser: FieldRef<'UserCoupon', 'Int'>;
    readonly idCoupon: FieldRef<'UserCoupon', 'Int'>;
  }

  // Custom InputTypes
  /**
   * UserCoupon findUnique
   */
  export type UserCouponFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null;
    /**
     * Filter, which UserCoupon to fetch.
     */
    where: UserCouponWhereUniqueInput;
  };

  /**
   * UserCoupon findUniqueOrThrow
   */
  export type UserCouponFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null;
    /**
     * Filter, which UserCoupon to fetch.
     */
    where: UserCouponWhereUniqueInput;
  };

  /**
   * UserCoupon findFirst
   */
  export type UserCouponFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null;
    /**
     * Filter, which UserCoupon to fetch.
     */
    where?: UserCouponWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserCoupons to fetch.
     */
    orderBy?:
      | UserCouponOrderByWithRelationInput
      | UserCouponOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserCoupons.
     */
    cursor?: UserCouponWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserCoupons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserCoupons.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserCoupons.
     */
    distinct?: UserCouponScalarFieldEnum | UserCouponScalarFieldEnum[];
  };

  /**
   * UserCoupon findFirstOrThrow
   */
  export type UserCouponFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null;
    /**
     * Filter, which UserCoupon to fetch.
     */
    where?: UserCouponWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserCoupons to fetch.
     */
    orderBy?:
      | UserCouponOrderByWithRelationInput
      | UserCouponOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserCoupons.
     */
    cursor?: UserCouponWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserCoupons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserCoupons.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserCoupons.
     */
    distinct?: UserCouponScalarFieldEnum | UserCouponScalarFieldEnum[];
  };

  /**
   * UserCoupon findMany
   */
  export type UserCouponFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null;
    /**
     * Filter, which UserCoupons to fetch.
     */
    where?: UserCouponWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserCoupons to fetch.
     */
    orderBy?:
      | UserCouponOrderByWithRelationInput
      | UserCouponOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UserCoupons.
     */
    cursor?: UserCouponWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserCoupons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserCoupons.
     */
    skip?: number;
    distinct?: UserCouponScalarFieldEnum | UserCouponScalarFieldEnum[];
  };

  /**
   * UserCoupon create
   */
  export type UserCouponCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null;
    /**
     * The data needed to create a UserCoupon.
     */
    data: XOR<UserCouponCreateInput, UserCouponUncheckedCreateInput>;
  };

  /**
   * UserCoupon createMany
   */
  export type UserCouponCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many UserCoupons.
     */
    data: UserCouponCreateManyInput | UserCouponCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserCoupon update
   */
  export type UserCouponUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null;
    /**
     * The data needed to update a UserCoupon.
     */
    data: XOR<UserCouponUpdateInput, UserCouponUncheckedUpdateInput>;
    /**
     * Choose, which UserCoupon to update.
     */
    where: UserCouponWhereUniqueInput;
  };

  /**
   * UserCoupon updateMany
   */
  export type UserCouponUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update UserCoupons.
     */
    data: XOR<
      UserCouponUpdateManyMutationInput,
      UserCouponUncheckedUpdateManyInput
    >;
    /**
     * Filter which UserCoupons to update
     */
    where?: UserCouponWhereInput;
    /**
     * Limit how many UserCoupons to update.
     */
    limit?: number;
  };

  /**
   * UserCoupon upsert
   */
  export type UserCouponUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null;
    /**
     * The filter to search for the UserCoupon to update in case it exists.
     */
    where: UserCouponWhereUniqueInput;
    /**
     * In case the UserCoupon found by the `where` argument doesn't exist, create a new UserCoupon with this data.
     */
    create: XOR<UserCouponCreateInput, UserCouponUncheckedCreateInput>;
    /**
     * In case the UserCoupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCouponUpdateInput, UserCouponUncheckedUpdateInput>;
  };

  /**
   * UserCoupon delete
   */
  export type UserCouponDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null;
    /**
     * Filter which UserCoupon to delete.
     */
    where: UserCouponWhereUniqueInput;
  };

  /**
   * UserCoupon deleteMany
   */
  export type UserCouponDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which UserCoupons to delete
     */
    where?: UserCouponWhereInput;
    /**
     * Limit how many UserCoupons to delete.
     */
    limit?: number;
  };

  /**
   * UserCoupon without action
   */
  export type UserCouponDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null;
  };

  /**
   * Model Wishlist
   */

  export type AggregateWishlist = {
    _count: WishlistCountAggregateOutputType | null;
    _avg: WishlistAvgAggregateOutputType | null;
    _sum: WishlistSumAggregateOutputType | null;
    _min: WishlistMinAggregateOutputType | null;
    _max: WishlistMaxAggregateOutputType | null;
  };

  export type WishlistAvgAggregateOutputType = {
    idUser: number | null;
    idCourse: number | null;
  };

  export type WishlistSumAggregateOutputType = {
    idUser: number | null;
    idCourse: number | null;
  };

  export type WishlistMinAggregateOutputType = {
    idUser: number | null;
    idCourse: number | null;
  };

  export type WishlistMaxAggregateOutputType = {
    idUser: number | null;
    idCourse: number | null;
  };

  export type WishlistCountAggregateOutputType = {
    idUser: number;
    idCourse: number;
    _all: number;
  };

  export type WishlistAvgAggregateInputType = {
    idUser?: true;
    idCourse?: true;
  };

  export type WishlistSumAggregateInputType = {
    idUser?: true;
    idCourse?: true;
  };

  export type WishlistMinAggregateInputType = {
    idUser?: true;
    idCourse?: true;
  };

  export type WishlistMaxAggregateInputType = {
    idUser?: true;
    idCourse?: true;
  };

  export type WishlistCountAggregateInputType = {
    idUser?: true;
    idCourse?: true;
    _all?: true;
  };

  export type WishlistAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Wishlist to aggregate.
     */
    where?: WishlistWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Wishlists to fetch.
     */
    orderBy?:
      | WishlistOrderByWithRelationInput
      | WishlistOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: WishlistWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Wishlists.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Wishlists
     **/
    _count?: true | WishlistCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: WishlistAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: WishlistSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: WishlistMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: WishlistMaxAggregateInputType;
  };

  export type GetWishlistAggregateType<T extends WishlistAggregateArgs> = {
    [P in keyof T & keyof AggregateWishlist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishlist[P]>
      : GetScalarType<T[P], AggregateWishlist[P]>;
  };

  export type WishlistGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: WishlistWhereInput;
    orderBy?:
      | WishlistOrderByWithAggregationInput
      | WishlistOrderByWithAggregationInput[];
    by: WishlistScalarFieldEnum[] | WishlistScalarFieldEnum;
    having?: WishlistScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: WishlistCountAggregateInputType | true;
    _avg?: WishlistAvgAggregateInputType;
    _sum?: WishlistSumAggregateInputType;
    _min?: WishlistMinAggregateInputType;
    _max?: WishlistMaxAggregateInputType;
  };

  export type WishlistGroupByOutputType = {
    idUser: number;
    idCourse: number;
    _count: WishlistCountAggregateOutputType | null;
    _avg: WishlistAvgAggregateOutputType | null;
    _sum: WishlistSumAggregateOutputType | null;
    _min: WishlistMinAggregateOutputType | null;
    _max: WishlistMaxAggregateOutputType | null;
  };

  type GetWishlistGroupByPayload<T extends WishlistGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<WishlistGroupByOutputType, T['by']> & {
          [P in keyof T & keyof WishlistGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WishlistGroupByOutputType[P]>
            : GetScalarType<T[P], WishlistGroupByOutputType[P]>;
        }
      >
    >;

  export type WishlistSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      idUser?: boolean;
      idCourse?: boolean;
      Course?: boolean | CourseDefaultArgs<ExtArgs>;
      User?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['wishlist']
  >;

  export type WishlistSelectScalar = {
    idUser?: boolean;
    idCourse?: boolean;
  };

  export type WishlistOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<'idUser' | 'idCourse', ExtArgs['result']['wishlist']>;
  export type WishlistInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    Course?: boolean | CourseDefaultArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $WishlistPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Wishlist';
    objects: {
      Course: Prisma.$CoursePayload<ExtArgs>;
      User: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        idUser: number;
        idCourse: number;
      },
      ExtArgs['result']['wishlist']
    >;
    composites: {};
  };

  type WishlistGetPayload<
    S extends boolean | null | undefined | WishlistDefaultArgs
  > = $Result.GetResult<Prisma.$WishlistPayload, S>;

  type WishlistCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<WishlistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: WishlistCountAggregateInputType | true;
  };

  export interface WishlistDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Wishlist'];
      meta: { name: 'Wishlist' };
    };
    /**
     * Find zero or one Wishlist that matches the filter.
     * @param {WishlistFindUniqueArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WishlistFindUniqueArgs>(
      args: SelectSubset<T, WishlistFindUniqueArgs<ExtArgs>>
    ): Prisma__WishlistClient<
      $Result.GetResult<
        Prisma.$WishlistPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Wishlist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WishlistFindUniqueOrThrowArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WishlistFindUniqueOrThrowArgs>(
      args: SelectSubset<T, WishlistFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WishlistClient<
      $Result.GetResult<
        Prisma.$WishlistPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Wishlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindFirstArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WishlistFindFirstArgs>(
      args?: SelectSubset<T, WishlistFindFirstArgs<ExtArgs>>
    ): Prisma__WishlistClient<
      $Result.GetResult<
        Prisma.$WishlistPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Wishlist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindFirstOrThrowArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WishlistFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WishlistFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WishlistClient<
      $Result.GetResult<
        Prisma.$WishlistPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Wishlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wishlists
     * const wishlists = await prisma.wishlist.findMany()
     *
     * // Get first 10 Wishlists
     * const wishlists = await prisma.wishlist.findMany({ take: 10 })
     *
     * // Only select the `idUser`
     * const wishlistWithIdUserOnly = await prisma.wishlist.findMany({ select: { idUser: true } })
     *
     */
    findMany<T extends WishlistFindManyArgs>(
      args?: SelectSubset<T, WishlistFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WishlistPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Wishlist.
     * @param {WishlistCreateArgs} args - Arguments to create a Wishlist.
     * @example
     * // Create one Wishlist
     * const Wishlist = await prisma.wishlist.create({
     *   data: {
     *     // ... data to create a Wishlist
     *   }
     * })
     *
     */
    create<T extends WishlistCreateArgs>(
      args: SelectSubset<T, WishlistCreateArgs<ExtArgs>>
    ): Prisma__WishlistClient<
      $Result.GetResult<
        Prisma.$WishlistPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Wishlists.
     * @param {WishlistCreateManyArgs} args - Arguments to create many Wishlists.
     * @example
     * // Create many Wishlists
     * const wishlist = await prisma.wishlist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends WishlistCreateManyArgs>(
      args?: SelectSubset<T, WishlistCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Wishlist.
     * @param {WishlistDeleteArgs} args - Arguments to delete one Wishlist.
     * @example
     * // Delete one Wishlist
     * const Wishlist = await prisma.wishlist.delete({
     *   where: {
     *     // ... filter to delete one Wishlist
     *   }
     * })
     *
     */
    delete<T extends WishlistDeleteArgs>(
      args: SelectSubset<T, WishlistDeleteArgs<ExtArgs>>
    ): Prisma__WishlistClient<
      $Result.GetResult<
        Prisma.$WishlistPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Wishlist.
     * @param {WishlistUpdateArgs} args - Arguments to update one Wishlist.
     * @example
     * // Update one Wishlist
     * const wishlist = await prisma.wishlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends WishlistUpdateArgs>(
      args: SelectSubset<T, WishlistUpdateArgs<ExtArgs>>
    ): Prisma__WishlistClient<
      $Result.GetResult<
        Prisma.$WishlistPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Wishlists.
     * @param {WishlistDeleteManyArgs} args - Arguments to filter Wishlists to delete.
     * @example
     * // Delete a few Wishlists
     * const { count } = await prisma.wishlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends WishlistDeleteManyArgs>(
      args?: SelectSubset<T, WishlistDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Wishlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wishlists
     * const wishlist = await prisma.wishlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends WishlistUpdateManyArgs>(
      args: SelectSubset<T, WishlistUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Wishlist.
     * @param {WishlistUpsertArgs} args - Arguments to update or create a Wishlist.
     * @example
     * // Update or create a Wishlist
     * const wishlist = await prisma.wishlist.upsert({
     *   create: {
     *     // ... data to create a Wishlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wishlist we want to update
     *   }
     * })
     */
    upsert<T extends WishlistUpsertArgs>(
      args: SelectSubset<T, WishlistUpsertArgs<ExtArgs>>
    ): Prisma__WishlistClient<
      $Result.GetResult<
        Prisma.$WishlistPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Wishlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistCountArgs} args - Arguments to filter Wishlists to count.
     * @example
     * // Count the number of Wishlists
     * const count = await prisma.wishlist.count({
     *   where: {
     *     // ... the filter for the Wishlists we want to count
     *   }
     * })
     **/
    count<T extends WishlistCountArgs>(
      args?: Subset<T, WishlistCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WishlistCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Wishlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends WishlistAggregateArgs>(
      args: Subset<T, WishlistAggregateArgs>
    ): Prisma.PrismaPromise<GetWishlistAggregateType<T>>;

    /**
     * Group by Wishlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends WishlistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WishlistGroupByArgs['orderBy'] }
        : { orderBy?: WishlistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, WishlistGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetWishlistGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Wishlist model
     */
    readonly fields: WishlistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wishlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WishlistClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    Course<T extends CourseDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CourseDefaultArgs<ExtArgs>>
    ): Prisma__CourseClient<
      | $Result.GetResult<
          Prisma.$CoursePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    User<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Wishlist model
   */
  interface WishlistFieldRefs {
    readonly idUser: FieldRef<'Wishlist', 'Int'>;
    readonly idCourse: FieldRef<'Wishlist', 'Int'>;
  }

  // Custom InputTypes
  /**
   * Wishlist findUnique
   */
  export type WishlistFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    /**
     * Filter, which Wishlist to fetch.
     */
    where: WishlistWhereUniqueInput;
  };

  /**
   * Wishlist findUniqueOrThrow
   */
  export type WishlistFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    /**
     * Filter, which Wishlist to fetch.
     */
    where: WishlistWhereUniqueInput;
  };

  /**
   * Wishlist findFirst
   */
  export type WishlistFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    /**
     * Filter, which Wishlist to fetch.
     */
    where?: WishlistWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Wishlists to fetch.
     */
    orderBy?:
      | WishlistOrderByWithRelationInput
      | WishlistOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Wishlists.
     */
    cursor?: WishlistWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Wishlists.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Wishlists.
     */
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[];
  };

  /**
   * Wishlist findFirstOrThrow
   */
  export type WishlistFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    /**
     * Filter, which Wishlist to fetch.
     */
    where?: WishlistWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Wishlists to fetch.
     */
    orderBy?:
      | WishlistOrderByWithRelationInput
      | WishlistOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Wishlists.
     */
    cursor?: WishlistWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Wishlists.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Wishlists.
     */
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[];
  };

  /**
   * Wishlist findMany
   */
  export type WishlistFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    /**
     * Filter, which Wishlists to fetch.
     */
    where?: WishlistWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Wishlists to fetch.
     */
    orderBy?:
      | WishlistOrderByWithRelationInput
      | WishlistOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Wishlists.
     */
    cursor?: WishlistWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Wishlists.
     */
    skip?: number;
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[];
  };

  /**
   * Wishlist create
   */
  export type WishlistCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    /**
     * The data needed to create a Wishlist.
     */
    data: XOR<WishlistCreateInput, WishlistUncheckedCreateInput>;
  };

  /**
   * Wishlist createMany
   */
  export type WishlistCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Wishlists.
     */
    data: WishlistCreateManyInput | WishlistCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Wishlist update
   */
  export type WishlistUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    /**
     * The data needed to update a Wishlist.
     */
    data: XOR<WishlistUpdateInput, WishlistUncheckedUpdateInput>;
    /**
     * Choose, which Wishlist to update.
     */
    where: WishlistWhereUniqueInput;
  };

  /**
   * Wishlist updateMany
   */
  export type WishlistUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Wishlists.
     */
    data: XOR<
      WishlistUpdateManyMutationInput,
      WishlistUncheckedUpdateManyInput
    >;
    /**
     * Filter which Wishlists to update
     */
    where?: WishlistWhereInput;
    /**
     * Limit how many Wishlists to update.
     */
    limit?: number;
  };

  /**
   * Wishlist upsert
   */
  export type WishlistUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    /**
     * The filter to search for the Wishlist to update in case it exists.
     */
    where: WishlistWhereUniqueInput;
    /**
     * In case the Wishlist found by the `where` argument doesn't exist, create a new Wishlist with this data.
     */
    create: XOR<WishlistCreateInput, WishlistUncheckedCreateInput>;
    /**
     * In case the Wishlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WishlistUpdateInput, WishlistUncheckedUpdateInput>;
  };

  /**
   * Wishlist delete
   */
  export type WishlistDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    /**
     * Filter which Wishlist to delete.
     */
    where: WishlistWhereUniqueInput;
  };

  /**
   * Wishlist deleteMany
   */
  export type WishlistDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Wishlists to delete
     */
    where?: WishlistWhereInput;
    /**
     * Limit how many Wishlists to delete.
     */
    limit?: number;
  };

  /**
   * Wishlist without action
   */
  export type WishlistDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted';
    ReadCommitted: 'ReadCommitted';
    RepeatableRead: 'RepeatableRead';
    Serializable: 'Serializable';
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const AnswerScalarFieldEnum: {
    idQuestion: 'idQuestion';
    idAnswer: 'idAnswer';
    idUser: 'idUser';
    contentAnswer: 'contentAnswer';
  };

  export type AnswerScalarFieldEnum =
    (typeof AnswerScalarFieldEnum)[keyof typeof AnswerScalarFieldEnum];

  export const CartScalarFieldEnum: {
    idUser: 'idUser';
    idCourse: 'idCourse';
  };

  export type CartScalarFieldEnum =
    (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum];

  export const CategoryScalarFieldEnum: {
    idCategory: 'idCategory';
    nameCategory: 'nameCategory';
  };

  export type CategoryScalarFieldEnum =
    (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum];

  export const CertificateScalarFieldEnum: {
    idCourse: 'idCourse';
    certificate: 'certificate';
  };

  export type CertificateScalarFieldEnum =
    (typeof CertificateScalarFieldEnum)[keyof typeof CertificateScalarFieldEnum];

  export const CouponScalarFieldEnum: {
    idCoupon: 'idCoupon';
    type: 'type';
    value: 'value';
    startDate: 'startDate';
    endDate: 'endDate';
    quantity: 'quantity';
    appliedAmount: 'appliedAmount';
    minRequire: 'minRequire';
    maxValueDiscount: 'maxValueDiscount';
    code: 'code';
    idUser: 'idUser';
  };

  export type CouponScalarFieldEnum =
    (typeof CouponScalarFieldEnum)[keyof typeof CouponScalarFieldEnum];

  export const CouponCourseScalarFieldEnum: {
    idCoupon: 'idCoupon';
    idCourse: 'idCourse';
  };

  export type CouponCourseScalarFieldEnum =
    (typeof CouponCourseScalarFieldEnum)[keyof typeof CouponCourseScalarFieldEnum];

  export const CourseScalarFieldEnum: {
    idCourse: 'idCourse';
    idUser: 'idUser';
    title: 'title';
    subTitle: 'subTitle';
    description: 'description';
    price: 'price';
    isPublic: 'isPublic';
    isAccepted: 'isAccepted';
    thumbnail: 'thumbnail';
    requirement: 'requirement';
    targetAudience: 'targetAudience';
  };

  export type CourseScalarFieldEnum =
    (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum];

  export const CourseCategoryScalarFieldEnum: {
    idCourse: 'idCourse';
    idCategory: 'idCategory';
  };

  export type CourseCategoryScalarFieldEnum =
    (typeof CourseCategoryScalarFieldEnum)[keyof typeof CourseCategoryScalarFieldEnum];

  export const CourseObjectiveScalarFieldEnum: {
    idCourse: 'idCourse';
    idCourseObjective: 'idCourseObjective';
    content: 'content';
  };

  export type CourseObjectiveScalarFieldEnum =
    (typeof CourseObjectiveScalarFieldEnum)[keyof typeof CourseObjectiveScalarFieldEnum];

  export const EnrollmentScalarFieldEnum: {
    idUser: 'idUser';
    idCourse: 'idCourse';
    dateRegister: 'dateRegister';
    finishStatus: 'finishStatus';
    progress: 'progress';
  };

  export type EnrollmentScalarFieldEnum =
    (typeof EnrollmentScalarFieldEnum)[keyof typeof EnrollmentScalarFieldEnum];

  export const FollowScalarFieldEnum: {
    idFollower: 'idFollower';
    idFollowing: 'idFollowing';
  };

  export type FollowScalarFieldEnum =
    (typeof FollowScalarFieldEnum)[keyof typeof FollowScalarFieldEnum];

  export const LectureScalarFieldEnum: {
    idCourse: 'idCourse';
    idSection: 'idSection';
    idLecture: 'idLecture';
    nameLecture: 'nameLecture';
    isDone: 'isDone';
  };

  export type LectureScalarFieldEnum =
    (typeof LectureScalarFieldEnum)[keyof typeof LectureScalarFieldEnum];

  export const MessageScalarFieldEnum: {
    idMessage: 'idMessage';
    idUserSender: 'idUserSender';
    idUserReceiver: 'idUserReceiver';
    message: 'message';
    timeSend: 'timeSend';
  };

  export type MessageScalarFieldEnum =
    (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum];

  export const NoteScalarFieldEnum: {
    idNote: 'idNote';
    timeNote: 'timeNote';
    note: 'note';
    idUser: 'idUser';
    idCourse: 'idCourse';
    idSection: 'idSection';
    idLecture: 'idLecture';
  };

  export type NoteScalarFieldEnum =
    (typeof NoteScalarFieldEnum)[keyof typeof NoteScalarFieldEnum];

  export const NotificationScalarFieldEnum: {
    idNotification: 'idNotification';
    contentNotification: 'contentNotification';
    idUser: 'idUser';
  };

  export type NotificationScalarFieldEnum =
    (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum];

  export const NotificationReceiverScalarFieldEnum: {
    idNotification: 'idNotification';
    idUser: 'idUser';
    timeGetNotification: 'timeGetNotification';
  };

  export type NotificationReceiverScalarFieldEnum =
    (typeof NotificationReceiverScalarFieldEnum)[keyof typeof NotificationReceiverScalarFieldEnum];

  export const PaymentScalarFieldEnum: {
    idPayment: 'idPayment';
    timePayment: 'timePayment';
    totalPrice: 'totalPrice';
    idUser: 'idUser';
  };

  export type PaymentScalarFieldEnum =
    (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum];

  export const PaymentDetailScalarFieldEnum: {
    idPayment: 'idPayment';
    idCourse: 'idCourse';
    price: 'price';
  };

  export type PaymentDetailScalarFieldEnum =
    (typeof PaymentDetailScalarFieldEnum)[keyof typeof PaymentDetailScalarFieldEnum];

  export const QuestionScalarFieldEnum: {
    idQuestion: 'idQuestion';
    idUser: 'idUser';
    idCourse: 'idCourse';
    idSection: 'idSection';
    idLecture: 'idLecture';
    contentQuestion: 'contentQuestion';
  };

  export type QuestionScalarFieldEnum =
    (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum];

  export const ReportScalarFieldEnum: {
    idReport: 'idReport';
    idUser: 'idUser';
    contentReport: 'contentReport';
  };

  export type ReportScalarFieldEnum =
    (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum];

  export const ReviewScalarFieldEnum: {
    idReview: 'idReview';
    idUser: 'idUser';
    idCourse: 'idCourse';
    rating: 'rating';
    review: 'review';
  };

  export type ReviewScalarFieldEnum =
    (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum];

  export const SectionScalarFieldEnum: {
    idCourse: 'idCourse';
    idSection: 'idSection';
    nameSection: 'nameSection';
  };

  export type SectionScalarFieldEnum =
    (typeof SectionScalarFieldEnum)[keyof typeof SectionScalarFieldEnum];

  export const StudyRemindScalarFieldEnum: {
    idStudyRemind: 'idStudyRemind';
    idUser: 'idUser';
    idCourse: 'idCourse';
    timeRemind: 'timeRemind';
    typeRemind: 'typeRemind';
  };

  export type StudyRemindScalarFieldEnum =
    (typeof StudyRemindScalarFieldEnum)[keyof typeof StudyRemindScalarFieldEnum];

  export const UserScalarFieldEnum: {
    idUser: 'idUser';
    name: 'name';
    biography: 'biography';
    role: 'role';
    gender: 'gender';
    birthday: 'birthday';
    codeExpired: 'codeExpired';
    codeId: 'codeId';
    email: 'email';
    password: 'password';
  };

  export type UserScalarFieldEnum =
    (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const UserCertificateScalarFieldEnum: {
    idCourse: 'idCourse';
    idUser: 'idUser';
  };

  export type UserCertificateScalarFieldEnum =
    (typeof UserCertificateScalarFieldEnum)[keyof typeof UserCertificateScalarFieldEnum];

  export const UserCouponScalarFieldEnum: {
    idUser: 'idUser';
    idCoupon: 'idCoupon';
  };

  export type UserCouponScalarFieldEnum =
    (typeof UserCouponScalarFieldEnum)[keyof typeof UserCouponScalarFieldEnum];

  export const WishlistScalarFieldEnum: {
    idUser: 'idUser';
    idCourse: 'idCourse';
  };

  export type WishlistScalarFieldEnum =
    (typeof WishlistScalarFieldEnum)[keyof typeof WishlistScalarFieldEnum];

  export const SortOrder: {
    asc: 'asc';
    desc: 'desc';
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const NullsOrder: {
    first: 'first';
    last: 'last';
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const AnswerOrderByRelevanceFieldEnum: {
    contentAnswer: 'contentAnswer';
  };

  export type AnswerOrderByRelevanceFieldEnum =
    (typeof AnswerOrderByRelevanceFieldEnum)[keyof typeof AnswerOrderByRelevanceFieldEnum];

  export const CategoryOrderByRelevanceFieldEnum: {
    nameCategory: 'nameCategory';
  };

  export type CategoryOrderByRelevanceFieldEnum =
    (typeof CategoryOrderByRelevanceFieldEnum)[keyof typeof CategoryOrderByRelevanceFieldEnum];

  export const CertificateOrderByRelevanceFieldEnum: {
    certificate: 'certificate';
  };

  export type CertificateOrderByRelevanceFieldEnum =
    (typeof CertificateOrderByRelevanceFieldEnum)[keyof typeof CertificateOrderByRelevanceFieldEnum];

  export const CouponOrderByRelevanceFieldEnum: {
    type: 'type';
    code: 'code';
  };

  export type CouponOrderByRelevanceFieldEnum =
    (typeof CouponOrderByRelevanceFieldEnum)[keyof typeof CouponOrderByRelevanceFieldEnum];

  export const CourseOrderByRelevanceFieldEnum: {
    title: 'title';
    subTitle: 'subTitle';
    description: 'description';
    thumbnail: 'thumbnail';
    requirement: 'requirement';
    targetAudience: 'targetAudience';
  };

  export type CourseOrderByRelevanceFieldEnum =
    (typeof CourseOrderByRelevanceFieldEnum)[keyof typeof CourseOrderByRelevanceFieldEnum];

  export const CourseObjectiveOrderByRelevanceFieldEnum: {
    content: 'content';
  };

  export type CourseObjectiveOrderByRelevanceFieldEnum =
    (typeof CourseObjectiveOrderByRelevanceFieldEnum)[keyof typeof CourseObjectiveOrderByRelevanceFieldEnum];

  export const LectureOrderByRelevanceFieldEnum: {
    nameLecture: 'nameLecture';
  };

  export type LectureOrderByRelevanceFieldEnum =
    (typeof LectureOrderByRelevanceFieldEnum)[keyof typeof LectureOrderByRelevanceFieldEnum];

  export const MessageOrderByRelevanceFieldEnum: {
    message: 'message';
  };

  export type MessageOrderByRelevanceFieldEnum =
    (typeof MessageOrderByRelevanceFieldEnum)[keyof typeof MessageOrderByRelevanceFieldEnum];

  export const NoteOrderByRelevanceFieldEnum: {
    note: 'note';
  };

  export type NoteOrderByRelevanceFieldEnum =
    (typeof NoteOrderByRelevanceFieldEnum)[keyof typeof NoteOrderByRelevanceFieldEnum];

  export const NotificationOrderByRelevanceFieldEnum: {
    contentNotification: 'contentNotification';
  };

  export type NotificationOrderByRelevanceFieldEnum =
    (typeof NotificationOrderByRelevanceFieldEnum)[keyof typeof NotificationOrderByRelevanceFieldEnum];

  export const QuestionOrderByRelevanceFieldEnum: {
    contentQuestion: 'contentQuestion';
  };

  export type QuestionOrderByRelevanceFieldEnum =
    (typeof QuestionOrderByRelevanceFieldEnum)[keyof typeof QuestionOrderByRelevanceFieldEnum];

  export const ReportOrderByRelevanceFieldEnum: {
    contentReport: 'contentReport';
  };

  export type ReportOrderByRelevanceFieldEnum =
    (typeof ReportOrderByRelevanceFieldEnum)[keyof typeof ReportOrderByRelevanceFieldEnum];

  export const ReviewOrderByRelevanceFieldEnum: {
    review: 'review';
  };

  export type ReviewOrderByRelevanceFieldEnum =
    (typeof ReviewOrderByRelevanceFieldEnum)[keyof typeof ReviewOrderByRelevanceFieldEnum];

  export const SectionOrderByRelevanceFieldEnum: {
    nameSection: 'nameSection';
  };

  export type SectionOrderByRelevanceFieldEnum =
    (typeof SectionOrderByRelevanceFieldEnum)[keyof typeof SectionOrderByRelevanceFieldEnum];

  export const StudyRemindOrderByRelevanceFieldEnum: {
    typeRemind: 'typeRemind';
  };

  export type StudyRemindOrderByRelevanceFieldEnum =
    (typeof StudyRemindOrderByRelevanceFieldEnum)[keyof typeof StudyRemindOrderByRelevanceFieldEnum];

  export const UserOrderByRelevanceFieldEnum: {
    name: 'name';
    biography: 'biography';
    role: 'role';
    gender: 'gender';
    codeExpired: 'codeExpired';
    codeId: 'codeId';
    email: 'email';
    password: 'password';
  };

  export type UserOrderByRelevanceFieldEnum =
    (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int'
  >;

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String'
  >;

  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Decimal'
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime'
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Boolean'
  >;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float'
  >;

  /**
   * Deep Input Types
   */

  export type AnswerWhereInput = {
    AND?: AnswerWhereInput | AnswerWhereInput[];
    OR?: AnswerWhereInput[];
    NOT?: AnswerWhereInput | AnswerWhereInput[];
    idQuestion?: IntFilter<'Answer'> | number;
    idAnswer?: IntFilter<'Answer'> | number;
    idUser?: IntNullableFilter<'Answer'> | number | null;
    contentAnswer?: StringNullableFilter<'Answer'> | string | null;
    Question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>;
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type AnswerOrderByWithRelationInput = {
    idQuestion?: SortOrder;
    idAnswer?: SortOrder;
    idUser?: SortOrderInput | SortOrder;
    contentAnswer?: SortOrderInput | SortOrder;
    Question?: QuestionOrderByWithRelationInput;
    User?: UserOrderByWithRelationInput;
    _relevance?: AnswerOrderByRelevanceInput;
  };

  export type AnswerWhereUniqueInput = Prisma.AtLeast<
    {
      idQuestion_idAnswer?: AnswerIdQuestionIdAnswerCompoundUniqueInput;
      AND?: AnswerWhereInput | AnswerWhereInput[];
      OR?: AnswerWhereInput[];
      NOT?: AnswerWhereInput | AnswerWhereInput[];
      idQuestion?: IntFilter<'Answer'> | number;
      idAnswer?: IntFilter<'Answer'> | number;
      idUser?: IntNullableFilter<'Answer'> | number | null;
      contentAnswer?: StringNullableFilter<'Answer'> | string | null;
      Question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>;
      User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    'idQuestion_idAnswer'
  >;

  export type AnswerOrderByWithAggregationInput = {
    idQuestion?: SortOrder;
    idAnswer?: SortOrder;
    idUser?: SortOrderInput | SortOrder;
    contentAnswer?: SortOrderInput | SortOrder;
    _count?: AnswerCountOrderByAggregateInput;
    _avg?: AnswerAvgOrderByAggregateInput;
    _max?: AnswerMaxOrderByAggregateInput;
    _min?: AnswerMinOrderByAggregateInput;
    _sum?: AnswerSumOrderByAggregateInput;
  };

  export type AnswerScalarWhereWithAggregatesInput = {
    AND?:
      | AnswerScalarWhereWithAggregatesInput
      | AnswerScalarWhereWithAggregatesInput[];
    OR?: AnswerScalarWhereWithAggregatesInput[];
    NOT?:
      | AnswerScalarWhereWithAggregatesInput
      | AnswerScalarWhereWithAggregatesInput[];
    idQuestion?: IntWithAggregatesFilter<'Answer'> | number;
    idAnswer?: IntWithAggregatesFilter<'Answer'> | number;
    idUser?: IntNullableWithAggregatesFilter<'Answer'> | number | null;
    contentAnswer?:
      | StringNullableWithAggregatesFilter<'Answer'>
      | string
      | null;
  };

  export type CartWhereInput = {
    AND?: CartWhereInput | CartWhereInput[];
    OR?: CartWhereInput[];
    NOT?: CartWhereInput | CartWhereInput[];
    idUser?: IntFilter<'Cart'> | number;
    idCourse?: IntFilter<'Cart'> | number;
    Course?: XOR<CourseScalarRelationFilter, CourseWhereInput>;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type CartOrderByWithRelationInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
    Course?: CourseOrderByWithRelationInput;
    User?: UserOrderByWithRelationInput;
  };

  export type CartWhereUniqueInput = Prisma.AtLeast<
    {
      idUser_idCourse?: CartIdUserIdCourseCompoundUniqueInput;
      AND?: CartWhereInput | CartWhereInput[];
      OR?: CartWhereInput[];
      NOT?: CartWhereInput | CartWhereInput[];
      idUser?: IntFilter<'Cart'> | number;
      idCourse?: IntFilter<'Cart'> | number;
      Course?: XOR<CourseScalarRelationFilter, CourseWhereInput>;
      User?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'idUser_idCourse'
  >;

  export type CartOrderByWithAggregationInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
    _count?: CartCountOrderByAggregateInput;
    _avg?: CartAvgOrderByAggregateInput;
    _max?: CartMaxOrderByAggregateInput;
    _min?: CartMinOrderByAggregateInput;
    _sum?: CartSumOrderByAggregateInput;
  };

  export type CartScalarWhereWithAggregatesInput = {
    AND?:
      | CartScalarWhereWithAggregatesInput
      | CartScalarWhereWithAggregatesInput[];
    OR?: CartScalarWhereWithAggregatesInput[];
    NOT?:
      | CartScalarWhereWithAggregatesInput
      | CartScalarWhereWithAggregatesInput[];
    idUser?: IntWithAggregatesFilter<'Cart'> | number;
    idCourse?: IntWithAggregatesFilter<'Cart'> | number;
  };

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[];
    OR?: CategoryWhereInput[];
    NOT?: CategoryWhereInput | CategoryWhereInput[];
    idCategory?: IntFilter<'Category'> | number;
    nameCategory?: StringNullableFilter<'Category'> | string | null;
    CourseCategory?: CourseCategoryListRelationFilter;
  };

  export type CategoryOrderByWithRelationInput = {
    idCategory?: SortOrder;
    nameCategory?: SortOrderInput | SortOrder;
    CourseCategory?: CourseCategoryOrderByRelationAggregateInput;
    _relevance?: CategoryOrderByRelevanceInput;
  };

  export type CategoryWhereUniqueInput = Prisma.AtLeast<
    {
      idCategory?: number;
      AND?: CategoryWhereInput | CategoryWhereInput[];
      OR?: CategoryWhereInput[];
      NOT?: CategoryWhereInput | CategoryWhereInput[];
      nameCategory?: StringNullableFilter<'Category'> | string | null;
      CourseCategory?: CourseCategoryListRelationFilter;
    },
    'idCategory'
  >;

  export type CategoryOrderByWithAggregationInput = {
    idCategory?: SortOrder;
    nameCategory?: SortOrderInput | SortOrder;
    _count?: CategoryCountOrderByAggregateInput;
    _avg?: CategoryAvgOrderByAggregateInput;
    _max?: CategoryMaxOrderByAggregateInput;
    _min?: CategoryMinOrderByAggregateInput;
    _sum?: CategorySumOrderByAggregateInput;
  };

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?:
      | CategoryScalarWhereWithAggregatesInput
      | CategoryScalarWhereWithAggregatesInput[];
    OR?: CategoryScalarWhereWithAggregatesInput[];
    NOT?:
      | CategoryScalarWhereWithAggregatesInput
      | CategoryScalarWhereWithAggregatesInput[];
    idCategory?: IntWithAggregatesFilter<'Category'> | number;
    nameCategory?:
      | StringNullableWithAggregatesFilter<'Category'>
      | string
      | null;
  };

  export type CertificateWhereInput = {
    AND?: CertificateWhereInput | CertificateWhereInput[];
    OR?: CertificateWhereInput[];
    NOT?: CertificateWhereInput | CertificateWhereInput[];
    idCourse?: IntFilter<'Certificate'> | number;
    certificate?: StringNullableFilter<'Certificate'> | string | null;
    Course?: XOR<CourseScalarRelationFilter, CourseWhereInput>;
    UserCertificate?: UserCertificateListRelationFilter;
  };

  export type CertificateOrderByWithRelationInput = {
    idCourse?: SortOrder;
    certificate?: SortOrderInput | SortOrder;
    Course?: CourseOrderByWithRelationInput;
    UserCertificate?: UserCertificateOrderByRelationAggregateInput;
    _relevance?: CertificateOrderByRelevanceInput;
  };

  export type CertificateWhereUniqueInput = Prisma.AtLeast<
    {
      idCourse?: number;
      AND?: CertificateWhereInput | CertificateWhereInput[];
      OR?: CertificateWhereInput[];
      NOT?: CertificateWhereInput | CertificateWhereInput[];
      certificate?: StringNullableFilter<'Certificate'> | string | null;
      Course?: XOR<CourseScalarRelationFilter, CourseWhereInput>;
      UserCertificate?: UserCertificateListRelationFilter;
    },
    'idCourse'
  >;

  export type CertificateOrderByWithAggregationInput = {
    idCourse?: SortOrder;
    certificate?: SortOrderInput | SortOrder;
    _count?: CertificateCountOrderByAggregateInput;
    _avg?: CertificateAvgOrderByAggregateInput;
    _max?: CertificateMaxOrderByAggregateInput;
    _min?: CertificateMinOrderByAggregateInput;
    _sum?: CertificateSumOrderByAggregateInput;
  };

  export type CertificateScalarWhereWithAggregatesInput = {
    AND?:
      | CertificateScalarWhereWithAggregatesInput
      | CertificateScalarWhereWithAggregatesInput[];
    OR?: CertificateScalarWhereWithAggregatesInput[];
    NOT?:
      | CertificateScalarWhereWithAggregatesInput
      | CertificateScalarWhereWithAggregatesInput[];
    idCourse?: IntWithAggregatesFilter<'Certificate'> | number;
    certificate?:
      | StringNullableWithAggregatesFilter<'Certificate'>
      | string
      | null;
  };

  export type CouponWhereInput = {
    AND?: CouponWhereInput | CouponWhereInput[];
    OR?: CouponWhereInput[];
    NOT?: CouponWhereInput | CouponWhereInput[];
    idCoupon?: IntFilter<'Coupon'> | number;
    type?: StringNullableFilter<'Coupon'> | string | null;
    value?:
      | DecimalNullableFilter<'Coupon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    startDate?: DateTimeNullableFilter<'Coupon'> | Date | string | null;
    endDate?: DateTimeNullableFilter<'Coupon'> | Date | string | null;
    quantity?: IntNullableFilter<'Coupon'> | number | null;
    appliedAmount?: IntNullableFilter<'Coupon'> | number | null;
    minRequire?:
      | DecimalNullableFilter<'Coupon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxValueDiscount?:
      | DecimalNullableFilter<'Coupon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    code?: StringNullableFilter<'Coupon'> | string | null;
    idUser?: IntNullableFilter<'Coupon'> | number | null;
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    CouponCourse?: CouponCourseListRelationFilter;
    UserCoupon?: UserCouponListRelationFilter;
  };

  export type CouponOrderByWithRelationInput = {
    idCoupon?: SortOrder;
    type?: SortOrderInput | SortOrder;
    value?: SortOrderInput | SortOrder;
    startDate?: SortOrderInput | SortOrder;
    endDate?: SortOrderInput | SortOrder;
    quantity?: SortOrderInput | SortOrder;
    appliedAmount?: SortOrderInput | SortOrder;
    minRequire?: SortOrderInput | SortOrder;
    maxValueDiscount?: SortOrderInput | SortOrder;
    code?: SortOrderInput | SortOrder;
    idUser?: SortOrderInput | SortOrder;
    User?: UserOrderByWithRelationInput;
    CouponCourse?: CouponCourseOrderByRelationAggregateInput;
    UserCoupon?: UserCouponOrderByRelationAggregateInput;
    _relevance?: CouponOrderByRelevanceInput;
  };

  export type CouponWhereUniqueInput = Prisma.AtLeast<
    {
      idCoupon?: number;
      AND?: CouponWhereInput | CouponWhereInput[];
      OR?: CouponWhereInput[];
      NOT?: CouponWhereInput | CouponWhereInput[];
      type?: StringNullableFilter<'Coupon'> | string | null;
      value?:
        | DecimalNullableFilter<'Coupon'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      startDate?: DateTimeNullableFilter<'Coupon'> | Date | string | null;
      endDate?: DateTimeNullableFilter<'Coupon'> | Date | string | null;
      quantity?: IntNullableFilter<'Coupon'> | number | null;
      appliedAmount?: IntNullableFilter<'Coupon'> | number | null;
      minRequire?:
        | DecimalNullableFilter<'Coupon'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      maxValueDiscount?:
        | DecimalNullableFilter<'Coupon'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      code?: StringNullableFilter<'Coupon'> | string | null;
      idUser?: IntNullableFilter<'Coupon'> | number | null;
      User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      CouponCourse?: CouponCourseListRelationFilter;
      UserCoupon?: UserCouponListRelationFilter;
    },
    'idCoupon'
  >;

  export type CouponOrderByWithAggregationInput = {
    idCoupon?: SortOrder;
    type?: SortOrderInput | SortOrder;
    value?: SortOrderInput | SortOrder;
    startDate?: SortOrderInput | SortOrder;
    endDate?: SortOrderInput | SortOrder;
    quantity?: SortOrderInput | SortOrder;
    appliedAmount?: SortOrderInput | SortOrder;
    minRequire?: SortOrderInput | SortOrder;
    maxValueDiscount?: SortOrderInput | SortOrder;
    code?: SortOrderInput | SortOrder;
    idUser?: SortOrderInput | SortOrder;
    _count?: CouponCountOrderByAggregateInput;
    _avg?: CouponAvgOrderByAggregateInput;
    _max?: CouponMaxOrderByAggregateInput;
    _min?: CouponMinOrderByAggregateInput;
    _sum?: CouponSumOrderByAggregateInput;
  };

  export type CouponScalarWhereWithAggregatesInput = {
    AND?:
      | CouponScalarWhereWithAggregatesInput
      | CouponScalarWhereWithAggregatesInput[];
    OR?: CouponScalarWhereWithAggregatesInput[];
    NOT?:
      | CouponScalarWhereWithAggregatesInput
      | CouponScalarWhereWithAggregatesInput[];
    idCoupon?: IntWithAggregatesFilter<'Coupon'> | number;
    type?: StringNullableWithAggregatesFilter<'Coupon'> | string | null;
    value?:
      | DecimalNullableWithAggregatesFilter<'Coupon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    startDate?:
      | DateTimeNullableWithAggregatesFilter<'Coupon'>
      | Date
      | string
      | null;
    endDate?:
      | DateTimeNullableWithAggregatesFilter<'Coupon'>
      | Date
      | string
      | null;
    quantity?: IntNullableWithAggregatesFilter<'Coupon'> | number | null;
    appliedAmount?: IntNullableWithAggregatesFilter<'Coupon'> | number | null;
    minRequire?:
      | DecimalNullableWithAggregatesFilter<'Coupon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxValueDiscount?:
      | DecimalNullableWithAggregatesFilter<'Coupon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    code?: StringNullableWithAggregatesFilter<'Coupon'> | string | null;
    idUser?: IntNullableWithAggregatesFilter<'Coupon'> | number | null;
  };

  export type CouponCourseWhereInput = {
    AND?: CouponCourseWhereInput | CouponCourseWhereInput[];
    OR?: CouponCourseWhereInput[];
    NOT?: CouponCourseWhereInput | CouponCourseWhereInput[];
    idCoupon?: IntFilter<'CouponCourse'> | number;
    idCourse?: IntFilter<'CouponCourse'> | number;
    Coupon?: XOR<CouponScalarRelationFilter, CouponWhereInput>;
    Course?: XOR<CourseScalarRelationFilter, CourseWhereInput>;
  };

  export type CouponCourseOrderByWithRelationInput = {
    idCoupon?: SortOrder;
    idCourse?: SortOrder;
    Coupon?: CouponOrderByWithRelationInput;
    Course?: CourseOrderByWithRelationInput;
  };

  export type CouponCourseWhereUniqueInput = Prisma.AtLeast<
    {
      idCoupon_idCourse?: CouponCourseIdCouponIdCourseCompoundUniqueInput;
      AND?: CouponCourseWhereInput | CouponCourseWhereInput[];
      OR?: CouponCourseWhereInput[];
      NOT?: CouponCourseWhereInput | CouponCourseWhereInput[];
      idCoupon?: IntFilter<'CouponCourse'> | number;
      idCourse?: IntFilter<'CouponCourse'> | number;
      Coupon?: XOR<CouponScalarRelationFilter, CouponWhereInput>;
      Course?: XOR<CourseScalarRelationFilter, CourseWhereInput>;
    },
    'idCoupon_idCourse'
  >;

  export type CouponCourseOrderByWithAggregationInput = {
    idCoupon?: SortOrder;
    idCourse?: SortOrder;
    _count?: CouponCourseCountOrderByAggregateInput;
    _avg?: CouponCourseAvgOrderByAggregateInput;
    _max?: CouponCourseMaxOrderByAggregateInput;
    _min?: CouponCourseMinOrderByAggregateInput;
    _sum?: CouponCourseSumOrderByAggregateInput;
  };

  export type CouponCourseScalarWhereWithAggregatesInput = {
    AND?:
      | CouponCourseScalarWhereWithAggregatesInput
      | CouponCourseScalarWhereWithAggregatesInput[];
    OR?: CouponCourseScalarWhereWithAggregatesInput[];
    NOT?:
      | CouponCourseScalarWhereWithAggregatesInput
      | CouponCourseScalarWhereWithAggregatesInput[];
    idCoupon?: IntWithAggregatesFilter<'CouponCourse'> | number;
    idCourse?: IntWithAggregatesFilter<'CouponCourse'> | number;
  };

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[];
    OR?: CourseWhereInput[];
    NOT?: CourseWhereInput | CourseWhereInput[];
    idCourse?: IntFilter<'Course'> | number;
    idUser?: IntNullableFilter<'Course'> | number | null;
    title?: StringNullableFilter<'Course'> | string | null;
    subTitle?: StringNullableFilter<'Course'> | string | null;
    description?: StringNullableFilter<'Course'> | string | null;
    price?:
      | DecimalNullableFilter<'Course'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: BoolNullableFilter<'Course'> | boolean | null;
    isAccepted?: BoolNullableFilter<'Course'> | boolean | null;
    thumbnail?: StringNullableFilter<'Course'> | string | null;
    requirement?: StringNullableFilter<'Course'> | string | null;
    targetAudience?: StringNullableFilter<'Course'> | string | null;
    Cart?: CartListRelationFilter;
    Certificate?: XOR<
      CertificateNullableScalarRelationFilter,
      CertificateWhereInput
    > | null;
    CouponCourse?: CouponCourseListRelationFilter;
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    CourseCategory?: CourseCategoryListRelationFilter;
    CourseObjective?: CourseObjectiveListRelationFilter;
    Enrollment?: EnrollmentListRelationFilter;
    PaymentDetail?: PaymentDetailListRelationFilter;
    Review?: ReviewListRelationFilter;
    Section?: SectionListRelationFilter;
    StudyRemind?: StudyRemindListRelationFilter;
    Wishlist?: WishlistListRelationFilter;
  };

  export type CourseOrderByWithRelationInput = {
    idCourse?: SortOrder;
    idUser?: SortOrderInput | SortOrder;
    title?: SortOrderInput | SortOrder;
    subTitle?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    price?: SortOrderInput | SortOrder;
    isPublic?: SortOrderInput | SortOrder;
    isAccepted?: SortOrderInput | SortOrder;
    thumbnail?: SortOrderInput | SortOrder;
    requirement?: SortOrderInput | SortOrder;
    targetAudience?: SortOrderInput | SortOrder;
    Cart?: CartOrderByRelationAggregateInput;
    Certificate?: CertificateOrderByWithRelationInput;
    CouponCourse?: CouponCourseOrderByRelationAggregateInput;
    User?: UserOrderByWithRelationInput;
    CourseCategory?: CourseCategoryOrderByRelationAggregateInput;
    CourseObjective?: CourseObjectiveOrderByRelationAggregateInput;
    Enrollment?: EnrollmentOrderByRelationAggregateInput;
    PaymentDetail?: PaymentDetailOrderByRelationAggregateInput;
    Review?: ReviewOrderByRelationAggregateInput;
    Section?: SectionOrderByRelationAggregateInput;
    StudyRemind?: StudyRemindOrderByRelationAggregateInput;
    Wishlist?: WishlistOrderByRelationAggregateInput;
    _relevance?: CourseOrderByRelevanceInput;
  };

  export type CourseWhereUniqueInput = Prisma.AtLeast<
    {
      idCourse?: number;
      AND?: CourseWhereInput | CourseWhereInput[];
      OR?: CourseWhereInput[];
      NOT?: CourseWhereInput | CourseWhereInput[];
      idUser?: IntNullableFilter<'Course'> | number | null;
      title?: StringNullableFilter<'Course'> | string | null;
      subTitle?: StringNullableFilter<'Course'> | string | null;
      description?: StringNullableFilter<'Course'> | string | null;
      price?:
        | DecimalNullableFilter<'Course'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      isPublic?: BoolNullableFilter<'Course'> | boolean | null;
      isAccepted?: BoolNullableFilter<'Course'> | boolean | null;
      thumbnail?: StringNullableFilter<'Course'> | string | null;
      requirement?: StringNullableFilter<'Course'> | string | null;
      targetAudience?: StringNullableFilter<'Course'> | string | null;
      Cart?: CartListRelationFilter;
      Certificate?: XOR<
        CertificateNullableScalarRelationFilter,
        CertificateWhereInput
      > | null;
      CouponCourse?: CouponCourseListRelationFilter;
      User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      CourseCategory?: CourseCategoryListRelationFilter;
      CourseObjective?: CourseObjectiveListRelationFilter;
      Enrollment?: EnrollmentListRelationFilter;
      PaymentDetail?: PaymentDetailListRelationFilter;
      Review?: ReviewListRelationFilter;
      Section?: SectionListRelationFilter;
      StudyRemind?: StudyRemindListRelationFilter;
      Wishlist?: WishlistListRelationFilter;
    },
    'idCourse'
  >;

  export type CourseOrderByWithAggregationInput = {
    idCourse?: SortOrder;
    idUser?: SortOrderInput | SortOrder;
    title?: SortOrderInput | SortOrder;
    subTitle?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    price?: SortOrderInput | SortOrder;
    isPublic?: SortOrderInput | SortOrder;
    isAccepted?: SortOrderInput | SortOrder;
    thumbnail?: SortOrderInput | SortOrder;
    requirement?: SortOrderInput | SortOrder;
    targetAudience?: SortOrderInput | SortOrder;
    _count?: CourseCountOrderByAggregateInput;
    _avg?: CourseAvgOrderByAggregateInput;
    _max?: CourseMaxOrderByAggregateInput;
    _min?: CourseMinOrderByAggregateInput;
    _sum?: CourseSumOrderByAggregateInput;
  };

  export type CourseScalarWhereWithAggregatesInput = {
    AND?:
      | CourseScalarWhereWithAggregatesInput
      | CourseScalarWhereWithAggregatesInput[];
    OR?: CourseScalarWhereWithAggregatesInput[];
    NOT?:
      | CourseScalarWhereWithAggregatesInput
      | CourseScalarWhereWithAggregatesInput[];
    idCourse?: IntWithAggregatesFilter<'Course'> | number;
    idUser?: IntNullableWithAggregatesFilter<'Course'> | number | null;
    title?: StringNullableWithAggregatesFilter<'Course'> | string | null;
    subTitle?: StringNullableWithAggregatesFilter<'Course'> | string | null;
    description?: StringNullableWithAggregatesFilter<'Course'> | string | null;
    price?:
      | DecimalNullableWithAggregatesFilter<'Course'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: BoolNullableWithAggregatesFilter<'Course'> | boolean | null;
    isAccepted?: BoolNullableWithAggregatesFilter<'Course'> | boolean | null;
    thumbnail?: StringNullableWithAggregatesFilter<'Course'> | string | null;
    requirement?: StringNullableWithAggregatesFilter<'Course'> | string | null;
    targetAudience?:
      | StringNullableWithAggregatesFilter<'Course'>
      | string
      | null;
  };

  export type CourseCategoryWhereInput = {
    AND?: CourseCategoryWhereInput | CourseCategoryWhereInput[];
    OR?: CourseCategoryWhereInput[];
    NOT?: CourseCategoryWhereInput | CourseCategoryWhereInput[];
    idCourse?: IntFilter<'CourseCategory'> | number;
    idCategory?: IntFilter<'CourseCategory'> | number;
    Category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>;
    Course?: XOR<CourseScalarRelationFilter, CourseWhereInput>;
  };

  export type CourseCategoryOrderByWithRelationInput = {
    idCourse?: SortOrder;
    idCategory?: SortOrder;
    Category?: CategoryOrderByWithRelationInput;
    Course?: CourseOrderByWithRelationInput;
  };

  export type CourseCategoryWhereUniqueInput = Prisma.AtLeast<
    {
      idCourse_idCategory?: CourseCategoryIdCourseIdCategoryCompoundUniqueInput;
      AND?: CourseCategoryWhereInput | CourseCategoryWhereInput[];
      OR?: CourseCategoryWhereInput[];
      NOT?: CourseCategoryWhereInput | CourseCategoryWhereInput[];
      idCourse?: IntFilter<'CourseCategory'> | number;
      idCategory?: IntFilter<'CourseCategory'> | number;
      Category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>;
      Course?: XOR<CourseScalarRelationFilter, CourseWhereInput>;
    },
    'idCourse_idCategory'
  >;

  export type CourseCategoryOrderByWithAggregationInput = {
    idCourse?: SortOrder;
    idCategory?: SortOrder;
    _count?: CourseCategoryCountOrderByAggregateInput;
    _avg?: CourseCategoryAvgOrderByAggregateInput;
    _max?: CourseCategoryMaxOrderByAggregateInput;
    _min?: CourseCategoryMinOrderByAggregateInput;
    _sum?: CourseCategorySumOrderByAggregateInput;
  };

  export type CourseCategoryScalarWhereWithAggregatesInput = {
    AND?:
      | CourseCategoryScalarWhereWithAggregatesInput
      | CourseCategoryScalarWhereWithAggregatesInput[];
    OR?: CourseCategoryScalarWhereWithAggregatesInput[];
    NOT?:
      | CourseCategoryScalarWhereWithAggregatesInput
      | CourseCategoryScalarWhereWithAggregatesInput[];
    idCourse?: IntWithAggregatesFilter<'CourseCategory'> | number;
    idCategory?: IntWithAggregatesFilter<'CourseCategory'> | number;
  };

  export type CourseObjectiveWhereInput = {
    AND?: CourseObjectiveWhereInput | CourseObjectiveWhereInput[];
    OR?: CourseObjectiveWhereInput[];
    NOT?: CourseObjectiveWhereInput | CourseObjectiveWhereInput[];
    idCourse?: IntFilter<'CourseObjective'> | number;
    idCourseObjective?: IntFilter<'CourseObjective'> | number;
    content?: StringNullableFilter<'CourseObjective'> | string | null;
    Course?: XOR<CourseScalarRelationFilter, CourseWhereInput>;
  };

  export type CourseObjectiveOrderByWithRelationInput = {
    idCourse?: SortOrder;
    idCourseObjective?: SortOrder;
    content?: SortOrderInput | SortOrder;
    Course?: CourseOrderByWithRelationInput;
    _relevance?: CourseObjectiveOrderByRelevanceInput;
  };

  export type CourseObjectiveWhereUniqueInput = Prisma.AtLeast<
    {
      idCourse_idCourseObjective?: CourseObjectiveIdCourseIdCourseObjectiveCompoundUniqueInput;
      AND?: CourseObjectiveWhereInput | CourseObjectiveWhereInput[];
      OR?: CourseObjectiveWhereInput[];
      NOT?: CourseObjectiveWhereInput | CourseObjectiveWhereInput[];
      idCourse?: IntFilter<'CourseObjective'> | number;
      idCourseObjective?: IntFilter<'CourseObjective'> | number;
      content?: StringNullableFilter<'CourseObjective'> | string | null;
      Course?: XOR<CourseScalarRelationFilter, CourseWhereInput>;
    },
    'idCourse_idCourseObjective'
  >;

  export type CourseObjectiveOrderByWithAggregationInput = {
    idCourse?: SortOrder;
    idCourseObjective?: SortOrder;
    content?: SortOrderInput | SortOrder;
    _count?: CourseObjectiveCountOrderByAggregateInput;
    _avg?: CourseObjectiveAvgOrderByAggregateInput;
    _max?: CourseObjectiveMaxOrderByAggregateInput;
    _min?: CourseObjectiveMinOrderByAggregateInput;
    _sum?: CourseObjectiveSumOrderByAggregateInput;
  };

  export type CourseObjectiveScalarWhereWithAggregatesInput = {
    AND?:
      | CourseObjectiveScalarWhereWithAggregatesInput
      | CourseObjectiveScalarWhereWithAggregatesInput[];
    OR?: CourseObjectiveScalarWhereWithAggregatesInput[];
    NOT?:
      | CourseObjectiveScalarWhereWithAggregatesInput
      | CourseObjectiveScalarWhereWithAggregatesInput[];
    idCourse?: IntWithAggregatesFilter<'CourseObjective'> | number;
    idCourseObjective?: IntWithAggregatesFilter<'CourseObjective'> | number;
    content?:
      | StringNullableWithAggregatesFilter<'CourseObjective'>
      | string
      | null;
  };

  export type EnrollmentWhereInput = {
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[];
    OR?: EnrollmentWhereInput[];
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[];
    idUser?: IntFilter<'Enrollment'> | number;
    idCourse?: IntFilter<'Enrollment'> | number;
    dateRegister?: DateTimeNullableFilter<'Enrollment'> | Date | string | null;
    finishStatus?: BoolNullableFilter<'Enrollment'> | boolean | null;
    progress?:
      | DecimalNullableFilter<'Enrollment'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    Course?: XOR<CourseScalarRelationFilter, CourseWhereInput>;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type EnrollmentOrderByWithRelationInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
    dateRegister?: SortOrderInput | SortOrder;
    finishStatus?: SortOrderInput | SortOrder;
    progress?: SortOrderInput | SortOrder;
    Course?: CourseOrderByWithRelationInput;
    User?: UserOrderByWithRelationInput;
  };

  export type EnrollmentWhereUniqueInput = Prisma.AtLeast<
    {
      idUser_idCourse?: EnrollmentIdUserIdCourseCompoundUniqueInput;
      AND?: EnrollmentWhereInput | EnrollmentWhereInput[];
      OR?: EnrollmentWhereInput[];
      NOT?: EnrollmentWhereInput | EnrollmentWhereInput[];
      idUser?: IntFilter<'Enrollment'> | number;
      idCourse?: IntFilter<'Enrollment'> | number;
      dateRegister?:
        | DateTimeNullableFilter<'Enrollment'>
        | Date
        | string
        | null;
      finishStatus?: BoolNullableFilter<'Enrollment'> | boolean | null;
      progress?:
        | DecimalNullableFilter<'Enrollment'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      Course?: XOR<CourseScalarRelationFilter, CourseWhereInput>;
      User?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'idUser_idCourse'
  >;

  export type EnrollmentOrderByWithAggregationInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
    dateRegister?: SortOrderInput | SortOrder;
    finishStatus?: SortOrderInput | SortOrder;
    progress?: SortOrderInput | SortOrder;
    _count?: EnrollmentCountOrderByAggregateInput;
    _avg?: EnrollmentAvgOrderByAggregateInput;
    _max?: EnrollmentMaxOrderByAggregateInput;
    _min?: EnrollmentMinOrderByAggregateInput;
    _sum?: EnrollmentSumOrderByAggregateInput;
  };

  export type EnrollmentScalarWhereWithAggregatesInput = {
    AND?:
      | EnrollmentScalarWhereWithAggregatesInput
      | EnrollmentScalarWhereWithAggregatesInput[];
    OR?: EnrollmentScalarWhereWithAggregatesInput[];
    NOT?:
      | EnrollmentScalarWhereWithAggregatesInput
      | EnrollmentScalarWhereWithAggregatesInput[];
    idUser?: IntWithAggregatesFilter<'Enrollment'> | number;
    idCourse?: IntWithAggregatesFilter<'Enrollment'> | number;
    dateRegister?:
      | DateTimeNullableWithAggregatesFilter<'Enrollment'>
      | Date
      | string
      | null;
    finishStatus?:
      | BoolNullableWithAggregatesFilter<'Enrollment'>
      | boolean
      | null;
    progress?:
      | DecimalNullableWithAggregatesFilter<'Enrollment'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type FollowWhereInput = {
    AND?: FollowWhereInput | FollowWhereInput[];
    OR?: FollowWhereInput[];
    NOT?: FollowWhereInput | FollowWhereInput[];
    idFollower?: IntFilter<'Follow'> | number;
    idFollowing?: IntFilter<'Follow'> | number;
    User_Follow_idFollowerToUser?: XOR<
      UserScalarRelationFilter,
      UserWhereInput
    >;
    User_Follow_idFollowingToUser?: XOR<
      UserScalarRelationFilter,
      UserWhereInput
    >;
  };

  export type FollowOrderByWithRelationInput = {
    idFollower?: SortOrder;
    idFollowing?: SortOrder;
    User_Follow_idFollowerToUser?: UserOrderByWithRelationInput;
    User_Follow_idFollowingToUser?: UserOrderByWithRelationInput;
  };

  export type FollowWhereUniqueInput = Prisma.AtLeast<
    {
      idFollower_idFollowing?: FollowIdFollowerIdFollowingCompoundUniqueInput;
      AND?: FollowWhereInput | FollowWhereInput[];
      OR?: FollowWhereInput[];
      NOT?: FollowWhereInput | FollowWhereInput[];
      idFollower?: IntFilter<'Follow'> | number;
      idFollowing?: IntFilter<'Follow'> | number;
      User_Follow_idFollowerToUser?: XOR<
        UserScalarRelationFilter,
        UserWhereInput
      >;
      User_Follow_idFollowingToUser?: XOR<
        UserScalarRelationFilter,
        UserWhereInput
      >;
    },
    'idFollower_idFollowing'
  >;

  export type FollowOrderByWithAggregationInput = {
    idFollower?: SortOrder;
    idFollowing?: SortOrder;
    _count?: FollowCountOrderByAggregateInput;
    _avg?: FollowAvgOrderByAggregateInput;
    _max?: FollowMaxOrderByAggregateInput;
    _min?: FollowMinOrderByAggregateInput;
    _sum?: FollowSumOrderByAggregateInput;
  };

  export type FollowScalarWhereWithAggregatesInput = {
    AND?:
      | FollowScalarWhereWithAggregatesInput
      | FollowScalarWhereWithAggregatesInput[];
    OR?: FollowScalarWhereWithAggregatesInput[];
    NOT?:
      | FollowScalarWhereWithAggregatesInput
      | FollowScalarWhereWithAggregatesInput[];
    idFollower?: IntWithAggregatesFilter<'Follow'> | number;
    idFollowing?: IntWithAggregatesFilter<'Follow'> | number;
  };

  export type LectureWhereInput = {
    AND?: LectureWhereInput | LectureWhereInput[];
    OR?: LectureWhereInput[];
    NOT?: LectureWhereInput | LectureWhereInput[];
    idCourse?: IntFilter<'Lecture'> | number;
    idSection?: IntFilter<'Lecture'> | number;
    idLecture?: IntFilter<'Lecture'> | number;
    nameLecture?: StringNullableFilter<'Lecture'> | string | null;
    isDone?: BoolNullableFilter<'Lecture'> | boolean | null;
    Section?: XOR<SectionScalarRelationFilter, SectionWhereInput>;
    Note?: NoteListRelationFilter;
    Question?: QuestionListRelationFilter;
  };

  export type LectureOrderByWithRelationInput = {
    idCourse?: SortOrder;
    idSection?: SortOrder;
    idLecture?: SortOrder;
    nameLecture?: SortOrderInput | SortOrder;
    isDone?: SortOrderInput | SortOrder;
    Section?: SectionOrderByWithRelationInput;
    Note?: NoteOrderByRelationAggregateInput;
    Question?: QuestionOrderByRelationAggregateInput;
    _relevance?: LectureOrderByRelevanceInput;
  };

  export type LectureWhereUniqueInput = Prisma.AtLeast<
    {
      idCourse_idSection_idLecture?: LectureIdCourseIdSectionIdLectureCompoundUniqueInput;
      AND?: LectureWhereInput | LectureWhereInput[];
      OR?: LectureWhereInput[];
      NOT?: LectureWhereInput | LectureWhereInput[];
      idCourse?: IntFilter<'Lecture'> | number;
      idSection?: IntFilter<'Lecture'> | number;
      idLecture?: IntFilter<'Lecture'> | number;
      nameLecture?: StringNullableFilter<'Lecture'> | string | null;
      isDone?: BoolNullableFilter<'Lecture'> | boolean | null;
      Section?: XOR<SectionScalarRelationFilter, SectionWhereInput>;
      Note?: NoteListRelationFilter;
      Question?: QuestionListRelationFilter;
    },
    'idCourse_idSection_idLecture'
  >;

  export type LectureOrderByWithAggregationInput = {
    idCourse?: SortOrder;
    idSection?: SortOrder;
    idLecture?: SortOrder;
    nameLecture?: SortOrderInput | SortOrder;
    isDone?: SortOrderInput | SortOrder;
    _count?: LectureCountOrderByAggregateInput;
    _avg?: LectureAvgOrderByAggregateInput;
    _max?: LectureMaxOrderByAggregateInput;
    _min?: LectureMinOrderByAggregateInput;
    _sum?: LectureSumOrderByAggregateInput;
  };

  export type LectureScalarWhereWithAggregatesInput = {
    AND?:
      | LectureScalarWhereWithAggregatesInput
      | LectureScalarWhereWithAggregatesInput[];
    OR?: LectureScalarWhereWithAggregatesInput[];
    NOT?:
      | LectureScalarWhereWithAggregatesInput
      | LectureScalarWhereWithAggregatesInput[];
    idCourse?: IntWithAggregatesFilter<'Lecture'> | number;
    idSection?: IntWithAggregatesFilter<'Lecture'> | number;
    idLecture?: IntWithAggregatesFilter<'Lecture'> | number;
    nameLecture?: StringNullableWithAggregatesFilter<'Lecture'> | string | null;
    isDone?: BoolNullableWithAggregatesFilter<'Lecture'> | boolean | null;
  };

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[];
    OR?: MessageWhereInput[];
    NOT?: MessageWhereInput | MessageWhereInput[];
    idMessage?: IntFilter<'Message'> | number;
    idUserSender?: IntNullableFilter<'Message'> | number | null;
    idUserReceiver?: IntNullableFilter<'Message'> | number | null;
    message?: StringNullableFilter<'Message'> | string | null;
    timeSend?: DateTimeNullableFilter<'Message'> | Date | string | null;
    User_Message_idUserReceiverToUser?: XOR<
      UserNullableScalarRelationFilter,
      UserWhereInput
    > | null;
    User_Message_idUserSenderToUser?: XOR<
      UserNullableScalarRelationFilter,
      UserWhereInput
    > | null;
  };

  export type MessageOrderByWithRelationInput = {
    idMessage?: SortOrder;
    idUserSender?: SortOrderInput | SortOrder;
    idUserReceiver?: SortOrderInput | SortOrder;
    message?: SortOrderInput | SortOrder;
    timeSend?: SortOrderInput | SortOrder;
    User_Message_idUserReceiverToUser?: UserOrderByWithRelationInput;
    User_Message_idUserSenderToUser?: UserOrderByWithRelationInput;
    _relevance?: MessageOrderByRelevanceInput;
  };

  export type MessageWhereUniqueInput = Prisma.AtLeast<
    {
      idMessage?: number;
      AND?: MessageWhereInput | MessageWhereInput[];
      OR?: MessageWhereInput[];
      NOT?: MessageWhereInput | MessageWhereInput[];
      idUserSender?: IntNullableFilter<'Message'> | number | null;
      idUserReceiver?: IntNullableFilter<'Message'> | number | null;
      message?: StringNullableFilter<'Message'> | string | null;
      timeSend?: DateTimeNullableFilter<'Message'> | Date | string | null;
      User_Message_idUserReceiverToUser?: XOR<
        UserNullableScalarRelationFilter,
        UserWhereInput
      > | null;
      User_Message_idUserSenderToUser?: XOR<
        UserNullableScalarRelationFilter,
        UserWhereInput
      > | null;
    },
    'idMessage'
  >;

  export type MessageOrderByWithAggregationInput = {
    idMessage?: SortOrder;
    idUserSender?: SortOrderInput | SortOrder;
    idUserReceiver?: SortOrderInput | SortOrder;
    message?: SortOrderInput | SortOrder;
    timeSend?: SortOrderInput | SortOrder;
    _count?: MessageCountOrderByAggregateInput;
    _avg?: MessageAvgOrderByAggregateInput;
    _max?: MessageMaxOrderByAggregateInput;
    _min?: MessageMinOrderByAggregateInput;
    _sum?: MessageSumOrderByAggregateInput;
  };

  export type MessageScalarWhereWithAggregatesInput = {
    AND?:
      | MessageScalarWhereWithAggregatesInput
      | MessageScalarWhereWithAggregatesInput[];
    OR?: MessageScalarWhereWithAggregatesInput[];
    NOT?:
      | MessageScalarWhereWithAggregatesInput
      | MessageScalarWhereWithAggregatesInput[];
    idMessage?: IntWithAggregatesFilter<'Message'> | number;
    idUserSender?: IntNullableWithAggregatesFilter<'Message'> | number | null;
    idUserReceiver?: IntNullableWithAggregatesFilter<'Message'> | number | null;
    message?: StringNullableWithAggregatesFilter<'Message'> | string | null;
    timeSend?:
      | DateTimeNullableWithAggregatesFilter<'Message'>
      | Date
      | string
      | null;
  };

  export type NoteWhereInput = {
    AND?: NoteWhereInput | NoteWhereInput[];
    OR?: NoteWhereInput[];
    NOT?: NoteWhereInput | NoteWhereInput[];
    idNote?: IntFilter<'Note'> | number;
    timeNote?: DateTimeNullableFilter<'Note'> | Date | string | null;
    note?: StringNullableFilter<'Note'> | string | null;
    idUser?: IntNullableFilter<'Note'> | number | null;
    idCourse?: IntNullableFilter<'Note'> | number | null;
    idSection?: IntNullableFilter<'Note'> | number | null;
    idLecture?: IntNullableFilter<'Note'> | number | null;
    Lecture?: XOR<
      LectureNullableScalarRelationFilter,
      LectureWhereInput
    > | null;
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type NoteOrderByWithRelationInput = {
    idNote?: SortOrder;
    timeNote?: SortOrderInput | SortOrder;
    note?: SortOrderInput | SortOrder;
    idUser?: SortOrderInput | SortOrder;
    idCourse?: SortOrderInput | SortOrder;
    idSection?: SortOrderInput | SortOrder;
    idLecture?: SortOrderInput | SortOrder;
    Lecture?: LectureOrderByWithRelationInput;
    User?: UserOrderByWithRelationInput;
    _relevance?: NoteOrderByRelevanceInput;
  };

  export type NoteWhereUniqueInput = Prisma.AtLeast<
    {
      idNote?: number;
      AND?: NoteWhereInput | NoteWhereInput[];
      OR?: NoteWhereInput[];
      NOT?: NoteWhereInput | NoteWhereInput[];
      timeNote?: DateTimeNullableFilter<'Note'> | Date | string | null;
      note?: StringNullableFilter<'Note'> | string | null;
      idUser?: IntNullableFilter<'Note'> | number | null;
      idCourse?: IntNullableFilter<'Note'> | number | null;
      idSection?: IntNullableFilter<'Note'> | number | null;
      idLecture?: IntNullableFilter<'Note'> | number | null;
      Lecture?: XOR<
        LectureNullableScalarRelationFilter,
        LectureWhereInput
      > | null;
      User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    'idNote'
  >;

  export type NoteOrderByWithAggregationInput = {
    idNote?: SortOrder;
    timeNote?: SortOrderInput | SortOrder;
    note?: SortOrderInput | SortOrder;
    idUser?: SortOrderInput | SortOrder;
    idCourse?: SortOrderInput | SortOrder;
    idSection?: SortOrderInput | SortOrder;
    idLecture?: SortOrderInput | SortOrder;
    _count?: NoteCountOrderByAggregateInput;
    _avg?: NoteAvgOrderByAggregateInput;
    _max?: NoteMaxOrderByAggregateInput;
    _min?: NoteMinOrderByAggregateInput;
    _sum?: NoteSumOrderByAggregateInput;
  };

  export type NoteScalarWhereWithAggregatesInput = {
    AND?:
      | NoteScalarWhereWithAggregatesInput
      | NoteScalarWhereWithAggregatesInput[];
    OR?: NoteScalarWhereWithAggregatesInput[];
    NOT?:
      | NoteScalarWhereWithAggregatesInput
      | NoteScalarWhereWithAggregatesInput[];
    idNote?: IntWithAggregatesFilter<'Note'> | number;
    timeNote?:
      | DateTimeNullableWithAggregatesFilter<'Note'>
      | Date
      | string
      | null;
    note?: StringNullableWithAggregatesFilter<'Note'> | string | null;
    idUser?: IntNullableWithAggregatesFilter<'Note'> | number | null;
    idCourse?: IntNullableWithAggregatesFilter<'Note'> | number | null;
    idSection?: IntNullableWithAggregatesFilter<'Note'> | number | null;
    idLecture?: IntNullableWithAggregatesFilter<'Note'> | number | null;
  };

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[];
    OR?: NotificationWhereInput[];
    NOT?: NotificationWhereInput | NotificationWhereInput[];
    idNotification?: IntFilter<'Notification'> | number;
    contentNotification?: StringNullableFilter<'Notification'> | string | null;
    idUser?: IntNullableFilter<'Notification'> | number | null;
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    NotificationReceiver?: NotificationReceiverListRelationFilter;
  };

  export type NotificationOrderByWithRelationInput = {
    idNotification?: SortOrder;
    contentNotification?: SortOrderInput | SortOrder;
    idUser?: SortOrderInput | SortOrder;
    User?: UserOrderByWithRelationInput;
    NotificationReceiver?: NotificationReceiverOrderByRelationAggregateInput;
    _relevance?: NotificationOrderByRelevanceInput;
  };

  export type NotificationWhereUniqueInput = Prisma.AtLeast<
    {
      idNotification?: number;
      AND?: NotificationWhereInput | NotificationWhereInput[];
      OR?: NotificationWhereInput[];
      NOT?: NotificationWhereInput | NotificationWhereInput[];
      contentNotification?:
        | StringNullableFilter<'Notification'>
        | string
        | null;
      idUser?: IntNullableFilter<'Notification'> | number | null;
      User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      NotificationReceiver?: NotificationReceiverListRelationFilter;
    },
    'idNotification'
  >;

  export type NotificationOrderByWithAggregationInput = {
    idNotification?: SortOrder;
    contentNotification?: SortOrderInput | SortOrder;
    idUser?: SortOrderInput | SortOrder;
    _count?: NotificationCountOrderByAggregateInput;
    _avg?: NotificationAvgOrderByAggregateInput;
    _max?: NotificationMaxOrderByAggregateInput;
    _min?: NotificationMinOrderByAggregateInput;
    _sum?: NotificationSumOrderByAggregateInput;
  };

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?:
      | NotificationScalarWhereWithAggregatesInput
      | NotificationScalarWhereWithAggregatesInput[];
    OR?: NotificationScalarWhereWithAggregatesInput[];
    NOT?:
      | NotificationScalarWhereWithAggregatesInput
      | NotificationScalarWhereWithAggregatesInput[];
    idNotification?: IntWithAggregatesFilter<'Notification'> | number;
    contentNotification?:
      | StringNullableWithAggregatesFilter<'Notification'>
      | string
      | null;
    idUser?: IntNullableWithAggregatesFilter<'Notification'> | number | null;
  };

  export type NotificationReceiverWhereInput = {
    AND?: NotificationReceiverWhereInput | NotificationReceiverWhereInput[];
    OR?: NotificationReceiverWhereInput[];
    NOT?: NotificationReceiverWhereInput | NotificationReceiverWhereInput[];
    idNotification?: IntFilter<'NotificationReceiver'> | number;
    idUser?: IntFilter<'NotificationReceiver'> | number;
    timeGetNotification?:
      | DateTimeNullableFilter<'NotificationReceiver'>
      | Date
      | string
      | null;
    Notification?: XOR<
      NotificationScalarRelationFilter,
      NotificationWhereInput
    >;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type NotificationReceiverOrderByWithRelationInput = {
    idNotification?: SortOrder;
    idUser?: SortOrder;
    timeGetNotification?: SortOrderInput | SortOrder;
    Notification?: NotificationOrderByWithRelationInput;
    User?: UserOrderByWithRelationInput;
  };

  export type NotificationReceiverWhereUniqueInput = Prisma.AtLeast<
    {
      idNotification_idUser?: NotificationReceiverIdNotificationIdUserCompoundUniqueInput;
      AND?: NotificationReceiverWhereInput | NotificationReceiverWhereInput[];
      OR?: NotificationReceiverWhereInput[];
      NOT?: NotificationReceiverWhereInput | NotificationReceiverWhereInput[];
      idNotification?: IntFilter<'NotificationReceiver'> | number;
      idUser?: IntFilter<'NotificationReceiver'> | number;
      timeGetNotification?:
        | DateTimeNullableFilter<'NotificationReceiver'>
        | Date
        | string
        | null;
      Notification?: XOR<
        NotificationScalarRelationFilter,
        NotificationWhereInput
      >;
      User?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'idNotification_idUser'
  >;

  export type NotificationReceiverOrderByWithAggregationInput = {
    idNotification?: SortOrder;
    idUser?: SortOrder;
    timeGetNotification?: SortOrderInput | SortOrder;
    _count?: NotificationReceiverCountOrderByAggregateInput;
    _avg?: NotificationReceiverAvgOrderByAggregateInput;
    _max?: NotificationReceiverMaxOrderByAggregateInput;
    _min?: NotificationReceiverMinOrderByAggregateInput;
    _sum?: NotificationReceiverSumOrderByAggregateInput;
  };

  export type NotificationReceiverScalarWhereWithAggregatesInput = {
    AND?:
      | NotificationReceiverScalarWhereWithAggregatesInput
      | NotificationReceiverScalarWhereWithAggregatesInput[];
    OR?: NotificationReceiverScalarWhereWithAggregatesInput[];
    NOT?:
      | NotificationReceiverScalarWhereWithAggregatesInput
      | NotificationReceiverScalarWhereWithAggregatesInput[];
    idNotification?: IntWithAggregatesFilter<'NotificationReceiver'> | number;
    idUser?: IntWithAggregatesFilter<'NotificationReceiver'> | number;
    timeGetNotification?:
      | DateTimeNullableWithAggregatesFilter<'NotificationReceiver'>
      | Date
      | string
      | null;
  };

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[];
    OR?: PaymentWhereInput[];
    NOT?: PaymentWhereInput | PaymentWhereInput[];
    idPayment?: IntFilter<'Payment'> | number;
    timePayment?: DateTimeNullableFilter<'Payment'> | Date | string | null;
    totalPrice?:
      | DecimalNullableFilter<'Payment'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    idUser?: IntNullableFilter<'Payment'> | number | null;
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    PaymentDetail?: PaymentDetailListRelationFilter;
  };

  export type PaymentOrderByWithRelationInput = {
    idPayment?: SortOrder;
    timePayment?: SortOrderInput | SortOrder;
    totalPrice?: SortOrderInput | SortOrder;
    idUser?: SortOrderInput | SortOrder;
    User?: UserOrderByWithRelationInput;
    PaymentDetail?: PaymentDetailOrderByRelationAggregateInput;
  };

  export type PaymentWhereUniqueInput = Prisma.AtLeast<
    {
      idPayment?: number;
      AND?: PaymentWhereInput | PaymentWhereInput[];
      OR?: PaymentWhereInput[];
      NOT?: PaymentWhereInput | PaymentWhereInput[];
      timePayment?: DateTimeNullableFilter<'Payment'> | Date | string | null;
      totalPrice?:
        | DecimalNullableFilter<'Payment'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      idUser?: IntNullableFilter<'Payment'> | number | null;
      User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      PaymentDetail?: PaymentDetailListRelationFilter;
    },
    'idPayment'
  >;

  export type PaymentOrderByWithAggregationInput = {
    idPayment?: SortOrder;
    timePayment?: SortOrderInput | SortOrder;
    totalPrice?: SortOrderInput | SortOrder;
    idUser?: SortOrderInput | SortOrder;
    _count?: PaymentCountOrderByAggregateInput;
    _avg?: PaymentAvgOrderByAggregateInput;
    _max?: PaymentMaxOrderByAggregateInput;
    _min?: PaymentMinOrderByAggregateInput;
    _sum?: PaymentSumOrderByAggregateInput;
  };

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?:
      | PaymentScalarWhereWithAggregatesInput
      | PaymentScalarWhereWithAggregatesInput[];
    OR?: PaymentScalarWhereWithAggregatesInput[];
    NOT?:
      | PaymentScalarWhereWithAggregatesInput
      | PaymentScalarWhereWithAggregatesInput[];
    idPayment?: IntWithAggregatesFilter<'Payment'> | number;
    timePayment?:
      | DateTimeNullableWithAggregatesFilter<'Payment'>
      | Date
      | string
      | null;
    totalPrice?:
      | DecimalNullableWithAggregatesFilter<'Payment'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    idUser?: IntNullableWithAggregatesFilter<'Payment'> | number | null;
  };

  export type PaymentDetailWhereInput = {
    AND?: PaymentDetailWhereInput | PaymentDetailWhereInput[];
    OR?: PaymentDetailWhereInput[];
    NOT?: PaymentDetailWhereInput | PaymentDetailWhereInput[];
    idPayment?: IntFilter<'PaymentDetail'> | number;
    idCourse?: IntFilter<'PaymentDetail'> | number;
    price?:
      | DecimalNullableFilter<'PaymentDetail'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    Course?: XOR<CourseScalarRelationFilter, CourseWhereInput>;
    Payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>;
  };

  export type PaymentDetailOrderByWithRelationInput = {
    idPayment?: SortOrder;
    idCourse?: SortOrder;
    price?: SortOrderInput | SortOrder;
    Course?: CourseOrderByWithRelationInput;
    Payment?: PaymentOrderByWithRelationInput;
  };

  export type PaymentDetailWhereUniqueInput = Prisma.AtLeast<
    {
      idPayment_idCourse?: PaymentDetailIdPaymentIdCourseCompoundUniqueInput;
      AND?: PaymentDetailWhereInput | PaymentDetailWhereInput[];
      OR?: PaymentDetailWhereInput[];
      NOT?: PaymentDetailWhereInput | PaymentDetailWhereInput[];
      idPayment?: IntFilter<'PaymentDetail'> | number;
      idCourse?: IntFilter<'PaymentDetail'> | number;
      price?:
        | DecimalNullableFilter<'PaymentDetail'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      Course?: XOR<CourseScalarRelationFilter, CourseWhereInput>;
      Payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>;
    },
    'idPayment_idCourse'
  >;

  export type PaymentDetailOrderByWithAggregationInput = {
    idPayment?: SortOrder;
    idCourse?: SortOrder;
    price?: SortOrderInput | SortOrder;
    _count?: PaymentDetailCountOrderByAggregateInput;
    _avg?: PaymentDetailAvgOrderByAggregateInput;
    _max?: PaymentDetailMaxOrderByAggregateInput;
    _min?: PaymentDetailMinOrderByAggregateInput;
    _sum?: PaymentDetailSumOrderByAggregateInput;
  };

  export type PaymentDetailScalarWhereWithAggregatesInput = {
    AND?:
      | PaymentDetailScalarWhereWithAggregatesInput
      | PaymentDetailScalarWhereWithAggregatesInput[];
    OR?: PaymentDetailScalarWhereWithAggregatesInput[];
    NOT?:
      | PaymentDetailScalarWhereWithAggregatesInput
      | PaymentDetailScalarWhereWithAggregatesInput[];
    idPayment?: IntWithAggregatesFilter<'PaymentDetail'> | number;
    idCourse?: IntWithAggregatesFilter<'PaymentDetail'> | number;
    price?:
      | DecimalNullableWithAggregatesFilter<'PaymentDetail'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type QuestionWhereInput = {
    AND?: QuestionWhereInput | QuestionWhereInput[];
    OR?: QuestionWhereInput[];
    NOT?: QuestionWhereInput | QuestionWhereInput[];
    idQuestion?: IntFilter<'Question'> | number;
    idUser?: IntNullableFilter<'Question'> | number | null;
    idCourse?: IntNullableFilter<'Question'> | number | null;
    idSection?: IntNullableFilter<'Question'> | number | null;
    idLecture?: IntNullableFilter<'Question'> | number | null;
    contentQuestion?: StringNullableFilter<'Question'> | string | null;
    Answer?: AnswerListRelationFilter;
    Lecture?: XOR<
      LectureNullableScalarRelationFilter,
      LectureWhereInput
    > | null;
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type QuestionOrderByWithRelationInput = {
    idQuestion?: SortOrder;
    idUser?: SortOrderInput | SortOrder;
    idCourse?: SortOrderInput | SortOrder;
    idSection?: SortOrderInput | SortOrder;
    idLecture?: SortOrderInput | SortOrder;
    contentQuestion?: SortOrderInput | SortOrder;
    Answer?: AnswerOrderByRelationAggregateInput;
    Lecture?: LectureOrderByWithRelationInput;
    User?: UserOrderByWithRelationInput;
    _relevance?: QuestionOrderByRelevanceInput;
  };

  export type QuestionWhereUniqueInput = Prisma.AtLeast<
    {
      idQuestion?: number;
      AND?: QuestionWhereInput | QuestionWhereInput[];
      OR?: QuestionWhereInput[];
      NOT?: QuestionWhereInput | QuestionWhereInput[];
      idUser?: IntNullableFilter<'Question'> | number | null;
      idCourse?: IntNullableFilter<'Question'> | number | null;
      idSection?: IntNullableFilter<'Question'> | number | null;
      idLecture?: IntNullableFilter<'Question'> | number | null;
      contentQuestion?: StringNullableFilter<'Question'> | string | null;
      Answer?: AnswerListRelationFilter;
      Lecture?: XOR<
        LectureNullableScalarRelationFilter,
        LectureWhereInput
      > | null;
      User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    'idQuestion'
  >;

  export type QuestionOrderByWithAggregationInput = {
    idQuestion?: SortOrder;
    idUser?: SortOrderInput | SortOrder;
    idCourse?: SortOrderInput | SortOrder;
    idSection?: SortOrderInput | SortOrder;
    idLecture?: SortOrderInput | SortOrder;
    contentQuestion?: SortOrderInput | SortOrder;
    _count?: QuestionCountOrderByAggregateInput;
    _avg?: QuestionAvgOrderByAggregateInput;
    _max?: QuestionMaxOrderByAggregateInput;
    _min?: QuestionMinOrderByAggregateInput;
    _sum?: QuestionSumOrderByAggregateInput;
  };

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?:
      | QuestionScalarWhereWithAggregatesInput
      | QuestionScalarWhereWithAggregatesInput[];
    OR?: QuestionScalarWhereWithAggregatesInput[];
    NOT?:
      | QuestionScalarWhereWithAggregatesInput
      | QuestionScalarWhereWithAggregatesInput[];
    idQuestion?: IntWithAggregatesFilter<'Question'> | number;
    idUser?: IntNullableWithAggregatesFilter<'Question'> | number | null;
    idCourse?: IntNullableWithAggregatesFilter<'Question'> | number | null;
    idSection?: IntNullableWithAggregatesFilter<'Question'> | number | null;
    idLecture?: IntNullableWithAggregatesFilter<'Question'> | number | null;
    contentQuestion?:
      | StringNullableWithAggregatesFilter<'Question'>
      | string
      | null;
  };

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[];
    OR?: ReportWhereInput[];
    NOT?: ReportWhereInput | ReportWhereInput[];
    idReport?: IntFilter<'Report'> | number;
    idUser?: IntNullableFilter<'Report'> | number | null;
    contentReport?: StringNullableFilter<'Report'> | string | null;
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type ReportOrderByWithRelationInput = {
    idReport?: SortOrder;
    idUser?: SortOrderInput | SortOrder;
    contentReport?: SortOrderInput | SortOrder;
    User?: UserOrderByWithRelationInput;
    _relevance?: ReportOrderByRelevanceInput;
  };

  export type ReportWhereUniqueInput = Prisma.AtLeast<
    {
      idReport?: number;
      AND?: ReportWhereInput | ReportWhereInput[];
      OR?: ReportWhereInput[];
      NOT?: ReportWhereInput | ReportWhereInput[];
      idUser?: IntNullableFilter<'Report'> | number | null;
      contentReport?: StringNullableFilter<'Report'> | string | null;
      User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    'idReport'
  >;

  export type ReportOrderByWithAggregationInput = {
    idReport?: SortOrder;
    idUser?: SortOrderInput | SortOrder;
    contentReport?: SortOrderInput | SortOrder;
    _count?: ReportCountOrderByAggregateInput;
    _avg?: ReportAvgOrderByAggregateInput;
    _max?: ReportMaxOrderByAggregateInput;
    _min?: ReportMinOrderByAggregateInput;
    _sum?: ReportSumOrderByAggregateInput;
  };

  export type ReportScalarWhereWithAggregatesInput = {
    AND?:
      | ReportScalarWhereWithAggregatesInput
      | ReportScalarWhereWithAggregatesInput[];
    OR?: ReportScalarWhereWithAggregatesInput[];
    NOT?:
      | ReportScalarWhereWithAggregatesInput
      | ReportScalarWhereWithAggregatesInput[];
    idReport?: IntWithAggregatesFilter<'Report'> | number;
    idUser?: IntNullableWithAggregatesFilter<'Report'> | number | null;
    contentReport?:
      | StringNullableWithAggregatesFilter<'Report'>
      | string
      | null;
  };

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[];
    OR?: ReviewWhereInput[];
    NOT?: ReviewWhereInput | ReviewWhereInput[];
    idReview?: IntFilter<'Review'> | number;
    idUser?: IntNullableFilter<'Review'> | number | null;
    idCourse?: IntNullableFilter<'Review'> | number | null;
    rating?: IntNullableFilter<'Review'> | number | null;
    review?: StringNullableFilter<'Review'> | string | null;
    Course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null;
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type ReviewOrderByWithRelationInput = {
    idReview?: SortOrder;
    idUser?: SortOrderInput | SortOrder;
    idCourse?: SortOrderInput | SortOrder;
    rating?: SortOrderInput | SortOrder;
    review?: SortOrderInput | SortOrder;
    Course?: CourseOrderByWithRelationInput;
    User?: UserOrderByWithRelationInput;
    _relevance?: ReviewOrderByRelevanceInput;
  };

  export type ReviewWhereUniqueInput = Prisma.AtLeast<
    {
      idReview?: number;
      AND?: ReviewWhereInput | ReviewWhereInput[];
      OR?: ReviewWhereInput[];
      NOT?: ReviewWhereInput | ReviewWhereInput[];
      idUser?: IntNullableFilter<'Review'> | number | null;
      idCourse?: IntNullableFilter<'Review'> | number | null;
      rating?: IntNullableFilter<'Review'> | number | null;
      review?: StringNullableFilter<'Review'> | string | null;
      Course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null;
      User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    'idReview'
  >;

  export type ReviewOrderByWithAggregationInput = {
    idReview?: SortOrder;
    idUser?: SortOrderInput | SortOrder;
    idCourse?: SortOrderInput | SortOrder;
    rating?: SortOrderInput | SortOrder;
    review?: SortOrderInput | SortOrder;
    _count?: ReviewCountOrderByAggregateInput;
    _avg?: ReviewAvgOrderByAggregateInput;
    _max?: ReviewMaxOrderByAggregateInput;
    _min?: ReviewMinOrderByAggregateInput;
    _sum?: ReviewSumOrderByAggregateInput;
  };

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?:
      | ReviewScalarWhereWithAggregatesInput
      | ReviewScalarWhereWithAggregatesInput[];
    OR?: ReviewScalarWhereWithAggregatesInput[];
    NOT?:
      | ReviewScalarWhereWithAggregatesInput
      | ReviewScalarWhereWithAggregatesInput[];
    idReview?: IntWithAggregatesFilter<'Review'> | number;
    idUser?: IntNullableWithAggregatesFilter<'Review'> | number | null;
    idCourse?: IntNullableWithAggregatesFilter<'Review'> | number | null;
    rating?: IntNullableWithAggregatesFilter<'Review'> | number | null;
    review?: StringNullableWithAggregatesFilter<'Review'> | string | null;
  };

  export type SectionWhereInput = {
    AND?: SectionWhereInput | SectionWhereInput[];
    OR?: SectionWhereInput[];
    NOT?: SectionWhereInput | SectionWhereInput[];
    idCourse?: IntFilter<'Section'> | number;
    idSection?: IntFilter<'Section'> | number;
    nameSection?: StringNullableFilter<'Section'> | string | null;
    Lecture?: LectureListRelationFilter;
    Course?: XOR<CourseScalarRelationFilter, CourseWhereInput>;
  };

  export type SectionOrderByWithRelationInput = {
    idCourse?: SortOrder;
    idSection?: SortOrder;
    nameSection?: SortOrderInput | SortOrder;
    Lecture?: LectureOrderByRelationAggregateInput;
    Course?: CourseOrderByWithRelationInput;
    _relevance?: SectionOrderByRelevanceInput;
  };

  export type SectionWhereUniqueInput = Prisma.AtLeast<
    {
      idCourse_idSection?: SectionIdCourseIdSectionCompoundUniqueInput;
      AND?: SectionWhereInput | SectionWhereInput[];
      OR?: SectionWhereInput[];
      NOT?: SectionWhereInput | SectionWhereInput[];
      idCourse?: IntFilter<'Section'> | number;
      idSection?: IntFilter<'Section'> | number;
      nameSection?: StringNullableFilter<'Section'> | string | null;
      Lecture?: LectureListRelationFilter;
      Course?: XOR<CourseScalarRelationFilter, CourseWhereInput>;
    },
    'idCourse_idSection'
  >;

  export type SectionOrderByWithAggregationInput = {
    idCourse?: SortOrder;
    idSection?: SortOrder;
    nameSection?: SortOrderInput | SortOrder;
    _count?: SectionCountOrderByAggregateInput;
    _avg?: SectionAvgOrderByAggregateInput;
    _max?: SectionMaxOrderByAggregateInput;
    _min?: SectionMinOrderByAggregateInput;
    _sum?: SectionSumOrderByAggregateInput;
  };

  export type SectionScalarWhereWithAggregatesInput = {
    AND?:
      | SectionScalarWhereWithAggregatesInput
      | SectionScalarWhereWithAggregatesInput[];
    OR?: SectionScalarWhereWithAggregatesInput[];
    NOT?:
      | SectionScalarWhereWithAggregatesInput
      | SectionScalarWhereWithAggregatesInput[];
    idCourse?: IntWithAggregatesFilter<'Section'> | number;
    idSection?: IntWithAggregatesFilter<'Section'> | number;
    nameSection?: StringNullableWithAggregatesFilter<'Section'> | string | null;
  };

  export type StudyRemindWhereInput = {
    AND?: StudyRemindWhereInput | StudyRemindWhereInput[];
    OR?: StudyRemindWhereInput[];
    NOT?: StudyRemindWhereInput | StudyRemindWhereInput[];
    idStudyRemind?: IntFilter<'StudyRemind'> | number;
    idUser?: IntNullableFilter<'StudyRemind'> | number | null;
    idCourse?: IntNullableFilter<'StudyRemind'> | number | null;
    timeRemind?: DateTimeNullableFilter<'StudyRemind'> | Date | string | null;
    typeRemind?: StringNullableFilter<'StudyRemind'> | string | null;
    Course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null;
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type StudyRemindOrderByWithRelationInput = {
    idStudyRemind?: SortOrder;
    idUser?: SortOrderInput | SortOrder;
    idCourse?: SortOrderInput | SortOrder;
    timeRemind?: SortOrderInput | SortOrder;
    typeRemind?: SortOrderInput | SortOrder;
    Course?: CourseOrderByWithRelationInput;
    User?: UserOrderByWithRelationInput;
    _relevance?: StudyRemindOrderByRelevanceInput;
  };

  export type StudyRemindWhereUniqueInput = Prisma.AtLeast<
    {
      idStudyRemind?: number;
      AND?: StudyRemindWhereInput | StudyRemindWhereInput[];
      OR?: StudyRemindWhereInput[];
      NOT?: StudyRemindWhereInput | StudyRemindWhereInput[];
      idUser?: IntNullableFilter<'StudyRemind'> | number | null;
      idCourse?: IntNullableFilter<'StudyRemind'> | number | null;
      timeRemind?: DateTimeNullableFilter<'StudyRemind'> | Date | string | null;
      typeRemind?: StringNullableFilter<'StudyRemind'> | string | null;
      Course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null;
      User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    'idStudyRemind'
  >;

  export type StudyRemindOrderByWithAggregationInput = {
    idStudyRemind?: SortOrder;
    idUser?: SortOrderInput | SortOrder;
    idCourse?: SortOrderInput | SortOrder;
    timeRemind?: SortOrderInput | SortOrder;
    typeRemind?: SortOrderInput | SortOrder;
    _count?: StudyRemindCountOrderByAggregateInput;
    _avg?: StudyRemindAvgOrderByAggregateInput;
    _max?: StudyRemindMaxOrderByAggregateInput;
    _min?: StudyRemindMinOrderByAggregateInput;
    _sum?: StudyRemindSumOrderByAggregateInput;
  };

  export type StudyRemindScalarWhereWithAggregatesInput = {
    AND?:
      | StudyRemindScalarWhereWithAggregatesInput
      | StudyRemindScalarWhereWithAggregatesInput[];
    OR?: StudyRemindScalarWhereWithAggregatesInput[];
    NOT?:
      | StudyRemindScalarWhereWithAggregatesInput
      | StudyRemindScalarWhereWithAggregatesInput[];
    idStudyRemind?: IntWithAggregatesFilter<'StudyRemind'> | number;
    idUser?: IntNullableWithAggregatesFilter<'StudyRemind'> | number | null;
    idCourse?: IntNullableWithAggregatesFilter<'StudyRemind'> | number | null;
    timeRemind?:
      | DateTimeNullableWithAggregatesFilter<'StudyRemind'>
      | Date
      | string
      | null;
    typeRemind?:
      | StringNullableWithAggregatesFilter<'StudyRemind'>
      | string
      | null;
  };

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    idUser?: IntFilter<'User'> | number;
    name?: StringNullableFilter<'User'> | string | null;
    biography?: StringNullableFilter<'User'> | string | null;
    role?: StringNullableFilter<'User'> | string | null;
    gender?: StringNullableFilter<'User'> | string | null;
    birthday?: DateTimeNullableFilter<'User'> | Date | string | null;
    codeExpired?: StringNullableFilter<'User'> | string | null;
    codeId?: StringNullableFilter<'User'> | string | null;
    email?: StringNullableFilter<'User'> | string | null;
    password?: StringNullableFilter<'User'> | string | null;
    Answer?: AnswerListRelationFilter;
    Cart?: CartListRelationFilter;
    Coupon?: CouponListRelationFilter;
    Course?: CourseListRelationFilter;
    Enrollment?: EnrollmentListRelationFilter;
    Follow_Follow_idFollowerToUser?: FollowListRelationFilter;
    Follow_Follow_idFollowingToUser?: FollowListRelationFilter;
    Message_Message_idUserReceiverToUser?: MessageListRelationFilter;
    Message_Message_idUserSenderToUser?: MessageListRelationFilter;
    Note?: NoteListRelationFilter;
    Notification?: NotificationListRelationFilter;
    NotificationReceiver?: NotificationReceiverListRelationFilter;
    Payment?: PaymentListRelationFilter;
    Question?: QuestionListRelationFilter;
    Report?: ReportListRelationFilter;
    Review?: ReviewListRelationFilter;
    StudyRemind?: StudyRemindListRelationFilter;
    UserCertificate?: UserCertificateListRelationFilter;
    UserCoupon?: UserCouponListRelationFilter;
    Wishlist?: WishlistListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    idUser?: SortOrder;
    name?: SortOrderInput | SortOrder;
    biography?: SortOrderInput | SortOrder;
    role?: SortOrderInput | SortOrder;
    gender?: SortOrderInput | SortOrder;
    birthday?: SortOrderInput | SortOrder;
    codeExpired?: SortOrderInput | SortOrder;
    codeId?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    Answer?: AnswerOrderByRelationAggregateInput;
    Cart?: CartOrderByRelationAggregateInput;
    Coupon?: CouponOrderByRelationAggregateInput;
    Course?: CourseOrderByRelationAggregateInput;
    Enrollment?: EnrollmentOrderByRelationAggregateInput;
    Follow_Follow_idFollowerToUser?: FollowOrderByRelationAggregateInput;
    Follow_Follow_idFollowingToUser?: FollowOrderByRelationAggregateInput;
    Message_Message_idUserReceiverToUser?: MessageOrderByRelationAggregateInput;
    Message_Message_idUserSenderToUser?: MessageOrderByRelationAggregateInput;
    Note?: NoteOrderByRelationAggregateInput;
    Notification?: NotificationOrderByRelationAggregateInput;
    NotificationReceiver?: NotificationReceiverOrderByRelationAggregateInput;
    Payment?: PaymentOrderByRelationAggregateInput;
    Question?: QuestionOrderByRelationAggregateInput;
    Report?: ReportOrderByRelationAggregateInput;
    Review?: ReviewOrderByRelationAggregateInput;
    StudyRemind?: StudyRemindOrderByRelationAggregateInput;
    UserCertificate?: UserCertificateOrderByRelationAggregateInput;
    UserCoupon?: UserCouponOrderByRelationAggregateInput;
    Wishlist?: WishlistOrderByRelationAggregateInput;
    _relevance?: UserOrderByRelevanceInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      idUser?: number;
      email?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      name?: StringNullableFilter<'User'> | string | null;
      biography?: StringNullableFilter<'User'> | string | null;
      role?: StringNullableFilter<'User'> | string | null;
      gender?: StringNullableFilter<'User'> | string | null;
      birthday?: DateTimeNullableFilter<'User'> | Date | string | null;
      codeExpired?: StringNullableFilter<'User'> | string | null;
      codeId?: StringNullableFilter<'User'> | string | null;
      password?: StringNullableFilter<'User'> | string | null;
      Answer?: AnswerListRelationFilter;
      Cart?: CartListRelationFilter;
      Coupon?: CouponListRelationFilter;
      Course?: CourseListRelationFilter;
      Enrollment?: EnrollmentListRelationFilter;
      Follow_Follow_idFollowerToUser?: FollowListRelationFilter;
      Follow_Follow_idFollowingToUser?: FollowListRelationFilter;
      Message_Message_idUserReceiverToUser?: MessageListRelationFilter;
      Message_Message_idUserSenderToUser?: MessageListRelationFilter;
      Note?: NoteListRelationFilter;
      Notification?: NotificationListRelationFilter;
      NotificationReceiver?: NotificationReceiverListRelationFilter;
      Payment?: PaymentListRelationFilter;
      Question?: QuestionListRelationFilter;
      Report?: ReportListRelationFilter;
      Review?: ReviewListRelationFilter;
      StudyRemind?: StudyRemindListRelationFilter;
      UserCertificate?: UserCertificateListRelationFilter;
      UserCoupon?: UserCouponListRelationFilter;
      Wishlist?: WishlistListRelationFilter;
    },
    'idUser' | 'email'
  >;

  export type UserOrderByWithAggregationInput = {
    idUser?: SortOrder;
    name?: SortOrderInput | SortOrder;
    biography?: SortOrderInput | SortOrder;
    role?: SortOrderInput | SortOrder;
    gender?: SortOrderInput | SortOrder;
    birthday?: SortOrderInput | SortOrder;
    codeExpired?: SortOrderInput | SortOrder;
    codeId?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _avg?: UserAvgOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
    _sum?: UserSumOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    idUser?: IntWithAggregatesFilter<'User'> | number;
    name?: StringNullableWithAggregatesFilter<'User'> | string | null;
    biography?: StringNullableWithAggregatesFilter<'User'> | string | null;
    role?: StringNullableWithAggregatesFilter<'User'> | string | null;
    gender?: StringNullableWithAggregatesFilter<'User'> | string | null;
    birthday?:
      | DateTimeNullableWithAggregatesFilter<'User'>
      | Date
      | string
      | null;
    codeExpired?: StringNullableWithAggregatesFilter<'User'> | string | null;
    codeId?: StringNullableWithAggregatesFilter<'User'> | string | null;
    email?: StringNullableWithAggregatesFilter<'User'> | string | null;
    password?: StringNullableWithAggregatesFilter<'User'> | string | null;
  };

  export type UserCertificateWhereInput = {
    AND?: UserCertificateWhereInput | UserCertificateWhereInput[];
    OR?: UserCertificateWhereInput[];
    NOT?: UserCertificateWhereInput | UserCertificateWhereInput[];
    idCourse?: IntFilter<'UserCertificate'> | number;
    idUser?: IntFilter<'UserCertificate'> | number;
    Certificate?: XOR<CertificateScalarRelationFilter, CertificateWhereInput>;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type UserCertificateOrderByWithRelationInput = {
    idCourse?: SortOrder;
    idUser?: SortOrder;
    Certificate?: CertificateOrderByWithRelationInput;
    User?: UserOrderByWithRelationInput;
  };

  export type UserCertificateWhereUniqueInput = Prisma.AtLeast<
    {
      idCourse_idUser?: UserCertificateIdCourseIdUserCompoundUniqueInput;
      AND?: UserCertificateWhereInput | UserCertificateWhereInput[];
      OR?: UserCertificateWhereInput[];
      NOT?: UserCertificateWhereInput | UserCertificateWhereInput[];
      idCourse?: IntFilter<'UserCertificate'> | number;
      idUser?: IntFilter<'UserCertificate'> | number;
      Certificate?: XOR<CertificateScalarRelationFilter, CertificateWhereInput>;
      User?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'idCourse_idUser'
  >;

  export type UserCertificateOrderByWithAggregationInput = {
    idCourse?: SortOrder;
    idUser?: SortOrder;
    _count?: UserCertificateCountOrderByAggregateInput;
    _avg?: UserCertificateAvgOrderByAggregateInput;
    _max?: UserCertificateMaxOrderByAggregateInput;
    _min?: UserCertificateMinOrderByAggregateInput;
    _sum?: UserCertificateSumOrderByAggregateInput;
  };

  export type UserCertificateScalarWhereWithAggregatesInput = {
    AND?:
      | UserCertificateScalarWhereWithAggregatesInput
      | UserCertificateScalarWhereWithAggregatesInput[];
    OR?: UserCertificateScalarWhereWithAggregatesInput[];
    NOT?:
      | UserCertificateScalarWhereWithAggregatesInput
      | UserCertificateScalarWhereWithAggregatesInput[];
    idCourse?: IntWithAggregatesFilter<'UserCertificate'> | number;
    idUser?: IntWithAggregatesFilter<'UserCertificate'> | number;
  };

  export type UserCouponWhereInput = {
    AND?: UserCouponWhereInput | UserCouponWhereInput[];
    OR?: UserCouponWhereInput[];
    NOT?: UserCouponWhereInput | UserCouponWhereInput[];
    idUser?: IntFilter<'UserCoupon'> | number;
    idCoupon?: IntFilter<'UserCoupon'> | number;
    Coupon?: XOR<CouponScalarRelationFilter, CouponWhereInput>;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type UserCouponOrderByWithRelationInput = {
    idUser?: SortOrder;
    idCoupon?: SortOrder;
    Coupon?: CouponOrderByWithRelationInput;
    User?: UserOrderByWithRelationInput;
  };

  export type UserCouponWhereUniqueInput = Prisma.AtLeast<
    {
      idUser_idCoupon?: UserCouponIdUserIdCouponCompoundUniqueInput;
      AND?: UserCouponWhereInput | UserCouponWhereInput[];
      OR?: UserCouponWhereInput[];
      NOT?: UserCouponWhereInput | UserCouponWhereInput[];
      idUser?: IntFilter<'UserCoupon'> | number;
      idCoupon?: IntFilter<'UserCoupon'> | number;
      Coupon?: XOR<CouponScalarRelationFilter, CouponWhereInput>;
      User?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'idUser_idCoupon'
  >;

  export type UserCouponOrderByWithAggregationInput = {
    idUser?: SortOrder;
    idCoupon?: SortOrder;
    _count?: UserCouponCountOrderByAggregateInput;
    _avg?: UserCouponAvgOrderByAggregateInput;
    _max?: UserCouponMaxOrderByAggregateInput;
    _min?: UserCouponMinOrderByAggregateInput;
    _sum?: UserCouponSumOrderByAggregateInput;
  };

  export type UserCouponScalarWhereWithAggregatesInput = {
    AND?:
      | UserCouponScalarWhereWithAggregatesInput
      | UserCouponScalarWhereWithAggregatesInput[];
    OR?: UserCouponScalarWhereWithAggregatesInput[];
    NOT?:
      | UserCouponScalarWhereWithAggregatesInput
      | UserCouponScalarWhereWithAggregatesInput[];
    idUser?: IntWithAggregatesFilter<'UserCoupon'> | number;
    idCoupon?: IntWithAggregatesFilter<'UserCoupon'> | number;
  };

  export type WishlistWhereInput = {
    AND?: WishlistWhereInput | WishlistWhereInput[];
    OR?: WishlistWhereInput[];
    NOT?: WishlistWhereInput | WishlistWhereInput[];
    idUser?: IntFilter<'Wishlist'> | number;
    idCourse?: IntFilter<'Wishlist'> | number;
    Course?: XOR<CourseScalarRelationFilter, CourseWhereInput>;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type WishlistOrderByWithRelationInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
    Course?: CourseOrderByWithRelationInput;
    User?: UserOrderByWithRelationInput;
  };

  export type WishlistWhereUniqueInput = Prisma.AtLeast<
    {
      idUser_idCourse?: WishlistIdUserIdCourseCompoundUniqueInput;
      AND?: WishlistWhereInput | WishlistWhereInput[];
      OR?: WishlistWhereInput[];
      NOT?: WishlistWhereInput | WishlistWhereInput[];
      idUser?: IntFilter<'Wishlist'> | number;
      idCourse?: IntFilter<'Wishlist'> | number;
      Course?: XOR<CourseScalarRelationFilter, CourseWhereInput>;
      User?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'idUser_idCourse'
  >;

  export type WishlistOrderByWithAggregationInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
    _count?: WishlistCountOrderByAggregateInput;
    _avg?: WishlistAvgOrderByAggregateInput;
    _max?: WishlistMaxOrderByAggregateInput;
    _min?: WishlistMinOrderByAggregateInput;
    _sum?: WishlistSumOrderByAggregateInput;
  };

  export type WishlistScalarWhereWithAggregatesInput = {
    AND?:
      | WishlistScalarWhereWithAggregatesInput
      | WishlistScalarWhereWithAggregatesInput[];
    OR?: WishlistScalarWhereWithAggregatesInput[];
    NOT?:
      | WishlistScalarWhereWithAggregatesInput
      | WishlistScalarWhereWithAggregatesInput[];
    idUser?: IntWithAggregatesFilter<'Wishlist'> | number;
    idCourse?: IntWithAggregatesFilter<'Wishlist'> | number;
  };

  export type AnswerCreateInput = {
    idAnswer: number;
    contentAnswer?: string | null;
    Question: QuestionCreateNestedOneWithoutAnswerInput;
    User?: UserCreateNestedOneWithoutAnswerInput;
  };

  export type AnswerUncheckedCreateInput = {
    idQuestion: number;
    idAnswer: number;
    idUser?: number | null;
    contentAnswer?: string | null;
  };

  export type AnswerUpdateInput = {
    idAnswer?: IntFieldUpdateOperationsInput | number;
    contentAnswer?: NullableStringFieldUpdateOperationsInput | string | null;
    Question?: QuestionUpdateOneRequiredWithoutAnswerNestedInput;
    User?: UserUpdateOneWithoutAnswerNestedInput;
  };

  export type AnswerUncheckedUpdateInput = {
    idQuestion?: IntFieldUpdateOperationsInput | number;
    idAnswer?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    contentAnswer?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AnswerCreateManyInput = {
    idQuestion: number;
    idAnswer: number;
    idUser?: number | null;
    contentAnswer?: string | null;
  };

  export type AnswerUpdateManyMutationInput = {
    idAnswer?: IntFieldUpdateOperationsInput | number;
    contentAnswer?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AnswerUncheckedUpdateManyInput = {
    idQuestion?: IntFieldUpdateOperationsInput | number;
    idAnswer?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    contentAnswer?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CartCreateInput = {
    Course: CourseCreateNestedOneWithoutCartInput;
    User: UserCreateNestedOneWithoutCartInput;
  };

  export type CartUncheckedCreateInput = {
    idUser: number;
    idCourse: number;
  };

  export type CartUpdateInput = {
    Course?: CourseUpdateOneRequiredWithoutCartNestedInput;
    User?: UserUpdateOneRequiredWithoutCartNestedInput;
  };

  export type CartUncheckedUpdateInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    idCourse?: IntFieldUpdateOperationsInput | number;
  };

  export type CartCreateManyInput = {
    idUser: number;
    idCourse: number;
  };

  export type CartUpdateManyMutationInput = {};

  export type CartUncheckedUpdateManyInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    idCourse?: IntFieldUpdateOperationsInput | number;
  };

  export type CategoryCreateInput = {
    nameCategory?: string | null;
    CourseCategory?: CourseCategoryCreateNestedManyWithoutCategoryInput;
  };

  export type CategoryUncheckedCreateInput = {
    idCategory?: number;
    nameCategory?: string | null;
    CourseCategory?: CourseCategoryUncheckedCreateNestedManyWithoutCategoryInput;
  };

  export type CategoryUpdateInput = {
    nameCategory?: NullableStringFieldUpdateOperationsInput | string | null;
    CourseCategory?: CourseCategoryUpdateManyWithoutCategoryNestedInput;
  };

  export type CategoryUncheckedUpdateInput = {
    idCategory?: IntFieldUpdateOperationsInput | number;
    nameCategory?: NullableStringFieldUpdateOperationsInput | string | null;
    CourseCategory?: CourseCategoryUncheckedUpdateManyWithoutCategoryNestedInput;
  };

  export type CategoryCreateManyInput = {
    idCategory?: number;
    nameCategory?: string | null;
  };

  export type CategoryUpdateManyMutationInput = {
    nameCategory?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CategoryUncheckedUpdateManyInput = {
    idCategory?: IntFieldUpdateOperationsInput | number;
    nameCategory?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CertificateCreateInput = {
    certificate?: string | null;
    Course: CourseCreateNestedOneWithoutCertificateInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutCertificateInput;
  };

  export type CertificateUncheckedCreateInput = {
    idCourse: number;
    certificate?: string | null;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutCertificateInput;
  };

  export type CertificateUpdateInput = {
    certificate?: NullableStringFieldUpdateOperationsInput | string | null;
    Course?: CourseUpdateOneRequiredWithoutCertificateNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutCertificateNestedInput;
  };

  export type CertificateUncheckedUpdateInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    certificate?: NullableStringFieldUpdateOperationsInput | string | null;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutCertificateNestedInput;
  };

  export type CertificateCreateManyInput = {
    idCourse: number;
    certificate?: string | null;
  };

  export type CertificateUpdateManyMutationInput = {
    certificate?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CertificateUncheckedUpdateManyInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    certificate?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CouponCreateInput = {
    type?: string | null;
    value?: Decimal | DecimalJsLike | number | string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    quantity?: number | null;
    appliedAmount?: number | null;
    minRequire?: Decimal | DecimalJsLike | number | string | null;
    maxValueDiscount?: Decimal | DecimalJsLike | number | string | null;
    code?: string | null;
    User?: UserCreateNestedOneWithoutCouponInput;
    CouponCourse?: CouponCourseCreateNestedManyWithoutCouponInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutCouponInput;
  };

  export type CouponUncheckedCreateInput = {
    idCoupon?: number;
    type?: string | null;
    value?: Decimal | DecimalJsLike | number | string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    quantity?: number | null;
    appliedAmount?: number | null;
    minRequire?: Decimal | DecimalJsLike | number | string | null;
    maxValueDiscount?: Decimal | DecimalJsLike | number | string | null;
    code?: string | null;
    idUser?: number | null;
    CouponCourse?: CouponCourseUncheckedCreateNestedManyWithoutCouponInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutCouponInput;
  };

  export type CouponUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    quantity?: NullableIntFieldUpdateOperationsInput | number | null;
    appliedAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    minRequire?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxValueDiscount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    code?: NullableStringFieldUpdateOperationsInput | string | null;
    User?: UserUpdateOneWithoutCouponNestedInput;
    CouponCourse?: CouponCourseUpdateManyWithoutCouponNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutCouponNestedInput;
  };

  export type CouponUncheckedUpdateInput = {
    idCoupon?: IntFieldUpdateOperationsInput | number;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    quantity?: NullableIntFieldUpdateOperationsInput | number | null;
    appliedAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    minRequire?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxValueDiscount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    code?: NullableStringFieldUpdateOperationsInput | string | null;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    CouponCourse?: CouponCourseUncheckedUpdateManyWithoutCouponNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutCouponNestedInput;
  };

  export type CouponCreateManyInput = {
    idCoupon?: number;
    type?: string | null;
    value?: Decimal | DecimalJsLike | number | string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    quantity?: number | null;
    appliedAmount?: number | null;
    minRequire?: Decimal | DecimalJsLike | number | string | null;
    maxValueDiscount?: Decimal | DecimalJsLike | number | string | null;
    code?: string | null;
    idUser?: number | null;
  };

  export type CouponUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    quantity?: NullableIntFieldUpdateOperationsInput | number | null;
    appliedAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    minRequire?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxValueDiscount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    code?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CouponUncheckedUpdateManyInput = {
    idCoupon?: IntFieldUpdateOperationsInput | number;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    quantity?: NullableIntFieldUpdateOperationsInput | number | null;
    appliedAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    minRequire?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxValueDiscount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    code?: NullableStringFieldUpdateOperationsInput | string | null;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type CouponCourseCreateInput = {
    Coupon: CouponCreateNestedOneWithoutCouponCourseInput;
    Course: CourseCreateNestedOneWithoutCouponCourseInput;
  };

  export type CouponCourseUncheckedCreateInput = {
    idCoupon: number;
    idCourse: number;
  };

  export type CouponCourseUpdateInput = {
    Coupon?: CouponUpdateOneRequiredWithoutCouponCourseNestedInput;
    Course?: CourseUpdateOneRequiredWithoutCouponCourseNestedInput;
  };

  export type CouponCourseUncheckedUpdateInput = {
    idCoupon?: IntFieldUpdateOperationsInput | number;
    idCourse?: IntFieldUpdateOperationsInput | number;
  };

  export type CouponCourseCreateManyInput = {
    idCoupon: number;
    idCourse: number;
  };

  export type CouponCourseUpdateManyMutationInput = {};

  export type CouponCourseUncheckedUpdateManyInput = {
    idCoupon?: IntFieldUpdateOperationsInput | number;
    idCourse?: IntFieldUpdateOperationsInput | number;
  };

  export type CourseCreateInput = {
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseCreateNestedManyWithoutCourseInput;
    User?: UserCreateNestedOneWithoutCourseInput;
    CourseCategory?: CourseCategoryCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailCreateNestedManyWithoutCourseInput;
    Review?: ReviewCreateNestedManyWithoutCourseInput;
    Section?: SectionCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistCreateNestedManyWithoutCourseInput;
  };

  export type CourseUncheckedCreateInput = {
    idCourse?: number;
    idUser?: number | null;
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartUncheckedCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateUncheckedCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseUncheckedCreateNestedManyWithoutCourseInput;
    CourseCategory?: CourseCategoryUncheckedCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailUncheckedCreateNestedManyWithoutCourseInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutCourseInput;
    Section?: SectionUncheckedCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutCourseInput;
  };

  export type CourseUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUpdateManyWithoutCourseNestedInput;
    User?: UserUpdateOneWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUpdateManyWithoutCourseNestedInput;
    Section?: SectionUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUpdateManyWithoutCourseNestedInput;
  };

  export type CourseUncheckedUpdateInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUncheckedUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUncheckedUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUncheckedUpdateManyWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUncheckedUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutCourseNestedInput;
    Section?: SectionUncheckedUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutCourseNestedInput;
  };

  export type CourseCreateManyInput = {
    idCourse?: number;
    idUser?: number | null;
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
  };

  export type CourseUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CourseUncheckedUpdateManyInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CourseCategoryCreateInput = {
    Category: CategoryCreateNestedOneWithoutCourseCategoryInput;
    Course: CourseCreateNestedOneWithoutCourseCategoryInput;
  };

  export type CourseCategoryUncheckedCreateInput = {
    idCourse: number;
    idCategory: number;
  };

  export type CourseCategoryUpdateInput = {
    Category?: CategoryUpdateOneRequiredWithoutCourseCategoryNestedInput;
    Course?: CourseUpdateOneRequiredWithoutCourseCategoryNestedInput;
  };

  export type CourseCategoryUncheckedUpdateInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idCategory?: IntFieldUpdateOperationsInput | number;
  };

  export type CourseCategoryCreateManyInput = {
    idCourse: number;
    idCategory: number;
  };

  export type CourseCategoryUpdateManyMutationInput = {};

  export type CourseCategoryUncheckedUpdateManyInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idCategory?: IntFieldUpdateOperationsInput | number;
  };

  export type CourseObjectiveCreateInput = {
    idCourseObjective: number;
    content?: string | null;
    Course: CourseCreateNestedOneWithoutCourseObjectiveInput;
  };

  export type CourseObjectiveUncheckedCreateInput = {
    idCourse: number;
    idCourseObjective: number;
    content?: string | null;
  };

  export type CourseObjectiveUpdateInput = {
    idCourseObjective?: IntFieldUpdateOperationsInput | number;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    Course?: CourseUpdateOneRequiredWithoutCourseObjectiveNestedInput;
  };

  export type CourseObjectiveUncheckedUpdateInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idCourseObjective?: IntFieldUpdateOperationsInput | number;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CourseObjectiveCreateManyInput = {
    idCourse: number;
    idCourseObjective: number;
    content?: string | null;
  };

  export type CourseObjectiveUpdateManyMutationInput = {
    idCourseObjective?: IntFieldUpdateOperationsInput | number;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CourseObjectiveUncheckedUpdateManyInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idCourseObjective?: IntFieldUpdateOperationsInput | number;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type EnrollmentCreateInput = {
    dateRegister?: Date | string | null;
    finishStatus?: boolean | null;
    progress?: Decimal | DecimalJsLike | number | string | null;
    Course: CourseCreateNestedOneWithoutEnrollmentInput;
    User: UserCreateNestedOneWithoutEnrollmentInput;
  };

  export type EnrollmentUncheckedCreateInput = {
    idUser: number;
    idCourse: number;
    dateRegister?: Date | string | null;
    finishStatus?: boolean | null;
    progress?: Decimal | DecimalJsLike | number | string | null;
  };

  export type EnrollmentUpdateInput = {
    dateRegister?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    finishStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    progress?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    Course?: CourseUpdateOneRequiredWithoutEnrollmentNestedInput;
    User?: UserUpdateOneRequiredWithoutEnrollmentNestedInput;
  };

  export type EnrollmentUncheckedUpdateInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    idCourse?: IntFieldUpdateOperationsInput | number;
    dateRegister?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    finishStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    progress?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type EnrollmentCreateManyInput = {
    idUser: number;
    idCourse: number;
    dateRegister?: Date | string | null;
    finishStatus?: boolean | null;
    progress?: Decimal | DecimalJsLike | number | string | null;
  };

  export type EnrollmentUpdateManyMutationInput = {
    dateRegister?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    finishStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    progress?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type EnrollmentUncheckedUpdateManyInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    idCourse?: IntFieldUpdateOperationsInput | number;
    dateRegister?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    finishStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    progress?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type FollowCreateInput = {
    User_Follow_idFollowerToUser: UserCreateNestedOneWithoutFollow_Follow_idFollowerToUserInput;
    User_Follow_idFollowingToUser: UserCreateNestedOneWithoutFollow_Follow_idFollowingToUserInput;
  };

  export type FollowUncheckedCreateInput = {
    idFollower: number;
    idFollowing: number;
  };

  export type FollowUpdateInput = {
    User_Follow_idFollowerToUser?: UserUpdateOneRequiredWithoutFollow_Follow_idFollowerToUserNestedInput;
    User_Follow_idFollowingToUser?: UserUpdateOneRequiredWithoutFollow_Follow_idFollowingToUserNestedInput;
  };

  export type FollowUncheckedUpdateInput = {
    idFollower?: IntFieldUpdateOperationsInput | number;
    idFollowing?: IntFieldUpdateOperationsInput | number;
  };

  export type FollowCreateManyInput = {
    idFollower: number;
    idFollowing: number;
  };

  export type FollowUpdateManyMutationInput = {};

  export type FollowUncheckedUpdateManyInput = {
    idFollower?: IntFieldUpdateOperationsInput | number;
    idFollowing?: IntFieldUpdateOperationsInput | number;
  };

  export type LectureCreateInput = {
    idLecture: number;
    nameLecture?: string | null;
    isDone?: boolean | null;
    Section: SectionCreateNestedOneWithoutLectureInput;
    Note?: NoteCreateNestedManyWithoutLectureInput;
    Question?: QuestionCreateNestedManyWithoutLectureInput;
  };

  export type LectureUncheckedCreateInput = {
    idCourse: number;
    idSection: number;
    idLecture: number;
    nameLecture?: string | null;
    isDone?: boolean | null;
    Note?: NoteUncheckedCreateNestedManyWithoutLectureInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutLectureInput;
  };

  export type LectureUpdateInput = {
    idLecture?: IntFieldUpdateOperationsInput | number;
    nameLecture?: NullableStringFieldUpdateOperationsInput | string | null;
    isDone?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    Section?: SectionUpdateOneRequiredWithoutLectureNestedInput;
    Note?: NoteUpdateManyWithoutLectureNestedInput;
    Question?: QuestionUpdateManyWithoutLectureNestedInput;
  };

  export type LectureUncheckedUpdateInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idSection?: IntFieldUpdateOperationsInput | number;
    idLecture?: IntFieldUpdateOperationsInput | number;
    nameLecture?: NullableStringFieldUpdateOperationsInput | string | null;
    isDone?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    Note?: NoteUncheckedUpdateManyWithoutLectureNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutLectureNestedInput;
  };

  export type LectureCreateManyInput = {
    idCourse: number;
    idSection: number;
    idLecture: number;
    nameLecture?: string | null;
    isDone?: boolean | null;
  };

  export type LectureUpdateManyMutationInput = {
    idLecture?: IntFieldUpdateOperationsInput | number;
    nameLecture?: NullableStringFieldUpdateOperationsInput | string | null;
    isDone?: NullableBoolFieldUpdateOperationsInput | boolean | null;
  };

  export type LectureUncheckedUpdateManyInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idSection?: IntFieldUpdateOperationsInput | number;
    idLecture?: IntFieldUpdateOperationsInput | number;
    nameLecture?: NullableStringFieldUpdateOperationsInput | string | null;
    isDone?: NullableBoolFieldUpdateOperationsInput | boolean | null;
  };

  export type MessageCreateInput = {
    message?: string | null;
    timeSend?: Date | string | null;
    User_Message_idUserReceiverToUser?: UserCreateNestedOneWithoutMessage_Message_idUserReceiverToUserInput;
    User_Message_idUserSenderToUser?: UserCreateNestedOneWithoutMessage_Message_idUserSenderToUserInput;
  };

  export type MessageUncheckedCreateInput = {
    idMessage?: number;
    idUserSender?: number | null;
    idUserReceiver?: number | null;
    message?: string | null;
    timeSend?: Date | string | null;
  };

  export type MessageUpdateInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    timeSend?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    User_Message_idUserReceiverToUser?: UserUpdateOneWithoutMessage_Message_idUserReceiverToUserNestedInput;
    User_Message_idUserSenderToUser?: UserUpdateOneWithoutMessage_Message_idUserSenderToUserNestedInput;
  };

  export type MessageUncheckedUpdateInput = {
    idMessage?: IntFieldUpdateOperationsInput | number;
    idUserSender?: NullableIntFieldUpdateOperationsInput | number | null;
    idUserReceiver?: NullableIntFieldUpdateOperationsInput | number | null;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    timeSend?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type MessageCreateManyInput = {
    idMessage?: number;
    idUserSender?: number | null;
    idUserReceiver?: number | null;
    message?: string | null;
    timeSend?: Date | string | null;
  };

  export type MessageUpdateManyMutationInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    timeSend?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type MessageUncheckedUpdateManyInput = {
    idMessage?: IntFieldUpdateOperationsInput | number;
    idUserSender?: NullableIntFieldUpdateOperationsInput | number | null;
    idUserReceiver?: NullableIntFieldUpdateOperationsInput | number | null;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    timeSend?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type NoteCreateInput = {
    timeNote?: Date | string | null;
    note?: string | null;
    Lecture?: LectureCreateNestedOneWithoutNoteInput;
    User?: UserCreateNestedOneWithoutNoteInput;
  };

  export type NoteUncheckedCreateInput = {
    idNote?: number;
    timeNote?: Date | string | null;
    note?: string | null;
    idUser?: number | null;
    idCourse?: number | null;
    idSection?: number | null;
    idLecture?: number | null;
  };

  export type NoteUpdateInput = {
    timeNote?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    note?: NullableStringFieldUpdateOperationsInput | string | null;
    Lecture?: LectureUpdateOneWithoutNoteNestedInput;
    User?: UserUpdateOneWithoutNoteNestedInput;
  };

  export type NoteUncheckedUpdateInput = {
    idNote?: IntFieldUpdateOperationsInput | number;
    timeNote?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    note?: NullableStringFieldUpdateOperationsInput | string | null;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    idCourse?: NullableIntFieldUpdateOperationsInput | number | null;
    idSection?: NullableIntFieldUpdateOperationsInput | number | null;
    idLecture?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type NoteCreateManyInput = {
    idNote?: number;
    timeNote?: Date | string | null;
    note?: string | null;
    idUser?: number | null;
    idCourse?: number | null;
    idSection?: number | null;
    idLecture?: number | null;
  };

  export type NoteUpdateManyMutationInput = {
    timeNote?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    note?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type NoteUncheckedUpdateManyInput = {
    idNote?: IntFieldUpdateOperationsInput | number;
    timeNote?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    note?: NullableStringFieldUpdateOperationsInput | string | null;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    idCourse?: NullableIntFieldUpdateOperationsInput | number | null;
    idSection?: NullableIntFieldUpdateOperationsInput | number | null;
    idLecture?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type NotificationCreateInput = {
    contentNotification?: string | null;
    User?: UserCreateNestedOneWithoutNotificationInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutNotificationInput;
  };

  export type NotificationUncheckedCreateInput = {
    idNotification?: number;
    contentNotification?: string | null;
    idUser?: number | null;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutNotificationInput;
  };

  export type NotificationUpdateInput = {
    contentNotification?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    User?: UserUpdateOneWithoutNotificationNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutNotificationNestedInput;
  };

  export type NotificationUncheckedUpdateInput = {
    idNotification?: IntFieldUpdateOperationsInput | number;
    contentNotification?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutNotificationNestedInput;
  };

  export type NotificationCreateManyInput = {
    idNotification?: number;
    contentNotification?: string | null;
    idUser?: number | null;
  };

  export type NotificationUpdateManyMutationInput = {
    contentNotification?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
  };

  export type NotificationUncheckedUpdateManyInput = {
    idNotification?: IntFieldUpdateOperationsInput | number;
    contentNotification?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type NotificationReceiverCreateInput = {
    timeGetNotification?: Date | string | null;
    Notification: NotificationCreateNestedOneWithoutNotificationReceiverInput;
    User: UserCreateNestedOneWithoutNotificationReceiverInput;
  };

  export type NotificationReceiverUncheckedCreateInput = {
    idNotification: number;
    idUser: number;
    timeGetNotification?: Date | string | null;
  };

  export type NotificationReceiverUpdateInput = {
    timeGetNotification?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Notification?: NotificationUpdateOneRequiredWithoutNotificationReceiverNestedInput;
    User?: UserUpdateOneRequiredWithoutNotificationReceiverNestedInput;
  };

  export type NotificationReceiverUncheckedUpdateInput = {
    idNotification?: IntFieldUpdateOperationsInput | number;
    idUser?: IntFieldUpdateOperationsInput | number;
    timeGetNotification?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type NotificationReceiverCreateManyInput = {
    idNotification: number;
    idUser: number;
    timeGetNotification?: Date | string | null;
  };

  export type NotificationReceiverUpdateManyMutationInput = {
    timeGetNotification?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type NotificationReceiverUncheckedUpdateManyInput = {
    idNotification?: IntFieldUpdateOperationsInput | number;
    idUser?: IntFieldUpdateOperationsInput | number;
    timeGetNotification?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type PaymentCreateInput = {
    timePayment?: Date | string | null;
    totalPrice?: Decimal | DecimalJsLike | number | string | null;
    User?: UserCreateNestedOneWithoutPaymentInput;
    PaymentDetail?: PaymentDetailCreateNestedManyWithoutPaymentInput;
  };

  export type PaymentUncheckedCreateInput = {
    idPayment?: number;
    timePayment?: Date | string | null;
    totalPrice?: Decimal | DecimalJsLike | number | string | null;
    idUser?: number | null;
    PaymentDetail?: PaymentDetailUncheckedCreateNestedManyWithoutPaymentInput;
  };

  export type PaymentUpdateInput = {
    timePayment?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    totalPrice?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    User?: UserUpdateOneWithoutPaymentNestedInput;
    PaymentDetail?: PaymentDetailUpdateManyWithoutPaymentNestedInput;
  };

  export type PaymentUncheckedUpdateInput = {
    idPayment?: IntFieldUpdateOperationsInput | number;
    timePayment?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    totalPrice?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    PaymentDetail?: PaymentDetailUncheckedUpdateManyWithoutPaymentNestedInput;
  };

  export type PaymentCreateManyInput = {
    idPayment?: number;
    timePayment?: Date | string | null;
    totalPrice?: Decimal | DecimalJsLike | number | string | null;
    idUser?: number | null;
  };

  export type PaymentUpdateManyMutationInput = {
    timePayment?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    totalPrice?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type PaymentUncheckedUpdateManyInput = {
    idPayment?: IntFieldUpdateOperationsInput | number;
    timePayment?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    totalPrice?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type PaymentDetailCreateInput = {
    price?: Decimal | DecimalJsLike | number | string | null;
    Course: CourseCreateNestedOneWithoutPaymentDetailInput;
    Payment: PaymentCreateNestedOneWithoutPaymentDetailInput;
  };

  export type PaymentDetailUncheckedCreateInput = {
    idPayment: number;
    idCourse: number;
    price?: Decimal | DecimalJsLike | number | string | null;
  };

  export type PaymentDetailUpdateInput = {
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    Course?: CourseUpdateOneRequiredWithoutPaymentDetailNestedInput;
    Payment?: PaymentUpdateOneRequiredWithoutPaymentDetailNestedInput;
  };

  export type PaymentDetailUncheckedUpdateInput = {
    idPayment?: IntFieldUpdateOperationsInput | number;
    idCourse?: IntFieldUpdateOperationsInput | number;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type PaymentDetailCreateManyInput = {
    idPayment: number;
    idCourse: number;
    price?: Decimal | DecimalJsLike | number | string | null;
  };

  export type PaymentDetailUpdateManyMutationInput = {
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type PaymentDetailUncheckedUpdateManyInput = {
    idPayment?: IntFieldUpdateOperationsInput | number;
    idCourse?: IntFieldUpdateOperationsInput | number;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type QuestionCreateInput = {
    contentQuestion?: string | null;
    Answer?: AnswerCreateNestedManyWithoutQuestionInput;
    Lecture?: LectureCreateNestedOneWithoutQuestionInput;
    User?: UserCreateNestedOneWithoutQuestionInput;
  };

  export type QuestionUncheckedCreateInput = {
    idQuestion?: number;
    idUser?: number | null;
    idCourse?: number | null;
    idSection?: number | null;
    idLecture?: number | null;
    contentQuestion?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutQuestionInput;
  };

  export type QuestionUpdateInput = {
    contentQuestion?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutQuestionNestedInput;
    Lecture?: LectureUpdateOneWithoutQuestionNestedInput;
    User?: UserUpdateOneWithoutQuestionNestedInput;
  };

  export type QuestionUncheckedUpdateInput = {
    idQuestion?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    idCourse?: NullableIntFieldUpdateOperationsInput | number | null;
    idSection?: NullableIntFieldUpdateOperationsInput | number | null;
    idLecture?: NullableIntFieldUpdateOperationsInput | number | null;
    contentQuestion?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput;
  };

  export type QuestionCreateManyInput = {
    idQuestion?: number;
    idUser?: number | null;
    idCourse?: number | null;
    idSection?: number | null;
    idLecture?: number | null;
    contentQuestion?: string | null;
  };

  export type QuestionUpdateManyMutationInput = {
    contentQuestion?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type QuestionUncheckedUpdateManyInput = {
    idQuestion?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    idCourse?: NullableIntFieldUpdateOperationsInput | number | null;
    idSection?: NullableIntFieldUpdateOperationsInput | number | null;
    idLecture?: NullableIntFieldUpdateOperationsInput | number | null;
    contentQuestion?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ReportCreateInput = {
    contentReport?: string | null;
    User?: UserCreateNestedOneWithoutReportInput;
  };

  export type ReportUncheckedCreateInput = {
    idReport?: number;
    idUser?: number | null;
    contentReport?: string | null;
  };

  export type ReportUpdateInput = {
    contentReport?: NullableStringFieldUpdateOperationsInput | string | null;
    User?: UserUpdateOneWithoutReportNestedInput;
  };

  export type ReportUncheckedUpdateInput = {
    idReport?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    contentReport?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ReportCreateManyInput = {
    idReport?: number;
    idUser?: number | null;
    contentReport?: string | null;
  };

  export type ReportUpdateManyMutationInput = {
    contentReport?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ReportUncheckedUpdateManyInput = {
    idReport?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    contentReport?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ReviewCreateInput = {
    rating?: number | null;
    review?: string | null;
    Course?: CourseCreateNestedOneWithoutReviewInput;
    User?: UserCreateNestedOneWithoutReviewInput;
  };

  export type ReviewUncheckedCreateInput = {
    idReview?: number;
    idUser?: number | null;
    idCourse?: number | null;
    rating?: number | null;
    review?: string | null;
  };

  export type ReviewUpdateInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null;
    review?: NullableStringFieldUpdateOperationsInput | string | null;
    Course?: CourseUpdateOneWithoutReviewNestedInput;
    User?: UserUpdateOneWithoutReviewNestedInput;
  };

  export type ReviewUncheckedUpdateInput = {
    idReview?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    idCourse?: NullableIntFieldUpdateOperationsInput | number | null;
    rating?: NullableIntFieldUpdateOperationsInput | number | null;
    review?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ReviewCreateManyInput = {
    idReview?: number;
    idUser?: number | null;
    idCourse?: number | null;
    rating?: number | null;
    review?: string | null;
  };

  export type ReviewUpdateManyMutationInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null;
    review?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ReviewUncheckedUpdateManyInput = {
    idReview?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    idCourse?: NullableIntFieldUpdateOperationsInput | number | null;
    rating?: NullableIntFieldUpdateOperationsInput | number | null;
    review?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SectionCreateInput = {
    idSection: number;
    nameSection?: string | null;
    Lecture?: LectureCreateNestedManyWithoutSectionInput;
    Course: CourseCreateNestedOneWithoutSectionInput;
  };

  export type SectionUncheckedCreateInput = {
    idCourse: number;
    idSection: number;
    nameSection?: string | null;
    Lecture?: LectureUncheckedCreateNestedManyWithoutSectionInput;
  };

  export type SectionUpdateInput = {
    idSection?: IntFieldUpdateOperationsInput | number;
    nameSection?: NullableStringFieldUpdateOperationsInput | string | null;
    Lecture?: LectureUpdateManyWithoutSectionNestedInput;
    Course?: CourseUpdateOneRequiredWithoutSectionNestedInput;
  };

  export type SectionUncheckedUpdateInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idSection?: IntFieldUpdateOperationsInput | number;
    nameSection?: NullableStringFieldUpdateOperationsInput | string | null;
    Lecture?: LectureUncheckedUpdateManyWithoutSectionNestedInput;
  };

  export type SectionCreateManyInput = {
    idCourse: number;
    idSection: number;
    nameSection?: string | null;
  };

  export type SectionUpdateManyMutationInput = {
    idSection?: IntFieldUpdateOperationsInput | number;
    nameSection?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SectionUncheckedUpdateManyInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idSection?: IntFieldUpdateOperationsInput | number;
    nameSection?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type StudyRemindCreateInput = {
    timeRemind?: Date | string | null;
    typeRemind?: string | null;
    Course?: CourseCreateNestedOneWithoutStudyRemindInput;
    User?: UserCreateNestedOneWithoutStudyRemindInput;
  };

  export type StudyRemindUncheckedCreateInput = {
    idStudyRemind?: number;
    idUser?: number | null;
    idCourse?: number | null;
    timeRemind?: Date | string | null;
    typeRemind?: string | null;
  };

  export type StudyRemindUpdateInput = {
    timeRemind?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    typeRemind?: NullableStringFieldUpdateOperationsInput | string | null;
    Course?: CourseUpdateOneWithoutStudyRemindNestedInput;
    User?: UserUpdateOneWithoutStudyRemindNestedInput;
  };

  export type StudyRemindUncheckedUpdateInput = {
    idStudyRemind?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    idCourse?: NullableIntFieldUpdateOperationsInput | number | null;
    timeRemind?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    typeRemind?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type StudyRemindCreateManyInput = {
    idStudyRemind?: number;
    idUser?: number | null;
    idCourse?: number | null;
    timeRemind?: Date | string | null;
    typeRemind?: string | null;
  };

  export type StudyRemindUpdateManyMutationInput = {
    timeRemind?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    typeRemind?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type StudyRemindUncheckedUpdateManyInput = {
    idStudyRemind?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    idCourse?: NullableIntFieldUpdateOperationsInput | number | null;
    timeRemind?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    typeRemind?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UserCreateInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
    Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
    Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
    Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateManyInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
  };

  export type UserUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UserUncheckedUpdateManyInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UserCertificateCreateInput = {
    Certificate: CertificateCreateNestedOneWithoutUserCertificateInput;
    User: UserCreateNestedOneWithoutUserCertificateInput;
  };

  export type UserCertificateUncheckedCreateInput = {
    idCourse: number;
    idUser: number;
  };

  export type UserCertificateUpdateInput = {
    Certificate?: CertificateUpdateOneRequiredWithoutUserCertificateNestedInput;
    User?: UserUpdateOneRequiredWithoutUserCertificateNestedInput;
  };

  export type UserCertificateUncheckedUpdateInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idUser?: IntFieldUpdateOperationsInput | number;
  };

  export type UserCertificateCreateManyInput = {
    idCourse: number;
    idUser: number;
  };

  export type UserCertificateUpdateManyMutationInput = {};

  export type UserCertificateUncheckedUpdateManyInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idUser?: IntFieldUpdateOperationsInput | number;
  };

  export type UserCouponCreateInput = {
    Coupon: CouponCreateNestedOneWithoutUserCouponInput;
    User: UserCreateNestedOneWithoutUserCouponInput;
  };

  export type UserCouponUncheckedCreateInput = {
    idUser: number;
    idCoupon: number;
  };

  export type UserCouponUpdateInput = {
    Coupon?: CouponUpdateOneRequiredWithoutUserCouponNestedInput;
    User?: UserUpdateOneRequiredWithoutUserCouponNestedInput;
  };

  export type UserCouponUncheckedUpdateInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    idCoupon?: IntFieldUpdateOperationsInput | number;
  };

  export type UserCouponCreateManyInput = {
    idUser: number;
    idCoupon: number;
  };

  export type UserCouponUpdateManyMutationInput = {};

  export type UserCouponUncheckedUpdateManyInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    idCoupon?: IntFieldUpdateOperationsInput | number;
  };

  export type WishlistCreateInput = {
    Course: CourseCreateNestedOneWithoutWishlistInput;
    User: UserCreateNestedOneWithoutWishlistInput;
  };

  export type WishlistUncheckedCreateInput = {
    idUser: number;
    idCourse: number;
  };

  export type WishlistUpdateInput = {
    Course?: CourseUpdateOneRequiredWithoutWishlistNestedInput;
    User?: UserUpdateOneRequiredWithoutWishlistNestedInput;
  };

  export type WishlistUncheckedUpdateInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    idCourse?: IntFieldUpdateOperationsInput | number;
  };

  export type WishlistCreateManyInput = {
    idUser: number;
    idCourse: number;
  };

  export type WishlistUpdateManyMutationInput = {};

  export type WishlistUncheckedUpdateManyInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    idCourse?: IntFieldUpdateOperationsInput | number;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | null;
    notIn?: string[] | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type QuestionScalarRelationFilter = {
    is?: QuestionWhereInput;
    isNot?: QuestionWhereInput;
  };

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null;
    isNot?: UserWhereInput | null;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type AnswerOrderByRelevanceInput = {
    fields: AnswerOrderByRelevanceFieldEnum | AnswerOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type AnswerIdQuestionIdAnswerCompoundUniqueInput = {
    idQuestion: number;
    idAnswer: number;
  };

  export type AnswerCountOrderByAggregateInput = {
    idQuestion?: SortOrder;
    idAnswer?: SortOrder;
    idUser?: SortOrder;
    contentAnswer?: SortOrder;
  };

  export type AnswerAvgOrderByAggregateInput = {
    idQuestion?: SortOrder;
    idAnswer?: SortOrder;
    idUser?: SortOrder;
  };

  export type AnswerMaxOrderByAggregateInput = {
    idQuestion?: SortOrder;
    idAnswer?: SortOrder;
    idUser?: SortOrder;
    contentAnswer?: SortOrder;
  };

  export type AnswerMinOrderByAggregateInput = {
    idQuestion?: SortOrder;
    idAnswer?: SortOrder;
    idUser?: SortOrder;
    contentAnswer?: SortOrder;
  };

  export type AnswerSumOrderByAggregateInput = {
    idQuestion?: SortOrder;
    idAnswer?: SortOrder;
    idUser?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | null;
    notIn?: string[] | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput;
    isNot?: CourseWhereInput;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type CartIdUserIdCourseCompoundUniqueInput = {
    idUser: number;
    idCourse: number;
  };

  export type CartCountOrderByAggregateInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
  };

  export type CartAvgOrderByAggregateInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
  };

  export type CartMaxOrderByAggregateInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
  };

  export type CartMinOrderByAggregateInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
  };

  export type CartSumOrderByAggregateInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
  };

  export type CourseCategoryListRelationFilter = {
    every?: CourseCategoryWhereInput;
    some?: CourseCategoryWhereInput;
    none?: CourseCategoryWhereInput;
  };

  export type CourseCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CategoryOrderByRelevanceInput = {
    fields:
      | CategoryOrderByRelevanceFieldEnum
      | CategoryOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type CategoryCountOrderByAggregateInput = {
    idCategory?: SortOrder;
    nameCategory?: SortOrder;
  };

  export type CategoryAvgOrderByAggregateInput = {
    idCategory?: SortOrder;
  };

  export type CategoryMaxOrderByAggregateInput = {
    idCategory?: SortOrder;
    nameCategory?: SortOrder;
  };

  export type CategoryMinOrderByAggregateInput = {
    idCategory?: SortOrder;
    nameCategory?: SortOrder;
  };

  export type CategorySumOrderByAggregateInput = {
    idCategory?: SortOrder;
  };

  export type UserCertificateListRelationFilter = {
    every?: UserCertificateWhereInput;
    some?: UserCertificateWhereInput;
    none?: UserCertificateWhereInput;
  };

  export type UserCertificateOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CertificateOrderByRelevanceInput = {
    fields:
      | CertificateOrderByRelevanceFieldEnum
      | CertificateOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type CertificateCountOrderByAggregateInput = {
    idCourse?: SortOrder;
    certificate?: SortOrder;
  };

  export type CertificateAvgOrderByAggregateInput = {
    idCourse?: SortOrder;
  };

  export type CertificateMaxOrderByAggregateInput = {
    idCourse?: SortOrder;
    certificate?: SortOrder;
  };

  export type CertificateMinOrderByAggregateInput = {
    idCourse?: SortOrder;
    certificate?: SortOrder;
  };

  export type CertificateSumOrderByAggregateInput = {
    idCourse?: SortOrder;
  };

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
      | null;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null;
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | null;
    notIn?: Date[] | string[] | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type CouponCourseListRelationFilter = {
    every?: CouponCourseWhereInput;
    some?: CouponCourseWhereInput;
    none?: CouponCourseWhereInput;
  };

  export type UserCouponListRelationFilter = {
    every?: UserCouponWhereInput;
    some?: UserCouponWhereInput;
    none?: UserCouponWhereInput;
  };

  export type CouponCourseOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCouponOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CouponOrderByRelevanceInput = {
    fields: CouponOrderByRelevanceFieldEnum | CouponOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type CouponCountOrderByAggregateInput = {
    idCoupon?: SortOrder;
    type?: SortOrder;
    value?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    quantity?: SortOrder;
    appliedAmount?: SortOrder;
    minRequire?: SortOrder;
    maxValueDiscount?: SortOrder;
    code?: SortOrder;
    idUser?: SortOrder;
  };

  export type CouponAvgOrderByAggregateInput = {
    idCoupon?: SortOrder;
    value?: SortOrder;
    quantity?: SortOrder;
    appliedAmount?: SortOrder;
    minRequire?: SortOrder;
    maxValueDiscount?: SortOrder;
    idUser?: SortOrder;
  };

  export type CouponMaxOrderByAggregateInput = {
    idCoupon?: SortOrder;
    type?: SortOrder;
    value?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    quantity?: SortOrder;
    appliedAmount?: SortOrder;
    minRequire?: SortOrder;
    maxValueDiscount?: SortOrder;
    code?: SortOrder;
    idUser?: SortOrder;
  };

  export type CouponMinOrderByAggregateInput = {
    idCoupon?: SortOrder;
    type?: SortOrder;
    value?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    quantity?: SortOrder;
    appliedAmount?: SortOrder;
    minRequire?: SortOrder;
    maxValueDiscount?: SortOrder;
    code?: SortOrder;
    idUser?: SortOrder;
  };

  export type CouponSumOrderByAggregateInput = {
    idCoupon?: SortOrder;
    value?: SortOrder;
    quantity?: SortOrder;
    appliedAmount?: SortOrder;
    minRequire?: SortOrder;
    maxValueDiscount?: SortOrder;
    idUser?: SortOrder;
  };

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
      | null;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null;
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedDecimalNullableFilter<$PrismaModel>;
    _sum?: NestedDecimalNullableFilter<$PrismaModel>;
    _min?: NestedDecimalNullableFilter<$PrismaModel>;
    _max?: NestedDecimalNullableFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | null;
    notIn?: Date[] | string[] | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type CouponScalarRelationFilter = {
    is?: CouponWhereInput;
    isNot?: CouponWhereInput;
  };

  export type CouponCourseIdCouponIdCourseCompoundUniqueInput = {
    idCoupon: number;
    idCourse: number;
  };

  export type CouponCourseCountOrderByAggregateInput = {
    idCoupon?: SortOrder;
    idCourse?: SortOrder;
  };

  export type CouponCourseAvgOrderByAggregateInput = {
    idCoupon?: SortOrder;
    idCourse?: SortOrder;
  };

  export type CouponCourseMaxOrderByAggregateInput = {
    idCoupon?: SortOrder;
    idCourse?: SortOrder;
  };

  export type CouponCourseMinOrderByAggregateInput = {
    idCoupon?: SortOrder;
    idCourse?: SortOrder;
  };

  export type CouponCourseSumOrderByAggregateInput = {
    idCoupon?: SortOrder;
    idCourse?: SortOrder;
  };

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null;
  };

  export type CartListRelationFilter = {
    every?: CartWhereInput;
    some?: CartWhereInput;
    none?: CartWhereInput;
  };

  export type CertificateNullableScalarRelationFilter = {
    is?: CertificateWhereInput | null;
    isNot?: CertificateWhereInput | null;
  };

  export type CourseObjectiveListRelationFilter = {
    every?: CourseObjectiveWhereInput;
    some?: CourseObjectiveWhereInput;
    none?: CourseObjectiveWhereInput;
  };

  export type EnrollmentListRelationFilter = {
    every?: EnrollmentWhereInput;
    some?: EnrollmentWhereInput;
    none?: EnrollmentWhereInput;
  };

  export type PaymentDetailListRelationFilter = {
    every?: PaymentDetailWhereInput;
    some?: PaymentDetailWhereInput;
    none?: PaymentDetailWhereInput;
  };

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput;
    some?: ReviewWhereInput;
    none?: ReviewWhereInput;
  };

  export type SectionListRelationFilter = {
    every?: SectionWhereInput;
    some?: SectionWhereInput;
    none?: SectionWhereInput;
  };

  export type StudyRemindListRelationFilter = {
    every?: StudyRemindWhereInput;
    some?: StudyRemindWhereInput;
    none?: StudyRemindWhereInput;
  };

  export type WishlistListRelationFilter = {
    every?: WishlistWhereInput;
    some?: WishlistWhereInput;
    none?: WishlistWhereInput;
  };

  export type CartOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CourseObjectiveOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type EnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type PaymentDetailOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SectionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type StudyRemindOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type WishlistOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CourseOrderByRelevanceInput = {
    fields: CourseOrderByRelevanceFieldEnum | CourseOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type CourseCountOrderByAggregateInput = {
    idCourse?: SortOrder;
    idUser?: SortOrder;
    title?: SortOrder;
    subTitle?: SortOrder;
    description?: SortOrder;
    price?: SortOrder;
    isPublic?: SortOrder;
    isAccepted?: SortOrder;
    thumbnail?: SortOrder;
    requirement?: SortOrder;
    targetAudience?: SortOrder;
  };

  export type CourseAvgOrderByAggregateInput = {
    idCourse?: SortOrder;
    idUser?: SortOrder;
    price?: SortOrder;
  };

  export type CourseMaxOrderByAggregateInput = {
    idCourse?: SortOrder;
    idUser?: SortOrder;
    title?: SortOrder;
    subTitle?: SortOrder;
    description?: SortOrder;
    price?: SortOrder;
    isPublic?: SortOrder;
    isAccepted?: SortOrder;
    thumbnail?: SortOrder;
    requirement?: SortOrder;
    targetAudience?: SortOrder;
  };

  export type CourseMinOrderByAggregateInput = {
    idCourse?: SortOrder;
    idUser?: SortOrder;
    title?: SortOrder;
    subTitle?: SortOrder;
    description?: SortOrder;
    price?: SortOrder;
    isPublic?: SortOrder;
    isAccepted?: SortOrder;
    thumbnail?: SortOrder;
    requirement?: SortOrder;
    targetAudience?: SortOrder;
  };

  export type CourseSumOrderByAggregateInput = {
    idCourse?: SortOrder;
    idUser?: SortOrder;
    price?: SortOrder;
  };

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedBoolNullableFilter<$PrismaModel>;
    _max?: NestedBoolNullableFilter<$PrismaModel>;
  };

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput;
    isNot?: CategoryWhereInput;
  };

  export type CourseCategoryIdCourseIdCategoryCompoundUniqueInput = {
    idCourse: number;
    idCategory: number;
  };

  export type CourseCategoryCountOrderByAggregateInput = {
    idCourse?: SortOrder;
    idCategory?: SortOrder;
  };

  export type CourseCategoryAvgOrderByAggregateInput = {
    idCourse?: SortOrder;
    idCategory?: SortOrder;
  };

  export type CourseCategoryMaxOrderByAggregateInput = {
    idCourse?: SortOrder;
    idCategory?: SortOrder;
  };

  export type CourseCategoryMinOrderByAggregateInput = {
    idCourse?: SortOrder;
    idCategory?: SortOrder;
  };

  export type CourseCategorySumOrderByAggregateInput = {
    idCourse?: SortOrder;
    idCategory?: SortOrder;
  };

  export type CourseObjectiveOrderByRelevanceInput = {
    fields:
      | CourseObjectiveOrderByRelevanceFieldEnum
      | CourseObjectiveOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type CourseObjectiveIdCourseIdCourseObjectiveCompoundUniqueInput = {
    idCourse: number;
    idCourseObjective: number;
  };

  export type CourseObjectiveCountOrderByAggregateInput = {
    idCourse?: SortOrder;
    idCourseObjective?: SortOrder;
    content?: SortOrder;
  };

  export type CourseObjectiveAvgOrderByAggregateInput = {
    idCourse?: SortOrder;
    idCourseObjective?: SortOrder;
  };

  export type CourseObjectiveMaxOrderByAggregateInput = {
    idCourse?: SortOrder;
    idCourseObjective?: SortOrder;
    content?: SortOrder;
  };

  export type CourseObjectiveMinOrderByAggregateInput = {
    idCourse?: SortOrder;
    idCourseObjective?: SortOrder;
    content?: SortOrder;
  };

  export type CourseObjectiveSumOrderByAggregateInput = {
    idCourse?: SortOrder;
    idCourseObjective?: SortOrder;
  };

  export type EnrollmentIdUserIdCourseCompoundUniqueInput = {
    idUser: number;
    idCourse: number;
  };

  export type EnrollmentCountOrderByAggregateInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
    dateRegister?: SortOrder;
    finishStatus?: SortOrder;
    progress?: SortOrder;
  };

  export type EnrollmentAvgOrderByAggregateInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
    progress?: SortOrder;
  };

  export type EnrollmentMaxOrderByAggregateInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
    dateRegister?: SortOrder;
    finishStatus?: SortOrder;
    progress?: SortOrder;
  };

  export type EnrollmentMinOrderByAggregateInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
    dateRegister?: SortOrder;
    finishStatus?: SortOrder;
    progress?: SortOrder;
  };

  export type EnrollmentSumOrderByAggregateInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
    progress?: SortOrder;
  };

  export type FollowIdFollowerIdFollowingCompoundUniqueInput = {
    idFollower: number;
    idFollowing: number;
  };

  export type FollowCountOrderByAggregateInput = {
    idFollower?: SortOrder;
    idFollowing?: SortOrder;
  };

  export type FollowAvgOrderByAggregateInput = {
    idFollower?: SortOrder;
    idFollowing?: SortOrder;
  };

  export type FollowMaxOrderByAggregateInput = {
    idFollower?: SortOrder;
    idFollowing?: SortOrder;
  };

  export type FollowMinOrderByAggregateInput = {
    idFollower?: SortOrder;
    idFollowing?: SortOrder;
  };

  export type FollowSumOrderByAggregateInput = {
    idFollower?: SortOrder;
    idFollowing?: SortOrder;
  };

  export type SectionScalarRelationFilter = {
    is?: SectionWhereInput;
    isNot?: SectionWhereInput;
  };

  export type NoteListRelationFilter = {
    every?: NoteWhereInput;
    some?: NoteWhereInput;
    none?: NoteWhereInput;
  };

  export type QuestionListRelationFilter = {
    every?: QuestionWhereInput;
    some?: QuestionWhereInput;
    none?: QuestionWhereInput;
  };

  export type NoteOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type QuestionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type LectureOrderByRelevanceInput = {
    fields:
      | LectureOrderByRelevanceFieldEnum
      | LectureOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type LectureIdCourseIdSectionIdLectureCompoundUniqueInput = {
    idCourse: number;
    idSection: number;
    idLecture: number;
  };

  export type LectureCountOrderByAggregateInput = {
    idCourse?: SortOrder;
    idSection?: SortOrder;
    idLecture?: SortOrder;
    nameLecture?: SortOrder;
    isDone?: SortOrder;
  };

  export type LectureAvgOrderByAggregateInput = {
    idCourse?: SortOrder;
    idSection?: SortOrder;
    idLecture?: SortOrder;
  };

  export type LectureMaxOrderByAggregateInput = {
    idCourse?: SortOrder;
    idSection?: SortOrder;
    idLecture?: SortOrder;
    nameLecture?: SortOrder;
    isDone?: SortOrder;
  };

  export type LectureMinOrderByAggregateInput = {
    idCourse?: SortOrder;
    idSection?: SortOrder;
    idLecture?: SortOrder;
    nameLecture?: SortOrder;
    isDone?: SortOrder;
  };

  export type LectureSumOrderByAggregateInput = {
    idCourse?: SortOrder;
    idSection?: SortOrder;
    idLecture?: SortOrder;
  };

  export type MessageOrderByRelevanceInput = {
    fields:
      | MessageOrderByRelevanceFieldEnum
      | MessageOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type MessageCountOrderByAggregateInput = {
    idMessage?: SortOrder;
    idUserSender?: SortOrder;
    idUserReceiver?: SortOrder;
    message?: SortOrder;
    timeSend?: SortOrder;
  };

  export type MessageAvgOrderByAggregateInput = {
    idMessage?: SortOrder;
    idUserSender?: SortOrder;
    idUserReceiver?: SortOrder;
  };

  export type MessageMaxOrderByAggregateInput = {
    idMessage?: SortOrder;
    idUserSender?: SortOrder;
    idUserReceiver?: SortOrder;
    message?: SortOrder;
    timeSend?: SortOrder;
  };

  export type MessageMinOrderByAggregateInput = {
    idMessage?: SortOrder;
    idUserSender?: SortOrder;
    idUserReceiver?: SortOrder;
    message?: SortOrder;
    timeSend?: SortOrder;
  };

  export type MessageSumOrderByAggregateInput = {
    idMessage?: SortOrder;
    idUserSender?: SortOrder;
    idUserReceiver?: SortOrder;
  };

  export type LectureNullableScalarRelationFilter = {
    is?: LectureWhereInput | null;
    isNot?: LectureWhereInput | null;
  };

  export type NoteOrderByRelevanceInput = {
    fields: NoteOrderByRelevanceFieldEnum | NoteOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type NoteCountOrderByAggregateInput = {
    idNote?: SortOrder;
    timeNote?: SortOrder;
    note?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
    idSection?: SortOrder;
    idLecture?: SortOrder;
  };

  export type NoteAvgOrderByAggregateInput = {
    idNote?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
    idSection?: SortOrder;
    idLecture?: SortOrder;
  };

  export type NoteMaxOrderByAggregateInput = {
    idNote?: SortOrder;
    timeNote?: SortOrder;
    note?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
    idSection?: SortOrder;
    idLecture?: SortOrder;
  };

  export type NoteMinOrderByAggregateInput = {
    idNote?: SortOrder;
    timeNote?: SortOrder;
    note?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
    idSection?: SortOrder;
    idLecture?: SortOrder;
  };

  export type NoteSumOrderByAggregateInput = {
    idNote?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
    idSection?: SortOrder;
    idLecture?: SortOrder;
  };

  export type NotificationReceiverListRelationFilter = {
    every?: NotificationReceiverWhereInput;
    some?: NotificationReceiverWhereInput;
    none?: NotificationReceiverWhereInput;
  };

  export type NotificationReceiverOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type NotificationOrderByRelevanceInput = {
    fields:
      | NotificationOrderByRelevanceFieldEnum
      | NotificationOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type NotificationCountOrderByAggregateInput = {
    idNotification?: SortOrder;
    contentNotification?: SortOrder;
    idUser?: SortOrder;
  };

  export type NotificationAvgOrderByAggregateInput = {
    idNotification?: SortOrder;
    idUser?: SortOrder;
  };

  export type NotificationMaxOrderByAggregateInput = {
    idNotification?: SortOrder;
    contentNotification?: SortOrder;
    idUser?: SortOrder;
  };

  export type NotificationMinOrderByAggregateInput = {
    idNotification?: SortOrder;
    contentNotification?: SortOrder;
    idUser?: SortOrder;
  };

  export type NotificationSumOrderByAggregateInput = {
    idNotification?: SortOrder;
    idUser?: SortOrder;
  };

  export type NotificationScalarRelationFilter = {
    is?: NotificationWhereInput;
    isNot?: NotificationWhereInput;
  };

  export type NotificationReceiverIdNotificationIdUserCompoundUniqueInput = {
    idNotification: number;
    idUser: number;
  };

  export type NotificationReceiverCountOrderByAggregateInput = {
    idNotification?: SortOrder;
    idUser?: SortOrder;
    timeGetNotification?: SortOrder;
  };

  export type NotificationReceiverAvgOrderByAggregateInput = {
    idNotification?: SortOrder;
    idUser?: SortOrder;
  };

  export type NotificationReceiverMaxOrderByAggregateInput = {
    idNotification?: SortOrder;
    idUser?: SortOrder;
    timeGetNotification?: SortOrder;
  };

  export type NotificationReceiverMinOrderByAggregateInput = {
    idNotification?: SortOrder;
    idUser?: SortOrder;
    timeGetNotification?: SortOrder;
  };

  export type NotificationReceiverSumOrderByAggregateInput = {
    idNotification?: SortOrder;
    idUser?: SortOrder;
  };

  export type PaymentCountOrderByAggregateInput = {
    idPayment?: SortOrder;
    timePayment?: SortOrder;
    totalPrice?: SortOrder;
    idUser?: SortOrder;
  };

  export type PaymentAvgOrderByAggregateInput = {
    idPayment?: SortOrder;
    totalPrice?: SortOrder;
    idUser?: SortOrder;
  };

  export type PaymentMaxOrderByAggregateInput = {
    idPayment?: SortOrder;
    timePayment?: SortOrder;
    totalPrice?: SortOrder;
    idUser?: SortOrder;
  };

  export type PaymentMinOrderByAggregateInput = {
    idPayment?: SortOrder;
    timePayment?: SortOrder;
    totalPrice?: SortOrder;
    idUser?: SortOrder;
  };

  export type PaymentSumOrderByAggregateInput = {
    idPayment?: SortOrder;
    totalPrice?: SortOrder;
    idUser?: SortOrder;
  };

  export type PaymentScalarRelationFilter = {
    is?: PaymentWhereInput;
    isNot?: PaymentWhereInput;
  };

  export type PaymentDetailIdPaymentIdCourseCompoundUniqueInput = {
    idPayment: number;
    idCourse: number;
  };

  export type PaymentDetailCountOrderByAggregateInput = {
    idPayment?: SortOrder;
    idCourse?: SortOrder;
    price?: SortOrder;
  };

  export type PaymentDetailAvgOrderByAggregateInput = {
    idPayment?: SortOrder;
    idCourse?: SortOrder;
    price?: SortOrder;
  };

  export type PaymentDetailMaxOrderByAggregateInput = {
    idPayment?: SortOrder;
    idCourse?: SortOrder;
    price?: SortOrder;
  };

  export type PaymentDetailMinOrderByAggregateInput = {
    idPayment?: SortOrder;
    idCourse?: SortOrder;
    price?: SortOrder;
  };

  export type PaymentDetailSumOrderByAggregateInput = {
    idPayment?: SortOrder;
    idCourse?: SortOrder;
    price?: SortOrder;
  };

  export type AnswerListRelationFilter = {
    every?: AnswerWhereInput;
    some?: AnswerWhereInput;
    none?: AnswerWhereInput;
  };

  export type AnswerOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type QuestionOrderByRelevanceInput = {
    fields:
      | QuestionOrderByRelevanceFieldEnum
      | QuestionOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type QuestionCountOrderByAggregateInput = {
    idQuestion?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
    idSection?: SortOrder;
    idLecture?: SortOrder;
    contentQuestion?: SortOrder;
  };

  export type QuestionAvgOrderByAggregateInput = {
    idQuestion?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
    idSection?: SortOrder;
    idLecture?: SortOrder;
  };

  export type QuestionMaxOrderByAggregateInput = {
    idQuestion?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
    idSection?: SortOrder;
    idLecture?: SortOrder;
    contentQuestion?: SortOrder;
  };

  export type QuestionMinOrderByAggregateInput = {
    idQuestion?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
    idSection?: SortOrder;
    idLecture?: SortOrder;
    contentQuestion?: SortOrder;
  };

  export type QuestionSumOrderByAggregateInput = {
    idQuestion?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
    idSection?: SortOrder;
    idLecture?: SortOrder;
  };

  export type ReportOrderByRelevanceInput = {
    fields: ReportOrderByRelevanceFieldEnum | ReportOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type ReportCountOrderByAggregateInput = {
    idReport?: SortOrder;
    idUser?: SortOrder;
    contentReport?: SortOrder;
  };

  export type ReportAvgOrderByAggregateInput = {
    idReport?: SortOrder;
    idUser?: SortOrder;
  };

  export type ReportMaxOrderByAggregateInput = {
    idReport?: SortOrder;
    idUser?: SortOrder;
    contentReport?: SortOrder;
  };

  export type ReportMinOrderByAggregateInput = {
    idReport?: SortOrder;
    idUser?: SortOrder;
    contentReport?: SortOrder;
  };

  export type ReportSumOrderByAggregateInput = {
    idReport?: SortOrder;
    idUser?: SortOrder;
  };

  export type CourseNullableScalarRelationFilter = {
    is?: CourseWhereInput | null;
    isNot?: CourseWhereInput | null;
  };

  export type ReviewOrderByRelevanceInput = {
    fields: ReviewOrderByRelevanceFieldEnum | ReviewOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type ReviewCountOrderByAggregateInput = {
    idReview?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
    rating?: SortOrder;
    review?: SortOrder;
  };

  export type ReviewAvgOrderByAggregateInput = {
    idReview?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
    rating?: SortOrder;
  };

  export type ReviewMaxOrderByAggregateInput = {
    idReview?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
    rating?: SortOrder;
    review?: SortOrder;
  };

  export type ReviewMinOrderByAggregateInput = {
    idReview?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
    rating?: SortOrder;
    review?: SortOrder;
  };

  export type ReviewSumOrderByAggregateInput = {
    idReview?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
    rating?: SortOrder;
  };

  export type LectureListRelationFilter = {
    every?: LectureWhereInput;
    some?: LectureWhereInput;
    none?: LectureWhereInput;
  };

  export type LectureOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SectionOrderByRelevanceInput = {
    fields:
      | SectionOrderByRelevanceFieldEnum
      | SectionOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type SectionIdCourseIdSectionCompoundUniqueInput = {
    idCourse: number;
    idSection: number;
  };

  export type SectionCountOrderByAggregateInput = {
    idCourse?: SortOrder;
    idSection?: SortOrder;
    nameSection?: SortOrder;
  };

  export type SectionAvgOrderByAggregateInput = {
    idCourse?: SortOrder;
    idSection?: SortOrder;
  };

  export type SectionMaxOrderByAggregateInput = {
    idCourse?: SortOrder;
    idSection?: SortOrder;
    nameSection?: SortOrder;
  };

  export type SectionMinOrderByAggregateInput = {
    idCourse?: SortOrder;
    idSection?: SortOrder;
    nameSection?: SortOrder;
  };

  export type SectionSumOrderByAggregateInput = {
    idCourse?: SortOrder;
    idSection?: SortOrder;
  };

  export type StudyRemindOrderByRelevanceInput = {
    fields:
      | StudyRemindOrderByRelevanceFieldEnum
      | StudyRemindOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type StudyRemindCountOrderByAggregateInput = {
    idStudyRemind?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
    timeRemind?: SortOrder;
    typeRemind?: SortOrder;
  };

  export type StudyRemindAvgOrderByAggregateInput = {
    idStudyRemind?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
  };

  export type StudyRemindMaxOrderByAggregateInput = {
    idStudyRemind?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
    timeRemind?: SortOrder;
    typeRemind?: SortOrder;
  };

  export type StudyRemindMinOrderByAggregateInput = {
    idStudyRemind?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
    timeRemind?: SortOrder;
    typeRemind?: SortOrder;
  };

  export type StudyRemindSumOrderByAggregateInput = {
    idStudyRemind?: SortOrder;
    idUser?: SortOrder;
    idCourse?: SortOrder;
  };

  export type CouponListRelationFilter = {
    every?: CouponWhereInput;
    some?: CouponWhereInput;
    none?: CouponWhereInput;
  };

  export type CourseListRelationFilter = {
    every?: CourseWhereInput;
    some?: CourseWhereInput;
    none?: CourseWhereInput;
  };

  export type FollowListRelationFilter = {
    every?: FollowWhereInput;
    some?: FollowWhereInput;
    none?: FollowWhereInput;
  };

  export type MessageListRelationFilter = {
    every?: MessageWhereInput;
    some?: MessageWhereInput;
    none?: MessageWhereInput;
  };

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput;
    some?: NotificationWhereInput;
    none?: NotificationWhereInput;
  };

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput;
    some?: PaymentWhereInput;
    none?: PaymentWhereInput;
  };

  export type ReportListRelationFilter = {
    every?: ReportWhereInput;
    some?: ReportWhereInput;
    none?: ReportWhereInput;
  };

  export type CouponOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type FollowOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type UserCountOrderByAggregateInput = {
    idUser?: SortOrder;
    name?: SortOrder;
    biography?: SortOrder;
    role?: SortOrder;
    gender?: SortOrder;
    birthday?: SortOrder;
    codeExpired?: SortOrder;
    codeId?: SortOrder;
    email?: SortOrder;
    password?: SortOrder;
  };

  export type UserAvgOrderByAggregateInput = {
    idUser?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    idUser?: SortOrder;
    name?: SortOrder;
    biography?: SortOrder;
    role?: SortOrder;
    gender?: SortOrder;
    birthday?: SortOrder;
    codeExpired?: SortOrder;
    codeId?: SortOrder;
    email?: SortOrder;
    password?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    idUser?: SortOrder;
    name?: SortOrder;
    biography?: SortOrder;
    role?: SortOrder;
    gender?: SortOrder;
    birthday?: SortOrder;
    codeExpired?: SortOrder;
    codeId?: SortOrder;
    email?: SortOrder;
    password?: SortOrder;
  };

  export type UserSumOrderByAggregateInput = {
    idUser?: SortOrder;
  };

  export type CertificateScalarRelationFilter = {
    is?: CertificateWhereInput;
    isNot?: CertificateWhereInput;
  };

  export type UserCertificateIdCourseIdUserCompoundUniqueInput = {
    idCourse: number;
    idUser: number;
  };

  export type UserCertificateCountOrderByAggregateInput = {
    idCourse?: SortOrder;
    idUser?: SortOrder;
  };

  export type UserCertificateAvgOrderByAggregateInput = {
    idCourse?: SortOrder;
    idUser?: SortOrder;
  };

  export type UserCertificateMaxOrderByAggregateInput = {
    idCourse?: SortOrder;
    idUser?: SortOrder;
  };

  export type UserCertificateMinOrderByAggregateInput = {
    idCourse?: SortOrder;
    idUser?: SortOrder;
  };

  export type UserCertificateSumOrderByAggregateInput = {
    idCourse?: SortOrder;
    idUser?: SortOrder;
  };

  export type UserCouponIdUserIdCouponCompoundUniqueInput = {
    idUser: number;
    idCoupon: number;
  };

  export type UserCouponCountOrderByAggregateInput = {
    idUser?: SortOrder;
    idCoupon?: SortOrder;
  };

  export type UserCouponAvgOrderByAggregateInput = {
    idUser?: SortOrder;
    idCoupon?: SortOrder;
  };

  export type UserCouponMaxOrderByAggregateInput = {
    idUser?: SortOrder;
    idCoupon?: SortOrder;
  };

  export type UserCouponMinOrderByAggregateInput = {
    idUser?: SortOrder;
    idCoupon?: SortOrder;
  };

  export type UserCouponSumOrderByAggregateInput = {
    idUser?: SortOrder;
    idCoupon?: SortOrder;
  };

  export type WishlistIdUserIdCourseCompoundUniqueInput = {
    idUser: number;
    idCourse: number;
  };

  export type WishlistCountOrderByAggregateInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
  };

  export type WishlistAvgOrderByAggregateInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
  };

  export type WishlistMaxOrderByAggregateInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
  };

  export type WishlistMinOrderByAggregateInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
  };

  export type WishlistSumOrderByAggregateInput = {
    idUser?: SortOrder;
    idCourse?: SortOrder;
  };

  export type QuestionCreateNestedOneWithoutAnswerInput = {
    create?: XOR<
      QuestionCreateWithoutAnswerInput,
      QuestionUncheckedCreateWithoutAnswerInput
    >;
    connectOrCreate?: QuestionCreateOrConnectWithoutAnswerInput;
    connect?: QuestionWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutAnswerInput = {
    create?: XOR<
      UserCreateWithoutAnswerInput,
      UserUncheckedCreateWithoutAnswerInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAnswerInput;
    connect?: UserWhereUniqueInput;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type QuestionUpdateOneRequiredWithoutAnswerNestedInput = {
    create?: XOR<
      QuestionCreateWithoutAnswerInput,
      QuestionUncheckedCreateWithoutAnswerInput
    >;
    connectOrCreate?: QuestionCreateOrConnectWithoutAnswerInput;
    upsert?: QuestionUpsertWithoutAnswerInput;
    connect?: QuestionWhereUniqueInput;
    update?: XOR<
      XOR<
        QuestionUpdateToOneWithWhereWithoutAnswerInput,
        QuestionUpdateWithoutAnswerInput
      >,
      QuestionUncheckedUpdateWithoutAnswerInput
    >;
  };

  export type UserUpdateOneWithoutAnswerNestedInput = {
    create?: XOR<
      UserCreateWithoutAnswerInput,
      UserUncheckedCreateWithoutAnswerInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAnswerInput;
    upsert?: UserUpsertWithoutAnswerInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutAnswerInput,
        UserUpdateWithoutAnswerInput
      >,
      UserUncheckedUpdateWithoutAnswerInput
    >;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type CourseCreateNestedOneWithoutCartInput = {
    create?: XOR<
      CourseCreateWithoutCartInput,
      CourseUncheckedCreateWithoutCartInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutCartInput;
    connect?: CourseWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutCartInput = {
    create?: XOR<
      UserCreateWithoutCartInput,
      UserUncheckedCreateWithoutCartInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCartInput;
    connect?: UserWhereUniqueInput;
  };

  export type CourseUpdateOneRequiredWithoutCartNestedInput = {
    create?: XOR<
      CourseCreateWithoutCartInput,
      CourseUncheckedCreateWithoutCartInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutCartInput;
    upsert?: CourseUpsertWithoutCartInput;
    connect?: CourseWhereUniqueInput;
    update?: XOR<
      XOR<
        CourseUpdateToOneWithWhereWithoutCartInput,
        CourseUpdateWithoutCartInput
      >,
      CourseUncheckedUpdateWithoutCartInput
    >;
  };

  export type UserUpdateOneRequiredWithoutCartNestedInput = {
    create?: XOR<
      UserCreateWithoutCartInput,
      UserUncheckedCreateWithoutCartInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCartInput;
    upsert?: UserUpsertWithoutCartInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutCartInput, UserUpdateWithoutCartInput>,
      UserUncheckedUpdateWithoutCartInput
    >;
  };

  export type CourseCategoryCreateNestedManyWithoutCategoryInput = {
    create?:
      | XOR<
          CourseCategoryCreateWithoutCategoryInput,
          CourseCategoryUncheckedCreateWithoutCategoryInput
        >
      | CourseCategoryCreateWithoutCategoryInput[]
      | CourseCategoryUncheckedCreateWithoutCategoryInput[];
    connectOrCreate?:
      | CourseCategoryCreateOrConnectWithoutCategoryInput
      | CourseCategoryCreateOrConnectWithoutCategoryInput[];
    createMany?: CourseCategoryCreateManyCategoryInputEnvelope;
    connect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[];
  };

  export type CourseCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?:
      | XOR<
          CourseCategoryCreateWithoutCategoryInput,
          CourseCategoryUncheckedCreateWithoutCategoryInput
        >
      | CourseCategoryCreateWithoutCategoryInput[]
      | CourseCategoryUncheckedCreateWithoutCategoryInput[];
    connectOrCreate?:
      | CourseCategoryCreateOrConnectWithoutCategoryInput
      | CourseCategoryCreateOrConnectWithoutCategoryInput[];
    createMany?: CourseCategoryCreateManyCategoryInputEnvelope;
    connect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[];
  };

  export type CourseCategoryUpdateManyWithoutCategoryNestedInput = {
    create?:
      | XOR<
          CourseCategoryCreateWithoutCategoryInput,
          CourseCategoryUncheckedCreateWithoutCategoryInput
        >
      | CourseCategoryCreateWithoutCategoryInput[]
      | CourseCategoryUncheckedCreateWithoutCategoryInput[];
    connectOrCreate?:
      | CourseCategoryCreateOrConnectWithoutCategoryInput
      | CourseCategoryCreateOrConnectWithoutCategoryInput[];
    upsert?:
      | CourseCategoryUpsertWithWhereUniqueWithoutCategoryInput
      | CourseCategoryUpsertWithWhereUniqueWithoutCategoryInput[];
    createMany?: CourseCategoryCreateManyCategoryInputEnvelope;
    set?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[];
    disconnect?:
      | CourseCategoryWhereUniqueInput
      | CourseCategoryWhereUniqueInput[];
    delete?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[];
    connect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[];
    update?:
      | CourseCategoryUpdateWithWhereUniqueWithoutCategoryInput
      | CourseCategoryUpdateWithWhereUniqueWithoutCategoryInput[];
    updateMany?:
      | CourseCategoryUpdateManyWithWhereWithoutCategoryInput
      | CourseCategoryUpdateManyWithWhereWithoutCategoryInput[];
    deleteMany?:
      | CourseCategoryScalarWhereInput
      | CourseCategoryScalarWhereInput[];
  };

  export type CourseCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?:
      | XOR<
          CourseCategoryCreateWithoutCategoryInput,
          CourseCategoryUncheckedCreateWithoutCategoryInput
        >
      | CourseCategoryCreateWithoutCategoryInput[]
      | CourseCategoryUncheckedCreateWithoutCategoryInput[];
    connectOrCreate?:
      | CourseCategoryCreateOrConnectWithoutCategoryInput
      | CourseCategoryCreateOrConnectWithoutCategoryInput[];
    upsert?:
      | CourseCategoryUpsertWithWhereUniqueWithoutCategoryInput
      | CourseCategoryUpsertWithWhereUniqueWithoutCategoryInput[];
    createMany?: CourseCategoryCreateManyCategoryInputEnvelope;
    set?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[];
    disconnect?:
      | CourseCategoryWhereUniqueInput
      | CourseCategoryWhereUniqueInput[];
    delete?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[];
    connect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[];
    update?:
      | CourseCategoryUpdateWithWhereUniqueWithoutCategoryInput
      | CourseCategoryUpdateWithWhereUniqueWithoutCategoryInput[];
    updateMany?:
      | CourseCategoryUpdateManyWithWhereWithoutCategoryInput
      | CourseCategoryUpdateManyWithWhereWithoutCategoryInput[];
    deleteMany?:
      | CourseCategoryScalarWhereInput
      | CourseCategoryScalarWhereInput[];
  };

  export type CourseCreateNestedOneWithoutCertificateInput = {
    create?: XOR<
      CourseCreateWithoutCertificateInput,
      CourseUncheckedCreateWithoutCertificateInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutCertificateInput;
    connect?: CourseWhereUniqueInput;
  };

  export type UserCertificateCreateNestedManyWithoutCertificateInput = {
    create?:
      | XOR<
          UserCertificateCreateWithoutCertificateInput,
          UserCertificateUncheckedCreateWithoutCertificateInput
        >
      | UserCertificateCreateWithoutCertificateInput[]
      | UserCertificateUncheckedCreateWithoutCertificateInput[];
    connectOrCreate?:
      | UserCertificateCreateOrConnectWithoutCertificateInput
      | UserCertificateCreateOrConnectWithoutCertificateInput[];
    createMany?: UserCertificateCreateManyCertificateInputEnvelope;
    connect?:
      | UserCertificateWhereUniqueInput
      | UserCertificateWhereUniqueInput[];
  };

  export type UserCertificateUncheckedCreateNestedManyWithoutCertificateInput =
    {
      create?:
        | XOR<
            UserCertificateCreateWithoutCertificateInput,
            UserCertificateUncheckedCreateWithoutCertificateInput
          >
        | UserCertificateCreateWithoutCertificateInput[]
        | UserCertificateUncheckedCreateWithoutCertificateInput[];
      connectOrCreate?:
        | UserCertificateCreateOrConnectWithoutCertificateInput
        | UserCertificateCreateOrConnectWithoutCertificateInput[];
      createMany?: UserCertificateCreateManyCertificateInputEnvelope;
      connect?:
        | UserCertificateWhereUniqueInput
        | UserCertificateWhereUniqueInput[];
    };

  export type CourseUpdateOneRequiredWithoutCertificateNestedInput = {
    create?: XOR<
      CourseCreateWithoutCertificateInput,
      CourseUncheckedCreateWithoutCertificateInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutCertificateInput;
    upsert?: CourseUpsertWithoutCertificateInput;
    connect?: CourseWhereUniqueInput;
    update?: XOR<
      XOR<
        CourseUpdateToOneWithWhereWithoutCertificateInput,
        CourseUpdateWithoutCertificateInput
      >,
      CourseUncheckedUpdateWithoutCertificateInput
    >;
  };

  export type UserCertificateUpdateManyWithoutCertificateNestedInput = {
    create?:
      | XOR<
          UserCertificateCreateWithoutCertificateInput,
          UserCertificateUncheckedCreateWithoutCertificateInput
        >
      | UserCertificateCreateWithoutCertificateInput[]
      | UserCertificateUncheckedCreateWithoutCertificateInput[];
    connectOrCreate?:
      | UserCertificateCreateOrConnectWithoutCertificateInput
      | UserCertificateCreateOrConnectWithoutCertificateInput[];
    upsert?:
      | UserCertificateUpsertWithWhereUniqueWithoutCertificateInput
      | UserCertificateUpsertWithWhereUniqueWithoutCertificateInput[];
    createMany?: UserCertificateCreateManyCertificateInputEnvelope;
    set?: UserCertificateWhereUniqueInput | UserCertificateWhereUniqueInput[];
    disconnect?:
      | UserCertificateWhereUniqueInput
      | UserCertificateWhereUniqueInput[];
    delete?:
      | UserCertificateWhereUniqueInput
      | UserCertificateWhereUniqueInput[];
    connect?:
      | UserCertificateWhereUniqueInput
      | UserCertificateWhereUniqueInput[];
    update?:
      | UserCertificateUpdateWithWhereUniqueWithoutCertificateInput
      | UserCertificateUpdateWithWhereUniqueWithoutCertificateInput[];
    updateMany?:
      | UserCertificateUpdateManyWithWhereWithoutCertificateInput
      | UserCertificateUpdateManyWithWhereWithoutCertificateInput[];
    deleteMany?:
      | UserCertificateScalarWhereInput
      | UserCertificateScalarWhereInput[];
  };

  export type UserCertificateUncheckedUpdateManyWithoutCertificateNestedInput =
    {
      create?:
        | XOR<
            UserCertificateCreateWithoutCertificateInput,
            UserCertificateUncheckedCreateWithoutCertificateInput
          >
        | UserCertificateCreateWithoutCertificateInput[]
        | UserCertificateUncheckedCreateWithoutCertificateInput[];
      connectOrCreate?:
        | UserCertificateCreateOrConnectWithoutCertificateInput
        | UserCertificateCreateOrConnectWithoutCertificateInput[];
      upsert?:
        | UserCertificateUpsertWithWhereUniqueWithoutCertificateInput
        | UserCertificateUpsertWithWhereUniqueWithoutCertificateInput[];
      createMany?: UserCertificateCreateManyCertificateInputEnvelope;
      set?: UserCertificateWhereUniqueInput | UserCertificateWhereUniqueInput[];
      disconnect?:
        | UserCertificateWhereUniqueInput
        | UserCertificateWhereUniqueInput[];
      delete?:
        | UserCertificateWhereUniqueInput
        | UserCertificateWhereUniqueInput[];
      connect?:
        | UserCertificateWhereUniqueInput
        | UserCertificateWhereUniqueInput[];
      update?:
        | UserCertificateUpdateWithWhereUniqueWithoutCertificateInput
        | UserCertificateUpdateWithWhereUniqueWithoutCertificateInput[];
      updateMany?:
        | UserCertificateUpdateManyWithWhereWithoutCertificateInput
        | UserCertificateUpdateManyWithWhereWithoutCertificateInput[];
      deleteMany?:
        | UserCertificateScalarWhereInput
        | UserCertificateScalarWhereInput[];
    };

  export type UserCreateNestedOneWithoutCouponInput = {
    create?: XOR<
      UserCreateWithoutCouponInput,
      UserUncheckedCreateWithoutCouponInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCouponInput;
    connect?: UserWhereUniqueInput;
  };

  export type CouponCourseCreateNestedManyWithoutCouponInput = {
    create?:
      | XOR<
          CouponCourseCreateWithoutCouponInput,
          CouponCourseUncheckedCreateWithoutCouponInput
        >
      | CouponCourseCreateWithoutCouponInput[]
      | CouponCourseUncheckedCreateWithoutCouponInput[];
    connectOrCreate?:
      | CouponCourseCreateOrConnectWithoutCouponInput
      | CouponCourseCreateOrConnectWithoutCouponInput[];
    createMany?: CouponCourseCreateManyCouponInputEnvelope;
    connect?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
  };

  export type UserCouponCreateNestedManyWithoutCouponInput = {
    create?:
      | XOR<
          UserCouponCreateWithoutCouponInput,
          UserCouponUncheckedCreateWithoutCouponInput
        >
      | UserCouponCreateWithoutCouponInput[]
      | UserCouponUncheckedCreateWithoutCouponInput[];
    connectOrCreate?:
      | UserCouponCreateOrConnectWithoutCouponInput
      | UserCouponCreateOrConnectWithoutCouponInput[];
    createMany?: UserCouponCreateManyCouponInputEnvelope;
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
  };

  export type CouponCourseUncheckedCreateNestedManyWithoutCouponInput = {
    create?:
      | XOR<
          CouponCourseCreateWithoutCouponInput,
          CouponCourseUncheckedCreateWithoutCouponInput
        >
      | CouponCourseCreateWithoutCouponInput[]
      | CouponCourseUncheckedCreateWithoutCouponInput[];
    connectOrCreate?:
      | CouponCourseCreateOrConnectWithoutCouponInput
      | CouponCourseCreateOrConnectWithoutCouponInput[];
    createMany?: CouponCourseCreateManyCouponInputEnvelope;
    connect?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
  };

  export type UserCouponUncheckedCreateNestedManyWithoutCouponInput = {
    create?:
      | XOR<
          UserCouponCreateWithoutCouponInput,
          UserCouponUncheckedCreateWithoutCouponInput
        >
      | UserCouponCreateWithoutCouponInput[]
      | UserCouponUncheckedCreateWithoutCouponInput[];
    connectOrCreate?:
      | UserCouponCreateOrConnectWithoutCouponInput
      | UserCouponCreateOrConnectWithoutCouponInput[];
    createMany?: UserCouponCreateManyCouponInputEnvelope;
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
  };

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null;
    increment?: Decimal | DecimalJsLike | number | string;
    decrement?: Decimal | DecimalJsLike | number | string;
    multiply?: Decimal | DecimalJsLike | number | string;
    divide?: Decimal | DecimalJsLike | number | string;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type UserUpdateOneWithoutCouponNestedInput = {
    create?: XOR<
      UserCreateWithoutCouponInput,
      UserUncheckedCreateWithoutCouponInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCouponInput;
    upsert?: UserUpsertWithoutCouponInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutCouponInput,
        UserUpdateWithoutCouponInput
      >,
      UserUncheckedUpdateWithoutCouponInput
    >;
  };

  export type CouponCourseUpdateManyWithoutCouponNestedInput = {
    create?:
      | XOR<
          CouponCourseCreateWithoutCouponInput,
          CouponCourseUncheckedCreateWithoutCouponInput
        >
      | CouponCourseCreateWithoutCouponInput[]
      | CouponCourseUncheckedCreateWithoutCouponInput[];
    connectOrCreate?:
      | CouponCourseCreateOrConnectWithoutCouponInput
      | CouponCourseCreateOrConnectWithoutCouponInput[];
    upsert?:
      | CouponCourseUpsertWithWhereUniqueWithoutCouponInput
      | CouponCourseUpsertWithWhereUniqueWithoutCouponInput[];
    createMany?: CouponCourseCreateManyCouponInputEnvelope;
    set?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
    disconnect?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
    delete?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
    connect?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
    update?:
      | CouponCourseUpdateWithWhereUniqueWithoutCouponInput
      | CouponCourseUpdateWithWhereUniqueWithoutCouponInput[];
    updateMany?:
      | CouponCourseUpdateManyWithWhereWithoutCouponInput
      | CouponCourseUpdateManyWithWhereWithoutCouponInput[];
    deleteMany?: CouponCourseScalarWhereInput | CouponCourseScalarWhereInput[];
  };

  export type UserCouponUpdateManyWithoutCouponNestedInput = {
    create?:
      | XOR<
          UserCouponCreateWithoutCouponInput,
          UserCouponUncheckedCreateWithoutCouponInput
        >
      | UserCouponCreateWithoutCouponInput[]
      | UserCouponUncheckedCreateWithoutCouponInput[];
    connectOrCreate?:
      | UserCouponCreateOrConnectWithoutCouponInput
      | UserCouponCreateOrConnectWithoutCouponInput[];
    upsert?:
      | UserCouponUpsertWithWhereUniqueWithoutCouponInput
      | UserCouponUpsertWithWhereUniqueWithoutCouponInput[];
    createMany?: UserCouponCreateManyCouponInputEnvelope;
    set?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
    disconnect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
    delete?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
    update?:
      | UserCouponUpdateWithWhereUniqueWithoutCouponInput
      | UserCouponUpdateWithWhereUniqueWithoutCouponInput[];
    updateMany?:
      | UserCouponUpdateManyWithWhereWithoutCouponInput
      | UserCouponUpdateManyWithWhereWithoutCouponInput[];
    deleteMany?: UserCouponScalarWhereInput | UserCouponScalarWhereInput[];
  };

  export type CouponCourseUncheckedUpdateManyWithoutCouponNestedInput = {
    create?:
      | XOR<
          CouponCourseCreateWithoutCouponInput,
          CouponCourseUncheckedCreateWithoutCouponInput
        >
      | CouponCourseCreateWithoutCouponInput[]
      | CouponCourseUncheckedCreateWithoutCouponInput[];
    connectOrCreate?:
      | CouponCourseCreateOrConnectWithoutCouponInput
      | CouponCourseCreateOrConnectWithoutCouponInput[];
    upsert?:
      | CouponCourseUpsertWithWhereUniqueWithoutCouponInput
      | CouponCourseUpsertWithWhereUniqueWithoutCouponInput[];
    createMany?: CouponCourseCreateManyCouponInputEnvelope;
    set?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
    disconnect?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
    delete?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
    connect?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
    update?:
      | CouponCourseUpdateWithWhereUniqueWithoutCouponInput
      | CouponCourseUpdateWithWhereUniqueWithoutCouponInput[];
    updateMany?:
      | CouponCourseUpdateManyWithWhereWithoutCouponInput
      | CouponCourseUpdateManyWithWhereWithoutCouponInput[];
    deleteMany?: CouponCourseScalarWhereInput | CouponCourseScalarWhereInput[];
  };

  export type UserCouponUncheckedUpdateManyWithoutCouponNestedInput = {
    create?:
      | XOR<
          UserCouponCreateWithoutCouponInput,
          UserCouponUncheckedCreateWithoutCouponInput
        >
      | UserCouponCreateWithoutCouponInput[]
      | UserCouponUncheckedCreateWithoutCouponInput[];
    connectOrCreate?:
      | UserCouponCreateOrConnectWithoutCouponInput
      | UserCouponCreateOrConnectWithoutCouponInput[];
    upsert?:
      | UserCouponUpsertWithWhereUniqueWithoutCouponInput
      | UserCouponUpsertWithWhereUniqueWithoutCouponInput[];
    createMany?: UserCouponCreateManyCouponInputEnvelope;
    set?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
    disconnect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
    delete?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
    update?:
      | UserCouponUpdateWithWhereUniqueWithoutCouponInput
      | UserCouponUpdateWithWhereUniqueWithoutCouponInput[];
    updateMany?:
      | UserCouponUpdateManyWithWhereWithoutCouponInput
      | UserCouponUpdateManyWithWhereWithoutCouponInput[];
    deleteMany?: UserCouponScalarWhereInput | UserCouponScalarWhereInput[];
  };

  export type CouponCreateNestedOneWithoutCouponCourseInput = {
    create?: XOR<
      CouponCreateWithoutCouponCourseInput,
      CouponUncheckedCreateWithoutCouponCourseInput
    >;
    connectOrCreate?: CouponCreateOrConnectWithoutCouponCourseInput;
    connect?: CouponWhereUniqueInput;
  };

  export type CourseCreateNestedOneWithoutCouponCourseInput = {
    create?: XOR<
      CourseCreateWithoutCouponCourseInput,
      CourseUncheckedCreateWithoutCouponCourseInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutCouponCourseInput;
    connect?: CourseWhereUniqueInput;
  };

  export type CouponUpdateOneRequiredWithoutCouponCourseNestedInput = {
    create?: XOR<
      CouponCreateWithoutCouponCourseInput,
      CouponUncheckedCreateWithoutCouponCourseInput
    >;
    connectOrCreate?: CouponCreateOrConnectWithoutCouponCourseInput;
    upsert?: CouponUpsertWithoutCouponCourseInput;
    connect?: CouponWhereUniqueInput;
    update?: XOR<
      XOR<
        CouponUpdateToOneWithWhereWithoutCouponCourseInput,
        CouponUpdateWithoutCouponCourseInput
      >,
      CouponUncheckedUpdateWithoutCouponCourseInput
    >;
  };

  export type CourseUpdateOneRequiredWithoutCouponCourseNestedInput = {
    create?: XOR<
      CourseCreateWithoutCouponCourseInput,
      CourseUncheckedCreateWithoutCouponCourseInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutCouponCourseInput;
    upsert?: CourseUpsertWithoutCouponCourseInput;
    connect?: CourseWhereUniqueInput;
    update?: XOR<
      XOR<
        CourseUpdateToOneWithWhereWithoutCouponCourseInput,
        CourseUpdateWithoutCouponCourseInput
      >,
      CourseUncheckedUpdateWithoutCouponCourseInput
    >;
  };

  export type CartCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<CartCreateWithoutCourseInput, CartUncheckedCreateWithoutCourseInput>
      | CartCreateWithoutCourseInput[]
      | CartUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | CartCreateOrConnectWithoutCourseInput
      | CartCreateOrConnectWithoutCourseInput[];
    createMany?: CartCreateManyCourseInputEnvelope;
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[];
  };

  export type CertificateCreateNestedOneWithoutCourseInput = {
    create?: XOR<
      CertificateCreateWithoutCourseInput,
      CertificateUncheckedCreateWithoutCourseInput
    >;
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput;
    connect?: CertificateWhereUniqueInput;
  };

  export type CouponCourseCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<
          CouponCourseCreateWithoutCourseInput,
          CouponCourseUncheckedCreateWithoutCourseInput
        >
      | CouponCourseCreateWithoutCourseInput[]
      | CouponCourseUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | CouponCourseCreateOrConnectWithoutCourseInput
      | CouponCourseCreateOrConnectWithoutCourseInput[];
    createMany?: CouponCourseCreateManyCourseInputEnvelope;
    connect?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
  };

  export type UserCreateNestedOneWithoutCourseInput = {
    create?: XOR<
      UserCreateWithoutCourseInput,
      UserUncheckedCreateWithoutCourseInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCourseInput;
    connect?: UserWhereUniqueInput;
  };

  export type CourseCategoryCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<
          CourseCategoryCreateWithoutCourseInput,
          CourseCategoryUncheckedCreateWithoutCourseInput
        >
      | CourseCategoryCreateWithoutCourseInput[]
      | CourseCategoryUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | CourseCategoryCreateOrConnectWithoutCourseInput
      | CourseCategoryCreateOrConnectWithoutCourseInput[];
    createMany?: CourseCategoryCreateManyCourseInputEnvelope;
    connect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[];
  };

  export type CourseObjectiveCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<
          CourseObjectiveCreateWithoutCourseInput,
          CourseObjectiveUncheckedCreateWithoutCourseInput
        >
      | CourseObjectiveCreateWithoutCourseInput[]
      | CourseObjectiveUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | CourseObjectiveCreateOrConnectWithoutCourseInput
      | CourseObjectiveCreateOrConnectWithoutCourseInput[];
    createMany?: CourseObjectiveCreateManyCourseInputEnvelope;
    connect?:
      | CourseObjectiveWhereUniqueInput
      | CourseObjectiveWhereUniqueInput[];
  };

  export type EnrollmentCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<
          EnrollmentCreateWithoutCourseInput,
          EnrollmentUncheckedCreateWithoutCourseInput
        >
      | EnrollmentCreateWithoutCourseInput[]
      | EnrollmentUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | EnrollmentCreateOrConnectWithoutCourseInput
      | EnrollmentCreateOrConnectWithoutCourseInput[];
    createMany?: EnrollmentCreateManyCourseInputEnvelope;
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
  };

  export type PaymentDetailCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<
          PaymentDetailCreateWithoutCourseInput,
          PaymentDetailUncheckedCreateWithoutCourseInput
        >
      | PaymentDetailCreateWithoutCourseInput[]
      | PaymentDetailUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | PaymentDetailCreateOrConnectWithoutCourseInput
      | PaymentDetailCreateOrConnectWithoutCourseInput[];
    createMany?: PaymentDetailCreateManyCourseInputEnvelope;
    connect?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[];
  };

  export type ReviewCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<
          ReviewCreateWithoutCourseInput,
          ReviewUncheckedCreateWithoutCourseInput
        >
      | ReviewCreateWithoutCourseInput[]
      | ReviewUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutCourseInput
      | ReviewCreateOrConnectWithoutCourseInput[];
    createMany?: ReviewCreateManyCourseInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type SectionCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<
          SectionCreateWithoutCourseInput,
          SectionUncheckedCreateWithoutCourseInput
        >
      | SectionCreateWithoutCourseInput[]
      | SectionUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | SectionCreateOrConnectWithoutCourseInput
      | SectionCreateOrConnectWithoutCourseInput[];
    createMany?: SectionCreateManyCourseInputEnvelope;
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[];
  };

  export type StudyRemindCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<
          StudyRemindCreateWithoutCourseInput,
          StudyRemindUncheckedCreateWithoutCourseInput
        >
      | StudyRemindCreateWithoutCourseInput[]
      | StudyRemindUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | StudyRemindCreateOrConnectWithoutCourseInput
      | StudyRemindCreateOrConnectWithoutCourseInput[];
    createMany?: StudyRemindCreateManyCourseInputEnvelope;
    connect?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
  };

  export type WishlistCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<
          WishlistCreateWithoutCourseInput,
          WishlistUncheckedCreateWithoutCourseInput
        >
      | WishlistCreateWithoutCourseInput[]
      | WishlistUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | WishlistCreateOrConnectWithoutCourseInput
      | WishlistCreateOrConnectWithoutCourseInput[];
    createMany?: WishlistCreateManyCourseInputEnvelope;
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
  };

  export type CartUncheckedCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<CartCreateWithoutCourseInput, CartUncheckedCreateWithoutCourseInput>
      | CartCreateWithoutCourseInput[]
      | CartUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | CartCreateOrConnectWithoutCourseInput
      | CartCreateOrConnectWithoutCourseInput[];
    createMany?: CartCreateManyCourseInputEnvelope;
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[];
  };

  export type CertificateUncheckedCreateNestedOneWithoutCourseInput = {
    create?: XOR<
      CertificateCreateWithoutCourseInput,
      CertificateUncheckedCreateWithoutCourseInput
    >;
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput;
    connect?: CertificateWhereUniqueInput;
  };

  export type CouponCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<
          CouponCourseCreateWithoutCourseInput,
          CouponCourseUncheckedCreateWithoutCourseInput
        >
      | CouponCourseCreateWithoutCourseInput[]
      | CouponCourseUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | CouponCourseCreateOrConnectWithoutCourseInput
      | CouponCourseCreateOrConnectWithoutCourseInput[];
    createMany?: CouponCourseCreateManyCourseInputEnvelope;
    connect?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
  };

  export type CourseCategoryUncheckedCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<
          CourseCategoryCreateWithoutCourseInput,
          CourseCategoryUncheckedCreateWithoutCourseInput
        >
      | CourseCategoryCreateWithoutCourseInput[]
      | CourseCategoryUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | CourseCategoryCreateOrConnectWithoutCourseInput
      | CourseCategoryCreateOrConnectWithoutCourseInput[];
    createMany?: CourseCategoryCreateManyCourseInputEnvelope;
    connect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[];
  };

  export type CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<
          CourseObjectiveCreateWithoutCourseInput,
          CourseObjectiveUncheckedCreateWithoutCourseInput
        >
      | CourseObjectiveCreateWithoutCourseInput[]
      | CourseObjectiveUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | CourseObjectiveCreateOrConnectWithoutCourseInput
      | CourseObjectiveCreateOrConnectWithoutCourseInput[];
    createMany?: CourseObjectiveCreateManyCourseInputEnvelope;
    connect?:
      | CourseObjectiveWhereUniqueInput
      | CourseObjectiveWhereUniqueInput[];
  };

  export type EnrollmentUncheckedCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<
          EnrollmentCreateWithoutCourseInput,
          EnrollmentUncheckedCreateWithoutCourseInput
        >
      | EnrollmentCreateWithoutCourseInput[]
      | EnrollmentUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | EnrollmentCreateOrConnectWithoutCourseInput
      | EnrollmentCreateOrConnectWithoutCourseInput[];
    createMany?: EnrollmentCreateManyCourseInputEnvelope;
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
  };

  export type PaymentDetailUncheckedCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<
          PaymentDetailCreateWithoutCourseInput,
          PaymentDetailUncheckedCreateWithoutCourseInput
        >
      | PaymentDetailCreateWithoutCourseInput[]
      | PaymentDetailUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | PaymentDetailCreateOrConnectWithoutCourseInput
      | PaymentDetailCreateOrConnectWithoutCourseInput[];
    createMany?: PaymentDetailCreateManyCourseInputEnvelope;
    connect?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[];
  };

  export type ReviewUncheckedCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<
          ReviewCreateWithoutCourseInput,
          ReviewUncheckedCreateWithoutCourseInput
        >
      | ReviewCreateWithoutCourseInput[]
      | ReviewUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutCourseInput
      | ReviewCreateOrConnectWithoutCourseInput[];
    createMany?: ReviewCreateManyCourseInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type SectionUncheckedCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<
          SectionCreateWithoutCourseInput,
          SectionUncheckedCreateWithoutCourseInput
        >
      | SectionCreateWithoutCourseInput[]
      | SectionUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | SectionCreateOrConnectWithoutCourseInput
      | SectionCreateOrConnectWithoutCourseInput[];
    createMany?: SectionCreateManyCourseInputEnvelope;
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[];
  };

  export type StudyRemindUncheckedCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<
          StudyRemindCreateWithoutCourseInput,
          StudyRemindUncheckedCreateWithoutCourseInput
        >
      | StudyRemindCreateWithoutCourseInput[]
      | StudyRemindUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | StudyRemindCreateOrConnectWithoutCourseInput
      | StudyRemindCreateOrConnectWithoutCourseInput[];
    createMany?: StudyRemindCreateManyCourseInputEnvelope;
    connect?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
  };

  export type WishlistUncheckedCreateNestedManyWithoutCourseInput = {
    create?:
      | XOR<
          WishlistCreateWithoutCourseInput,
          WishlistUncheckedCreateWithoutCourseInput
        >
      | WishlistCreateWithoutCourseInput[]
      | WishlistUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | WishlistCreateOrConnectWithoutCourseInput
      | WishlistCreateOrConnectWithoutCourseInput[];
    createMany?: WishlistCreateManyCourseInputEnvelope;
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
  };

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null;
  };

  export type CartUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<CartCreateWithoutCourseInput, CartUncheckedCreateWithoutCourseInput>
      | CartCreateWithoutCourseInput[]
      | CartUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | CartCreateOrConnectWithoutCourseInput
      | CartCreateOrConnectWithoutCourseInput[];
    upsert?:
      | CartUpsertWithWhereUniqueWithoutCourseInput
      | CartUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: CartCreateManyCourseInputEnvelope;
    set?: CartWhereUniqueInput | CartWhereUniqueInput[];
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[];
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[];
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[];
    update?:
      | CartUpdateWithWhereUniqueWithoutCourseInput
      | CartUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | CartUpdateManyWithWhereWithoutCourseInput
      | CartUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[];
  };

  export type CertificateUpdateOneWithoutCourseNestedInput = {
    create?: XOR<
      CertificateCreateWithoutCourseInput,
      CertificateUncheckedCreateWithoutCourseInput
    >;
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput;
    upsert?: CertificateUpsertWithoutCourseInput;
    disconnect?: CertificateWhereInput | boolean;
    delete?: CertificateWhereInput | boolean;
    connect?: CertificateWhereUniqueInput;
    update?: XOR<
      XOR<
        CertificateUpdateToOneWithWhereWithoutCourseInput,
        CertificateUpdateWithoutCourseInput
      >,
      CertificateUncheckedUpdateWithoutCourseInput
    >;
  };

  export type CouponCourseUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<
          CouponCourseCreateWithoutCourseInput,
          CouponCourseUncheckedCreateWithoutCourseInput
        >
      | CouponCourseCreateWithoutCourseInput[]
      | CouponCourseUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | CouponCourseCreateOrConnectWithoutCourseInput
      | CouponCourseCreateOrConnectWithoutCourseInput[];
    upsert?:
      | CouponCourseUpsertWithWhereUniqueWithoutCourseInput
      | CouponCourseUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: CouponCourseCreateManyCourseInputEnvelope;
    set?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
    disconnect?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
    delete?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
    connect?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
    update?:
      | CouponCourseUpdateWithWhereUniqueWithoutCourseInput
      | CouponCourseUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | CouponCourseUpdateManyWithWhereWithoutCourseInput
      | CouponCourseUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?: CouponCourseScalarWhereInput | CouponCourseScalarWhereInput[];
  };

  export type UserUpdateOneWithoutCourseNestedInput = {
    create?: XOR<
      UserCreateWithoutCourseInput,
      UserUncheckedCreateWithoutCourseInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCourseInput;
    upsert?: UserUpsertWithoutCourseInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutCourseInput,
        UserUpdateWithoutCourseInput
      >,
      UserUncheckedUpdateWithoutCourseInput
    >;
  };

  export type CourseCategoryUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<
          CourseCategoryCreateWithoutCourseInput,
          CourseCategoryUncheckedCreateWithoutCourseInput
        >
      | CourseCategoryCreateWithoutCourseInput[]
      | CourseCategoryUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | CourseCategoryCreateOrConnectWithoutCourseInput
      | CourseCategoryCreateOrConnectWithoutCourseInput[];
    upsert?:
      | CourseCategoryUpsertWithWhereUniqueWithoutCourseInput
      | CourseCategoryUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: CourseCategoryCreateManyCourseInputEnvelope;
    set?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[];
    disconnect?:
      | CourseCategoryWhereUniqueInput
      | CourseCategoryWhereUniqueInput[];
    delete?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[];
    connect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[];
    update?:
      | CourseCategoryUpdateWithWhereUniqueWithoutCourseInput
      | CourseCategoryUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | CourseCategoryUpdateManyWithWhereWithoutCourseInput
      | CourseCategoryUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?:
      | CourseCategoryScalarWhereInput
      | CourseCategoryScalarWhereInput[];
  };

  export type CourseObjectiveUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<
          CourseObjectiveCreateWithoutCourseInput,
          CourseObjectiveUncheckedCreateWithoutCourseInput
        >
      | CourseObjectiveCreateWithoutCourseInput[]
      | CourseObjectiveUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | CourseObjectiveCreateOrConnectWithoutCourseInput
      | CourseObjectiveCreateOrConnectWithoutCourseInput[];
    upsert?:
      | CourseObjectiveUpsertWithWhereUniqueWithoutCourseInput
      | CourseObjectiveUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: CourseObjectiveCreateManyCourseInputEnvelope;
    set?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[];
    disconnect?:
      | CourseObjectiveWhereUniqueInput
      | CourseObjectiveWhereUniqueInput[];
    delete?:
      | CourseObjectiveWhereUniqueInput
      | CourseObjectiveWhereUniqueInput[];
    connect?:
      | CourseObjectiveWhereUniqueInput
      | CourseObjectiveWhereUniqueInput[];
    update?:
      | CourseObjectiveUpdateWithWhereUniqueWithoutCourseInput
      | CourseObjectiveUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | CourseObjectiveUpdateManyWithWhereWithoutCourseInput
      | CourseObjectiveUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?:
      | CourseObjectiveScalarWhereInput
      | CourseObjectiveScalarWhereInput[];
  };

  export type EnrollmentUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<
          EnrollmentCreateWithoutCourseInput,
          EnrollmentUncheckedCreateWithoutCourseInput
        >
      | EnrollmentCreateWithoutCourseInput[]
      | EnrollmentUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | EnrollmentCreateOrConnectWithoutCourseInput
      | EnrollmentCreateOrConnectWithoutCourseInput[];
    upsert?:
      | EnrollmentUpsertWithWhereUniqueWithoutCourseInput
      | EnrollmentUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: EnrollmentCreateManyCourseInputEnvelope;
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
    update?:
      | EnrollmentUpdateWithWhereUniqueWithoutCourseInput
      | EnrollmentUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | EnrollmentUpdateManyWithWhereWithoutCourseInput
      | EnrollmentUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[];
  };

  export type PaymentDetailUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<
          PaymentDetailCreateWithoutCourseInput,
          PaymentDetailUncheckedCreateWithoutCourseInput
        >
      | PaymentDetailCreateWithoutCourseInput[]
      | PaymentDetailUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | PaymentDetailCreateOrConnectWithoutCourseInput
      | PaymentDetailCreateOrConnectWithoutCourseInput[];
    upsert?:
      | PaymentDetailUpsertWithWhereUniqueWithoutCourseInput
      | PaymentDetailUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: PaymentDetailCreateManyCourseInputEnvelope;
    set?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[];
    disconnect?:
      | PaymentDetailWhereUniqueInput
      | PaymentDetailWhereUniqueInput[];
    delete?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[];
    connect?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[];
    update?:
      | PaymentDetailUpdateWithWhereUniqueWithoutCourseInput
      | PaymentDetailUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | PaymentDetailUpdateManyWithWhereWithoutCourseInput
      | PaymentDetailUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?:
      | PaymentDetailScalarWhereInput
      | PaymentDetailScalarWhereInput[];
  };

  export type ReviewUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<
          ReviewCreateWithoutCourseInput,
          ReviewUncheckedCreateWithoutCourseInput
        >
      | ReviewCreateWithoutCourseInput[]
      | ReviewUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutCourseInput
      | ReviewCreateOrConnectWithoutCourseInput[];
    upsert?:
      | ReviewUpsertWithWhereUniqueWithoutCourseInput
      | ReviewUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: ReviewCreateManyCourseInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?:
      | ReviewUpdateWithWhereUniqueWithoutCourseInput
      | ReviewUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | ReviewUpdateManyWithWhereWithoutCourseInput
      | ReviewUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type SectionUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<
          SectionCreateWithoutCourseInput,
          SectionUncheckedCreateWithoutCourseInput
        >
      | SectionCreateWithoutCourseInput[]
      | SectionUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | SectionCreateOrConnectWithoutCourseInput
      | SectionCreateOrConnectWithoutCourseInput[];
    upsert?:
      | SectionUpsertWithWhereUniqueWithoutCourseInput
      | SectionUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: SectionCreateManyCourseInputEnvelope;
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[];
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[];
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[];
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[];
    update?:
      | SectionUpdateWithWhereUniqueWithoutCourseInput
      | SectionUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | SectionUpdateManyWithWhereWithoutCourseInput
      | SectionUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[];
  };

  export type StudyRemindUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<
          StudyRemindCreateWithoutCourseInput,
          StudyRemindUncheckedCreateWithoutCourseInput
        >
      | StudyRemindCreateWithoutCourseInput[]
      | StudyRemindUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | StudyRemindCreateOrConnectWithoutCourseInput
      | StudyRemindCreateOrConnectWithoutCourseInput[];
    upsert?:
      | StudyRemindUpsertWithWhereUniqueWithoutCourseInput
      | StudyRemindUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: StudyRemindCreateManyCourseInputEnvelope;
    set?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
    disconnect?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
    delete?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
    connect?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
    update?:
      | StudyRemindUpdateWithWhereUniqueWithoutCourseInput
      | StudyRemindUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | StudyRemindUpdateManyWithWhereWithoutCourseInput
      | StudyRemindUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?: StudyRemindScalarWhereInput | StudyRemindScalarWhereInput[];
  };

  export type WishlistUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<
          WishlistCreateWithoutCourseInput,
          WishlistUncheckedCreateWithoutCourseInput
        >
      | WishlistCreateWithoutCourseInput[]
      | WishlistUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | WishlistCreateOrConnectWithoutCourseInput
      | WishlistCreateOrConnectWithoutCourseInput[];
    upsert?:
      | WishlistUpsertWithWhereUniqueWithoutCourseInput
      | WishlistUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: WishlistCreateManyCourseInputEnvelope;
    set?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
    disconnect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
    delete?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
    update?:
      | WishlistUpdateWithWhereUniqueWithoutCourseInput
      | WishlistUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | WishlistUpdateManyWithWhereWithoutCourseInput
      | WishlistUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?: WishlistScalarWhereInput | WishlistScalarWhereInput[];
  };

  export type CartUncheckedUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<CartCreateWithoutCourseInput, CartUncheckedCreateWithoutCourseInput>
      | CartCreateWithoutCourseInput[]
      | CartUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | CartCreateOrConnectWithoutCourseInput
      | CartCreateOrConnectWithoutCourseInput[];
    upsert?:
      | CartUpsertWithWhereUniqueWithoutCourseInput
      | CartUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: CartCreateManyCourseInputEnvelope;
    set?: CartWhereUniqueInput | CartWhereUniqueInput[];
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[];
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[];
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[];
    update?:
      | CartUpdateWithWhereUniqueWithoutCourseInput
      | CartUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | CartUpdateManyWithWhereWithoutCourseInput
      | CartUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[];
  };

  export type CertificateUncheckedUpdateOneWithoutCourseNestedInput = {
    create?: XOR<
      CertificateCreateWithoutCourseInput,
      CertificateUncheckedCreateWithoutCourseInput
    >;
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput;
    upsert?: CertificateUpsertWithoutCourseInput;
    disconnect?: CertificateWhereInput | boolean;
    delete?: CertificateWhereInput | boolean;
    connect?: CertificateWhereUniqueInput;
    update?: XOR<
      XOR<
        CertificateUpdateToOneWithWhereWithoutCourseInput,
        CertificateUpdateWithoutCourseInput
      >,
      CertificateUncheckedUpdateWithoutCourseInput
    >;
  };

  export type CouponCourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<
          CouponCourseCreateWithoutCourseInput,
          CouponCourseUncheckedCreateWithoutCourseInput
        >
      | CouponCourseCreateWithoutCourseInput[]
      | CouponCourseUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | CouponCourseCreateOrConnectWithoutCourseInput
      | CouponCourseCreateOrConnectWithoutCourseInput[];
    upsert?:
      | CouponCourseUpsertWithWhereUniqueWithoutCourseInput
      | CouponCourseUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: CouponCourseCreateManyCourseInputEnvelope;
    set?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
    disconnect?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
    delete?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
    connect?: CouponCourseWhereUniqueInput | CouponCourseWhereUniqueInput[];
    update?:
      | CouponCourseUpdateWithWhereUniqueWithoutCourseInput
      | CouponCourseUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | CouponCourseUpdateManyWithWhereWithoutCourseInput
      | CouponCourseUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?: CouponCourseScalarWhereInput | CouponCourseScalarWhereInput[];
  };

  export type CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<
          CourseCategoryCreateWithoutCourseInput,
          CourseCategoryUncheckedCreateWithoutCourseInput
        >
      | CourseCategoryCreateWithoutCourseInput[]
      | CourseCategoryUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | CourseCategoryCreateOrConnectWithoutCourseInput
      | CourseCategoryCreateOrConnectWithoutCourseInput[];
    upsert?:
      | CourseCategoryUpsertWithWhereUniqueWithoutCourseInput
      | CourseCategoryUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: CourseCategoryCreateManyCourseInputEnvelope;
    set?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[];
    disconnect?:
      | CourseCategoryWhereUniqueInput
      | CourseCategoryWhereUniqueInput[];
    delete?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[];
    connect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[];
    update?:
      | CourseCategoryUpdateWithWhereUniqueWithoutCourseInput
      | CourseCategoryUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | CourseCategoryUpdateManyWithWhereWithoutCourseInput
      | CourseCategoryUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?:
      | CourseCategoryScalarWhereInput
      | CourseCategoryScalarWhereInput[];
  };

  export type CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<
          CourseObjectiveCreateWithoutCourseInput,
          CourseObjectiveUncheckedCreateWithoutCourseInput
        >
      | CourseObjectiveCreateWithoutCourseInput[]
      | CourseObjectiveUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | CourseObjectiveCreateOrConnectWithoutCourseInput
      | CourseObjectiveCreateOrConnectWithoutCourseInput[];
    upsert?:
      | CourseObjectiveUpsertWithWhereUniqueWithoutCourseInput
      | CourseObjectiveUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: CourseObjectiveCreateManyCourseInputEnvelope;
    set?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[];
    disconnect?:
      | CourseObjectiveWhereUniqueInput
      | CourseObjectiveWhereUniqueInput[];
    delete?:
      | CourseObjectiveWhereUniqueInput
      | CourseObjectiveWhereUniqueInput[];
    connect?:
      | CourseObjectiveWhereUniqueInput
      | CourseObjectiveWhereUniqueInput[];
    update?:
      | CourseObjectiveUpdateWithWhereUniqueWithoutCourseInput
      | CourseObjectiveUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | CourseObjectiveUpdateManyWithWhereWithoutCourseInput
      | CourseObjectiveUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?:
      | CourseObjectiveScalarWhereInput
      | CourseObjectiveScalarWhereInput[];
  };

  export type EnrollmentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<
          EnrollmentCreateWithoutCourseInput,
          EnrollmentUncheckedCreateWithoutCourseInput
        >
      | EnrollmentCreateWithoutCourseInput[]
      | EnrollmentUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | EnrollmentCreateOrConnectWithoutCourseInput
      | EnrollmentCreateOrConnectWithoutCourseInput[];
    upsert?:
      | EnrollmentUpsertWithWhereUniqueWithoutCourseInput
      | EnrollmentUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: EnrollmentCreateManyCourseInputEnvelope;
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
    update?:
      | EnrollmentUpdateWithWhereUniqueWithoutCourseInput
      | EnrollmentUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | EnrollmentUpdateManyWithWhereWithoutCourseInput
      | EnrollmentUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[];
  };

  export type PaymentDetailUncheckedUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<
          PaymentDetailCreateWithoutCourseInput,
          PaymentDetailUncheckedCreateWithoutCourseInput
        >
      | PaymentDetailCreateWithoutCourseInput[]
      | PaymentDetailUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | PaymentDetailCreateOrConnectWithoutCourseInput
      | PaymentDetailCreateOrConnectWithoutCourseInput[];
    upsert?:
      | PaymentDetailUpsertWithWhereUniqueWithoutCourseInput
      | PaymentDetailUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: PaymentDetailCreateManyCourseInputEnvelope;
    set?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[];
    disconnect?:
      | PaymentDetailWhereUniqueInput
      | PaymentDetailWhereUniqueInput[];
    delete?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[];
    connect?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[];
    update?:
      | PaymentDetailUpdateWithWhereUniqueWithoutCourseInput
      | PaymentDetailUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | PaymentDetailUpdateManyWithWhereWithoutCourseInput
      | PaymentDetailUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?:
      | PaymentDetailScalarWhereInput
      | PaymentDetailScalarWhereInput[];
  };

  export type ReviewUncheckedUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<
          ReviewCreateWithoutCourseInput,
          ReviewUncheckedCreateWithoutCourseInput
        >
      | ReviewCreateWithoutCourseInput[]
      | ReviewUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutCourseInput
      | ReviewCreateOrConnectWithoutCourseInput[];
    upsert?:
      | ReviewUpsertWithWhereUniqueWithoutCourseInput
      | ReviewUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: ReviewCreateManyCourseInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?:
      | ReviewUpdateWithWhereUniqueWithoutCourseInput
      | ReviewUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | ReviewUpdateManyWithWhereWithoutCourseInput
      | ReviewUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type SectionUncheckedUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<
          SectionCreateWithoutCourseInput,
          SectionUncheckedCreateWithoutCourseInput
        >
      | SectionCreateWithoutCourseInput[]
      | SectionUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | SectionCreateOrConnectWithoutCourseInput
      | SectionCreateOrConnectWithoutCourseInput[];
    upsert?:
      | SectionUpsertWithWhereUniqueWithoutCourseInput
      | SectionUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: SectionCreateManyCourseInputEnvelope;
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[];
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[];
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[];
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[];
    update?:
      | SectionUpdateWithWhereUniqueWithoutCourseInput
      | SectionUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | SectionUpdateManyWithWhereWithoutCourseInput
      | SectionUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[];
  };

  export type StudyRemindUncheckedUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<
          StudyRemindCreateWithoutCourseInput,
          StudyRemindUncheckedCreateWithoutCourseInput
        >
      | StudyRemindCreateWithoutCourseInput[]
      | StudyRemindUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | StudyRemindCreateOrConnectWithoutCourseInput
      | StudyRemindCreateOrConnectWithoutCourseInput[];
    upsert?:
      | StudyRemindUpsertWithWhereUniqueWithoutCourseInput
      | StudyRemindUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: StudyRemindCreateManyCourseInputEnvelope;
    set?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
    disconnect?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
    delete?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
    connect?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
    update?:
      | StudyRemindUpdateWithWhereUniqueWithoutCourseInput
      | StudyRemindUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | StudyRemindUpdateManyWithWhereWithoutCourseInput
      | StudyRemindUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?: StudyRemindScalarWhereInput | StudyRemindScalarWhereInput[];
  };

  export type WishlistUncheckedUpdateManyWithoutCourseNestedInput = {
    create?:
      | XOR<
          WishlistCreateWithoutCourseInput,
          WishlistUncheckedCreateWithoutCourseInput
        >
      | WishlistCreateWithoutCourseInput[]
      | WishlistUncheckedCreateWithoutCourseInput[];
    connectOrCreate?:
      | WishlistCreateOrConnectWithoutCourseInput
      | WishlistCreateOrConnectWithoutCourseInput[];
    upsert?:
      | WishlistUpsertWithWhereUniqueWithoutCourseInput
      | WishlistUpsertWithWhereUniqueWithoutCourseInput[];
    createMany?: WishlistCreateManyCourseInputEnvelope;
    set?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
    disconnect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
    delete?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
    update?:
      | WishlistUpdateWithWhereUniqueWithoutCourseInput
      | WishlistUpdateWithWhereUniqueWithoutCourseInput[];
    updateMany?:
      | WishlistUpdateManyWithWhereWithoutCourseInput
      | WishlistUpdateManyWithWhereWithoutCourseInput[];
    deleteMany?: WishlistScalarWhereInput | WishlistScalarWhereInput[];
  };

  export type CategoryCreateNestedOneWithoutCourseCategoryInput = {
    create?: XOR<
      CategoryCreateWithoutCourseCategoryInput,
      CategoryUncheckedCreateWithoutCourseCategoryInput
    >;
    connectOrCreate?: CategoryCreateOrConnectWithoutCourseCategoryInput;
    connect?: CategoryWhereUniqueInput;
  };

  export type CourseCreateNestedOneWithoutCourseCategoryInput = {
    create?: XOR<
      CourseCreateWithoutCourseCategoryInput,
      CourseUncheckedCreateWithoutCourseCategoryInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutCourseCategoryInput;
    connect?: CourseWhereUniqueInput;
  };

  export type CategoryUpdateOneRequiredWithoutCourseCategoryNestedInput = {
    create?: XOR<
      CategoryCreateWithoutCourseCategoryInput,
      CategoryUncheckedCreateWithoutCourseCategoryInput
    >;
    connectOrCreate?: CategoryCreateOrConnectWithoutCourseCategoryInput;
    upsert?: CategoryUpsertWithoutCourseCategoryInput;
    connect?: CategoryWhereUniqueInput;
    update?: XOR<
      XOR<
        CategoryUpdateToOneWithWhereWithoutCourseCategoryInput,
        CategoryUpdateWithoutCourseCategoryInput
      >,
      CategoryUncheckedUpdateWithoutCourseCategoryInput
    >;
  };

  export type CourseUpdateOneRequiredWithoutCourseCategoryNestedInput = {
    create?: XOR<
      CourseCreateWithoutCourseCategoryInput,
      CourseUncheckedCreateWithoutCourseCategoryInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutCourseCategoryInput;
    upsert?: CourseUpsertWithoutCourseCategoryInput;
    connect?: CourseWhereUniqueInput;
    update?: XOR<
      XOR<
        CourseUpdateToOneWithWhereWithoutCourseCategoryInput,
        CourseUpdateWithoutCourseCategoryInput
      >,
      CourseUncheckedUpdateWithoutCourseCategoryInput
    >;
  };

  export type CourseCreateNestedOneWithoutCourseObjectiveInput = {
    create?: XOR<
      CourseCreateWithoutCourseObjectiveInput,
      CourseUncheckedCreateWithoutCourseObjectiveInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutCourseObjectiveInput;
    connect?: CourseWhereUniqueInput;
  };

  export type CourseUpdateOneRequiredWithoutCourseObjectiveNestedInput = {
    create?: XOR<
      CourseCreateWithoutCourseObjectiveInput,
      CourseUncheckedCreateWithoutCourseObjectiveInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutCourseObjectiveInput;
    upsert?: CourseUpsertWithoutCourseObjectiveInput;
    connect?: CourseWhereUniqueInput;
    update?: XOR<
      XOR<
        CourseUpdateToOneWithWhereWithoutCourseObjectiveInput,
        CourseUpdateWithoutCourseObjectiveInput
      >,
      CourseUncheckedUpdateWithoutCourseObjectiveInput
    >;
  };

  export type CourseCreateNestedOneWithoutEnrollmentInput = {
    create?: XOR<
      CourseCreateWithoutEnrollmentInput,
      CourseUncheckedCreateWithoutEnrollmentInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentInput;
    connect?: CourseWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutEnrollmentInput = {
    create?: XOR<
      UserCreateWithoutEnrollmentInput,
      UserUncheckedCreateWithoutEnrollmentInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentInput;
    connect?: UserWhereUniqueInput;
  };

  export type CourseUpdateOneRequiredWithoutEnrollmentNestedInput = {
    create?: XOR<
      CourseCreateWithoutEnrollmentInput,
      CourseUncheckedCreateWithoutEnrollmentInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentInput;
    upsert?: CourseUpsertWithoutEnrollmentInput;
    connect?: CourseWhereUniqueInput;
    update?: XOR<
      XOR<
        CourseUpdateToOneWithWhereWithoutEnrollmentInput,
        CourseUpdateWithoutEnrollmentInput
      >,
      CourseUncheckedUpdateWithoutEnrollmentInput
    >;
  };

  export type UserUpdateOneRequiredWithoutEnrollmentNestedInput = {
    create?: XOR<
      UserCreateWithoutEnrollmentInput,
      UserUncheckedCreateWithoutEnrollmentInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentInput;
    upsert?: UserUpsertWithoutEnrollmentInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutEnrollmentInput,
        UserUpdateWithoutEnrollmentInput
      >,
      UserUncheckedUpdateWithoutEnrollmentInput
    >;
  };

  export type UserCreateNestedOneWithoutFollow_Follow_idFollowerToUserInput = {
    create?: XOR<
      UserCreateWithoutFollow_Follow_idFollowerToUserInput,
      UserUncheckedCreateWithoutFollow_Follow_idFollowerToUserInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutFollow_Follow_idFollowerToUserInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutFollow_Follow_idFollowingToUserInput = {
    create?: XOR<
      UserCreateWithoutFollow_Follow_idFollowingToUserInput,
      UserUncheckedCreateWithoutFollow_Follow_idFollowingToUserInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutFollow_Follow_idFollowingToUserInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutFollow_Follow_idFollowerToUserNestedInput =
    {
      create?: XOR<
        UserCreateWithoutFollow_Follow_idFollowerToUserInput,
        UserUncheckedCreateWithoutFollow_Follow_idFollowerToUserInput
      >;
      connectOrCreate?: UserCreateOrConnectWithoutFollow_Follow_idFollowerToUserInput;
      upsert?: UserUpsertWithoutFollow_Follow_idFollowerToUserInput;
      connect?: UserWhereUniqueInput;
      update?: XOR<
        XOR<
          UserUpdateToOneWithWhereWithoutFollow_Follow_idFollowerToUserInput,
          UserUpdateWithoutFollow_Follow_idFollowerToUserInput
        >,
        UserUncheckedUpdateWithoutFollow_Follow_idFollowerToUserInput
      >;
    };

  export type UserUpdateOneRequiredWithoutFollow_Follow_idFollowingToUserNestedInput =
    {
      create?: XOR<
        UserCreateWithoutFollow_Follow_idFollowingToUserInput,
        UserUncheckedCreateWithoutFollow_Follow_idFollowingToUserInput
      >;
      connectOrCreate?: UserCreateOrConnectWithoutFollow_Follow_idFollowingToUserInput;
      upsert?: UserUpsertWithoutFollow_Follow_idFollowingToUserInput;
      connect?: UserWhereUniqueInput;
      update?: XOR<
        XOR<
          UserUpdateToOneWithWhereWithoutFollow_Follow_idFollowingToUserInput,
          UserUpdateWithoutFollow_Follow_idFollowingToUserInput
        >,
        UserUncheckedUpdateWithoutFollow_Follow_idFollowingToUserInput
      >;
    };

  export type SectionCreateNestedOneWithoutLectureInput = {
    create?: XOR<
      SectionCreateWithoutLectureInput,
      SectionUncheckedCreateWithoutLectureInput
    >;
    connectOrCreate?: SectionCreateOrConnectWithoutLectureInput;
    connect?: SectionWhereUniqueInput;
  };

  export type NoteCreateNestedManyWithoutLectureInput = {
    create?:
      | XOR<
          NoteCreateWithoutLectureInput,
          NoteUncheckedCreateWithoutLectureInput
        >
      | NoteCreateWithoutLectureInput[]
      | NoteUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | NoteCreateOrConnectWithoutLectureInput
      | NoteCreateOrConnectWithoutLectureInput[];
    createMany?: NoteCreateManyLectureInputEnvelope;
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
  };

  export type QuestionCreateNestedManyWithoutLectureInput = {
    create?:
      | XOR<
          QuestionCreateWithoutLectureInput,
          QuestionUncheckedCreateWithoutLectureInput
        >
      | QuestionCreateWithoutLectureInput[]
      | QuestionUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | QuestionCreateOrConnectWithoutLectureInput
      | QuestionCreateOrConnectWithoutLectureInput[];
    createMany?: QuestionCreateManyLectureInputEnvelope;
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
  };

  export type NoteUncheckedCreateNestedManyWithoutLectureInput = {
    create?:
      | XOR<
          NoteCreateWithoutLectureInput,
          NoteUncheckedCreateWithoutLectureInput
        >
      | NoteCreateWithoutLectureInput[]
      | NoteUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | NoteCreateOrConnectWithoutLectureInput
      | NoteCreateOrConnectWithoutLectureInput[];
    createMany?: NoteCreateManyLectureInputEnvelope;
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
  };

  export type QuestionUncheckedCreateNestedManyWithoutLectureInput = {
    create?:
      | XOR<
          QuestionCreateWithoutLectureInput,
          QuestionUncheckedCreateWithoutLectureInput
        >
      | QuestionCreateWithoutLectureInput[]
      | QuestionUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | QuestionCreateOrConnectWithoutLectureInput
      | QuestionCreateOrConnectWithoutLectureInput[];
    createMany?: QuestionCreateManyLectureInputEnvelope;
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
  };

  export type SectionUpdateOneRequiredWithoutLectureNestedInput = {
    create?: XOR<
      SectionCreateWithoutLectureInput,
      SectionUncheckedCreateWithoutLectureInput
    >;
    connectOrCreate?: SectionCreateOrConnectWithoutLectureInput;
    upsert?: SectionUpsertWithoutLectureInput;
    connect?: SectionWhereUniqueInput;
    update?: XOR<
      XOR<
        SectionUpdateToOneWithWhereWithoutLectureInput,
        SectionUpdateWithoutLectureInput
      >,
      SectionUncheckedUpdateWithoutLectureInput
    >;
  };

  export type NoteUpdateManyWithoutLectureNestedInput = {
    create?:
      | XOR<
          NoteCreateWithoutLectureInput,
          NoteUncheckedCreateWithoutLectureInput
        >
      | NoteCreateWithoutLectureInput[]
      | NoteUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | NoteCreateOrConnectWithoutLectureInput
      | NoteCreateOrConnectWithoutLectureInput[];
    upsert?:
      | NoteUpsertWithWhereUniqueWithoutLectureInput
      | NoteUpsertWithWhereUniqueWithoutLectureInput[];
    createMany?: NoteCreateManyLectureInputEnvelope;
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
    update?:
      | NoteUpdateWithWhereUniqueWithoutLectureInput
      | NoteUpdateWithWhereUniqueWithoutLectureInput[];
    updateMany?:
      | NoteUpdateManyWithWhereWithoutLectureInput
      | NoteUpdateManyWithWhereWithoutLectureInput[];
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[];
  };

  export type QuestionUpdateManyWithoutLectureNestedInput = {
    create?:
      | XOR<
          QuestionCreateWithoutLectureInput,
          QuestionUncheckedCreateWithoutLectureInput
        >
      | QuestionCreateWithoutLectureInput[]
      | QuestionUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | QuestionCreateOrConnectWithoutLectureInput
      | QuestionCreateOrConnectWithoutLectureInput[];
    upsert?:
      | QuestionUpsertWithWhereUniqueWithoutLectureInput
      | QuestionUpsertWithWhereUniqueWithoutLectureInput[];
    createMany?: QuestionCreateManyLectureInputEnvelope;
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
    update?:
      | QuestionUpdateWithWhereUniqueWithoutLectureInput
      | QuestionUpdateWithWhereUniqueWithoutLectureInput[];
    updateMany?:
      | QuestionUpdateManyWithWhereWithoutLectureInput
      | QuestionUpdateManyWithWhereWithoutLectureInput[];
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[];
  };

  export type NoteUncheckedUpdateManyWithoutLectureNestedInput = {
    create?:
      | XOR<
          NoteCreateWithoutLectureInput,
          NoteUncheckedCreateWithoutLectureInput
        >
      | NoteCreateWithoutLectureInput[]
      | NoteUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | NoteCreateOrConnectWithoutLectureInput
      | NoteCreateOrConnectWithoutLectureInput[];
    upsert?:
      | NoteUpsertWithWhereUniqueWithoutLectureInput
      | NoteUpsertWithWhereUniqueWithoutLectureInput[];
    createMany?: NoteCreateManyLectureInputEnvelope;
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
    update?:
      | NoteUpdateWithWhereUniqueWithoutLectureInput
      | NoteUpdateWithWhereUniqueWithoutLectureInput[];
    updateMany?:
      | NoteUpdateManyWithWhereWithoutLectureInput
      | NoteUpdateManyWithWhereWithoutLectureInput[];
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[];
  };

  export type QuestionUncheckedUpdateManyWithoutLectureNestedInput = {
    create?:
      | XOR<
          QuestionCreateWithoutLectureInput,
          QuestionUncheckedCreateWithoutLectureInput
        >
      | QuestionCreateWithoutLectureInput[]
      | QuestionUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | QuestionCreateOrConnectWithoutLectureInput
      | QuestionCreateOrConnectWithoutLectureInput[];
    upsert?:
      | QuestionUpsertWithWhereUniqueWithoutLectureInput
      | QuestionUpsertWithWhereUniqueWithoutLectureInput[];
    createMany?: QuestionCreateManyLectureInputEnvelope;
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
    update?:
      | QuestionUpdateWithWhereUniqueWithoutLectureInput
      | QuestionUpdateWithWhereUniqueWithoutLectureInput[];
    updateMany?:
      | QuestionUpdateManyWithWhereWithoutLectureInput
      | QuestionUpdateManyWithWhereWithoutLectureInput[];
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutMessage_Message_idUserReceiverToUserInput =
    {
      create?: XOR<
        UserCreateWithoutMessage_Message_idUserReceiverToUserInput,
        UserUncheckedCreateWithoutMessage_Message_idUserReceiverToUserInput
      >;
      connectOrCreate?: UserCreateOrConnectWithoutMessage_Message_idUserReceiverToUserInput;
      connect?: UserWhereUniqueInput;
    };

  export type UserCreateNestedOneWithoutMessage_Message_idUserSenderToUserInput =
    {
      create?: XOR<
        UserCreateWithoutMessage_Message_idUserSenderToUserInput,
        UserUncheckedCreateWithoutMessage_Message_idUserSenderToUserInput
      >;
      connectOrCreate?: UserCreateOrConnectWithoutMessage_Message_idUserSenderToUserInput;
      connect?: UserWhereUniqueInput;
    };

  export type UserUpdateOneWithoutMessage_Message_idUserReceiverToUserNestedInput =
    {
      create?: XOR<
        UserCreateWithoutMessage_Message_idUserReceiverToUserInput,
        UserUncheckedCreateWithoutMessage_Message_idUserReceiverToUserInput
      >;
      connectOrCreate?: UserCreateOrConnectWithoutMessage_Message_idUserReceiverToUserInput;
      upsert?: UserUpsertWithoutMessage_Message_idUserReceiverToUserInput;
      disconnect?: UserWhereInput | boolean;
      delete?: UserWhereInput | boolean;
      connect?: UserWhereUniqueInput;
      update?: XOR<
        XOR<
          UserUpdateToOneWithWhereWithoutMessage_Message_idUserReceiverToUserInput,
          UserUpdateWithoutMessage_Message_idUserReceiverToUserInput
        >,
        UserUncheckedUpdateWithoutMessage_Message_idUserReceiverToUserInput
      >;
    };

  export type UserUpdateOneWithoutMessage_Message_idUserSenderToUserNestedInput =
    {
      create?: XOR<
        UserCreateWithoutMessage_Message_idUserSenderToUserInput,
        UserUncheckedCreateWithoutMessage_Message_idUserSenderToUserInput
      >;
      connectOrCreate?: UserCreateOrConnectWithoutMessage_Message_idUserSenderToUserInput;
      upsert?: UserUpsertWithoutMessage_Message_idUserSenderToUserInput;
      disconnect?: UserWhereInput | boolean;
      delete?: UserWhereInput | boolean;
      connect?: UserWhereUniqueInput;
      update?: XOR<
        XOR<
          UserUpdateToOneWithWhereWithoutMessage_Message_idUserSenderToUserInput,
          UserUpdateWithoutMessage_Message_idUserSenderToUserInput
        >,
        UserUncheckedUpdateWithoutMessage_Message_idUserSenderToUserInput
      >;
    };

  export type LectureCreateNestedOneWithoutNoteInput = {
    create?: XOR<
      LectureCreateWithoutNoteInput,
      LectureUncheckedCreateWithoutNoteInput
    >;
    connectOrCreate?: LectureCreateOrConnectWithoutNoteInput;
    connect?: LectureWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutNoteInput = {
    create?: XOR<
      UserCreateWithoutNoteInput,
      UserUncheckedCreateWithoutNoteInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutNoteInput;
    connect?: UserWhereUniqueInput;
  };

  export type LectureUpdateOneWithoutNoteNestedInput = {
    create?: XOR<
      LectureCreateWithoutNoteInput,
      LectureUncheckedCreateWithoutNoteInput
    >;
    connectOrCreate?: LectureCreateOrConnectWithoutNoteInput;
    upsert?: LectureUpsertWithoutNoteInput;
    disconnect?: LectureWhereInput | boolean;
    delete?: LectureWhereInput | boolean;
    connect?: LectureWhereUniqueInput;
    update?: XOR<
      XOR<
        LectureUpdateToOneWithWhereWithoutNoteInput,
        LectureUpdateWithoutNoteInput
      >,
      LectureUncheckedUpdateWithoutNoteInput
    >;
  };

  export type UserUpdateOneWithoutNoteNestedInput = {
    create?: XOR<
      UserCreateWithoutNoteInput,
      UserUncheckedCreateWithoutNoteInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutNoteInput;
    upsert?: UserUpsertWithoutNoteInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutNoteInput, UserUpdateWithoutNoteInput>,
      UserUncheckedUpdateWithoutNoteInput
    >;
  };

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<
      UserCreateWithoutNotificationInput,
      UserUncheckedCreateWithoutNotificationInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput;
    connect?: UserWhereUniqueInput;
  };

  export type NotificationReceiverCreateNestedManyWithoutNotificationInput = {
    create?:
      | XOR<
          NotificationReceiverCreateWithoutNotificationInput,
          NotificationReceiverUncheckedCreateWithoutNotificationInput
        >
      | NotificationReceiverCreateWithoutNotificationInput[]
      | NotificationReceiverUncheckedCreateWithoutNotificationInput[];
    connectOrCreate?:
      | NotificationReceiverCreateOrConnectWithoutNotificationInput
      | NotificationReceiverCreateOrConnectWithoutNotificationInput[];
    createMany?: NotificationReceiverCreateManyNotificationInputEnvelope;
    connect?:
      | NotificationReceiverWhereUniqueInput
      | NotificationReceiverWhereUniqueInput[];
  };

  export type NotificationReceiverUncheckedCreateNestedManyWithoutNotificationInput =
    {
      create?:
        | XOR<
            NotificationReceiverCreateWithoutNotificationInput,
            NotificationReceiverUncheckedCreateWithoutNotificationInput
          >
        | NotificationReceiverCreateWithoutNotificationInput[]
        | NotificationReceiverUncheckedCreateWithoutNotificationInput[];
      connectOrCreate?:
        | NotificationReceiverCreateOrConnectWithoutNotificationInput
        | NotificationReceiverCreateOrConnectWithoutNotificationInput[];
      createMany?: NotificationReceiverCreateManyNotificationInputEnvelope;
      connect?:
        | NotificationReceiverWhereUniqueInput
        | NotificationReceiverWhereUniqueInput[];
    };

  export type UserUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<
      UserCreateWithoutNotificationInput,
      UserUncheckedCreateWithoutNotificationInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput;
    upsert?: UserUpsertWithoutNotificationInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutNotificationInput,
        UserUpdateWithoutNotificationInput
      >,
      UserUncheckedUpdateWithoutNotificationInput
    >;
  };

  export type NotificationReceiverUpdateManyWithoutNotificationNestedInput = {
    create?:
      | XOR<
          NotificationReceiverCreateWithoutNotificationInput,
          NotificationReceiverUncheckedCreateWithoutNotificationInput
        >
      | NotificationReceiverCreateWithoutNotificationInput[]
      | NotificationReceiverUncheckedCreateWithoutNotificationInput[];
    connectOrCreate?:
      | NotificationReceiverCreateOrConnectWithoutNotificationInput
      | NotificationReceiverCreateOrConnectWithoutNotificationInput[];
    upsert?:
      | NotificationReceiverUpsertWithWhereUniqueWithoutNotificationInput
      | NotificationReceiverUpsertWithWhereUniqueWithoutNotificationInput[];
    createMany?: NotificationReceiverCreateManyNotificationInputEnvelope;
    set?:
      | NotificationReceiverWhereUniqueInput
      | NotificationReceiverWhereUniqueInput[];
    disconnect?:
      | NotificationReceiverWhereUniqueInput
      | NotificationReceiverWhereUniqueInput[];
    delete?:
      | NotificationReceiverWhereUniqueInput
      | NotificationReceiverWhereUniqueInput[];
    connect?:
      | NotificationReceiverWhereUniqueInput
      | NotificationReceiverWhereUniqueInput[];
    update?:
      | NotificationReceiverUpdateWithWhereUniqueWithoutNotificationInput
      | NotificationReceiverUpdateWithWhereUniqueWithoutNotificationInput[];
    updateMany?:
      | NotificationReceiverUpdateManyWithWhereWithoutNotificationInput
      | NotificationReceiverUpdateManyWithWhereWithoutNotificationInput[];
    deleteMany?:
      | NotificationReceiverScalarWhereInput
      | NotificationReceiverScalarWhereInput[];
  };

  export type NotificationReceiverUncheckedUpdateManyWithoutNotificationNestedInput =
    {
      create?:
        | XOR<
            NotificationReceiverCreateWithoutNotificationInput,
            NotificationReceiverUncheckedCreateWithoutNotificationInput
          >
        | NotificationReceiverCreateWithoutNotificationInput[]
        | NotificationReceiverUncheckedCreateWithoutNotificationInput[];
      connectOrCreate?:
        | NotificationReceiverCreateOrConnectWithoutNotificationInput
        | NotificationReceiverCreateOrConnectWithoutNotificationInput[];
      upsert?:
        | NotificationReceiverUpsertWithWhereUniqueWithoutNotificationInput
        | NotificationReceiverUpsertWithWhereUniqueWithoutNotificationInput[];
      createMany?: NotificationReceiverCreateManyNotificationInputEnvelope;
      set?:
        | NotificationReceiverWhereUniqueInput
        | NotificationReceiverWhereUniqueInput[];
      disconnect?:
        | NotificationReceiverWhereUniqueInput
        | NotificationReceiverWhereUniqueInput[];
      delete?:
        | NotificationReceiverWhereUniqueInput
        | NotificationReceiverWhereUniqueInput[];
      connect?:
        | NotificationReceiverWhereUniqueInput
        | NotificationReceiverWhereUniqueInput[];
      update?:
        | NotificationReceiverUpdateWithWhereUniqueWithoutNotificationInput
        | NotificationReceiverUpdateWithWhereUniqueWithoutNotificationInput[];
      updateMany?:
        | NotificationReceiverUpdateManyWithWhereWithoutNotificationInput
        | NotificationReceiverUpdateManyWithWhereWithoutNotificationInput[];
      deleteMany?:
        | NotificationReceiverScalarWhereInput
        | NotificationReceiverScalarWhereInput[];
    };

  export type NotificationCreateNestedOneWithoutNotificationReceiverInput = {
    create?: XOR<
      NotificationCreateWithoutNotificationReceiverInput,
      NotificationUncheckedCreateWithoutNotificationReceiverInput
    >;
    connectOrCreate?: NotificationCreateOrConnectWithoutNotificationReceiverInput;
    connect?: NotificationWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutNotificationReceiverInput = {
    create?: XOR<
      UserCreateWithoutNotificationReceiverInput,
      UserUncheckedCreateWithoutNotificationReceiverInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationReceiverInput;
    connect?: UserWhereUniqueInput;
  };

  export type NotificationUpdateOneRequiredWithoutNotificationReceiverNestedInput =
    {
      create?: XOR<
        NotificationCreateWithoutNotificationReceiverInput,
        NotificationUncheckedCreateWithoutNotificationReceiverInput
      >;
      connectOrCreate?: NotificationCreateOrConnectWithoutNotificationReceiverInput;
      upsert?: NotificationUpsertWithoutNotificationReceiverInput;
      connect?: NotificationWhereUniqueInput;
      update?: XOR<
        XOR<
          NotificationUpdateToOneWithWhereWithoutNotificationReceiverInput,
          NotificationUpdateWithoutNotificationReceiverInput
        >,
        NotificationUncheckedUpdateWithoutNotificationReceiverInput
      >;
    };

  export type UserUpdateOneRequiredWithoutNotificationReceiverNestedInput = {
    create?: XOR<
      UserCreateWithoutNotificationReceiverInput,
      UserUncheckedCreateWithoutNotificationReceiverInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationReceiverInput;
    upsert?: UserUpsertWithoutNotificationReceiverInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutNotificationReceiverInput,
        UserUpdateWithoutNotificationReceiverInput
      >,
      UserUncheckedUpdateWithoutNotificationReceiverInput
    >;
  };

  export type UserCreateNestedOneWithoutPaymentInput = {
    create?: XOR<
      UserCreateWithoutPaymentInput,
      UserUncheckedCreateWithoutPaymentInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutPaymentInput;
    connect?: UserWhereUniqueInput;
  };

  export type PaymentDetailCreateNestedManyWithoutPaymentInput = {
    create?:
      | XOR<
          PaymentDetailCreateWithoutPaymentInput,
          PaymentDetailUncheckedCreateWithoutPaymentInput
        >
      | PaymentDetailCreateWithoutPaymentInput[]
      | PaymentDetailUncheckedCreateWithoutPaymentInput[];
    connectOrCreate?:
      | PaymentDetailCreateOrConnectWithoutPaymentInput
      | PaymentDetailCreateOrConnectWithoutPaymentInput[];
    createMany?: PaymentDetailCreateManyPaymentInputEnvelope;
    connect?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[];
  };

  export type PaymentDetailUncheckedCreateNestedManyWithoutPaymentInput = {
    create?:
      | XOR<
          PaymentDetailCreateWithoutPaymentInput,
          PaymentDetailUncheckedCreateWithoutPaymentInput
        >
      | PaymentDetailCreateWithoutPaymentInput[]
      | PaymentDetailUncheckedCreateWithoutPaymentInput[];
    connectOrCreate?:
      | PaymentDetailCreateOrConnectWithoutPaymentInput
      | PaymentDetailCreateOrConnectWithoutPaymentInput[];
    createMany?: PaymentDetailCreateManyPaymentInputEnvelope;
    connect?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[];
  };

  export type UserUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<
      UserCreateWithoutPaymentInput,
      UserUncheckedCreateWithoutPaymentInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutPaymentInput;
    upsert?: UserUpsertWithoutPaymentInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutPaymentInput,
        UserUpdateWithoutPaymentInput
      >,
      UserUncheckedUpdateWithoutPaymentInput
    >;
  };

  export type PaymentDetailUpdateManyWithoutPaymentNestedInput = {
    create?:
      | XOR<
          PaymentDetailCreateWithoutPaymentInput,
          PaymentDetailUncheckedCreateWithoutPaymentInput
        >
      | PaymentDetailCreateWithoutPaymentInput[]
      | PaymentDetailUncheckedCreateWithoutPaymentInput[];
    connectOrCreate?:
      | PaymentDetailCreateOrConnectWithoutPaymentInput
      | PaymentDetailCreateOrConnectWithoutPaymentInput[];
    upsert?:
      | PaymentDetailUpsertWithWhereUniqueWithoutPaymentInput
      | PaymentDetailUpsertWithWhereUniqueWithoutPaymentInput[];
    createMany?: PaymentDetailCreateManyPaymentInputEnvelope;
    set?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[];
    disconnect?:
      | PaymentDetailWhereUniqueInput
      | PaymentDetailWhereUniqueInput[];
    delete?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[];
    connect?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[];
    update?:
      | PaymentDetailUpdateWithWhereUniqueWithoutPaymentInput
      | PaymentDetailUpdateWithWhereUniqueWithoutPaymentInput[];
    updateMany?:
      | PaymentDetailUpdateManyWithWhereWithoutPaymentInput
      | PaymentDetailUpdateManyWithWhereWithoutPaymentInput[];
    deleteMany?:
      | PaymentDetailScalarWhereInput
      | PaymentDetailScalarWhereInput[];
  };

  export type PaymentDetailUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?:
      | XOR<
          PaymentDetailCreateWithoutPaymentInput,
          PaymentDetailUncheckedCreateWithoutPaymentInput
        >
      | PaymentDetailCreateWithoutPaymentInput[]
      | PaymentDetailUncheckedCreateWithoutPaymentInput[];
    connectOrCreate?:
      | PaymentDetailCreateOrConnectWithoutPaymentInput
      | PaymentDetailCreateOrConnectWithoutPaymentInput[];
    upsert?:
      | PaymentDetailUpsertWithWhereUniqueWithoutPaymentInput
      | PaymentDetailUpsertWithWhereUniqueWithoutPaymentInput[];
    createMany?: PaymentDetailCreateManyPaymentInputEnvelope;
    set?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[];
    disconnect?:
      | PaymentDetailWhereUniqueInput
      | PaymentDetailWhereUniqueInput[];
    delete?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[];
    connect?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[];
    update?:
      | PaymentDetailUpdateWithWhereUniqueWithoutPaymentInput
      | PaymentDetailUpdateWithWhereUniqueWithoutPaymentInput[];
    updateMany?:
      | PaymentDetailUpdateManyWithWhereWithoutPaymentInput
      | PaymentDetailUpdateManyWithWhereWithoutPaymentInput[];
    deleteMany?:
      | PaymentDetailScalarWhereInput
      | PaymentDetailScalarWhereInput[];
  };

  export type CourseCreateNestedOneWithoutPaymentDetailInput = {
    create?: XOR<
      CourseCreateWithoutPaymentDetailInput,
      CourseUncheckedCreateWithoutPaymentDetailInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutPaymentDetailInput;
    connect?: CourseWhereUniqueInput;
  };

  export type PaymentCreateNestedOneWithoutPaymentDetailInput = {
    create?: XOR<
      PaymentCreateWithoutPaymentDetailInput,
      PaymentUncheckedCreateWithoutPaymentDetailInput
    >;
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentDetailInput;
    connect?: PaymentWhereUniqueInput;
  };

  export type CourseUpdateOneRequiredWithoutPaymentDetailNestedInput = {
    create?: XOR<
      CourseCreateWithoutPaymentDetailInput,
      CourseUncheckedCreateWithoutPaymentDetailInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutPaymentDetailInput;
    upsert?: CourseUpsertWithoutPaymentDetailInput;
    connect?: CourseWhereUniqueInput;
    update?: XOR<
      XOR<
        CourseUpdateToOneWithWhereWithoutPaymentDetailInput,
        CourseUpdateWithoutPaymentDetailInput
      >,
      CourseUncheckedUpdateWithoutPaymentDetailInput
    >;
  };

  export type PaymentUpdateOneRequiredWithoutPaymentDetailNestedInput = {
    create?: XOR<
      PaymentCreateWithoutPaymentDetailInput,
      PaymentUncheckedCreateWithoutPaymentDetailInput
    >;
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentDetailInput;
    upsert?: PaymentUpsertWithoutPaymentDetailInput;
    connect?: PaymentWhereUniqueInput;
    update?: XOR<
      XOR<
        PaymentUpdateToOneWithWhereWithoutPaymentDetailInput,
        PaymentUpdateWithoutPaymentDetailInput
      >,
      PaymentUncheckedUpdateWithoutPaymentDetailInput
    >;
  };

  export type AnswerCreateNestedManyWithoutQuestionInput = {
    create?:
      | XOR<
          AnswerCreateWithoutQuestionInput,
          AnswerUncheckedCreateWithoutQuestionInput
        >
      | AnswerCreateWithoutQuestionInput[]
      | AnswerUncheckedCreateWithoutQuestionInput[];
    connectOrCreate?:
      | AnswerCreateOrConnectWithoutQuestionInput
      | AnswerCreateOrConnectWithoutQuestionInput[];
    createMany?: AnswerCreateManyQuestionInputEnvelope;
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
  };

  export type LectureCreateNestedOneWithoutQuestionInput = {
    create?: XOR<
      LectureCreateWithoutQuestionInput,
      LectureUncheckedCreateWithoutQuestionInput
    >;
    connectOrCreate?: LectureCreateOrConnectWithoutQuestionInput;
    connect?: LectureWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutQuestionInput = {
    create?: XOR<
      UserCreateWithoutQuestionInput,
      UserUncheckedCreateWithoutQuestionInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutQuestionInput;
    connect?: UserWhereUniqueInput;
  };

  export type AnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?:
      | XOR<
          AnswerCreateWithoutQuestionInput,
          AnswerUncheckedCreateWithoutQuestionInput
        >
      | AnswerCreateWithoutQuestionInput[]
      | AnswerUncheckedCreateWithoutQuestionInput[];
    connectOrCreate?:
      | AnswerCreateOrConnectWithoutQuestionInput
      | AnswerCreateOrConnectWithoutQuestionInput[];
    createMany?: AnswerCreateManyQuestionInputEnvelope;
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
  };

  export type AnswerUpdateManyWithoutQuestionNestedInput = {
    create?:
      | XOR<
          AnswerCreateWithoutQuestionInput,
          AnswerUncheckedCreateWithoutQuestionInput
        >
      | AnswerCreateWithoutQuestionInput[]
      | AnswerUncheckedCreateWithoutQuestionInput[];
    connectOrCreate?:
      | AnswerCreateOrConnectWithoutQuestionInput
      | AnswerCreateOrConnectWithoutQuestionInput[];
    upsert?:
      | AnswerUpsertWithWhereUniqueWithoutQuestionInput
      | AnswerUpsertWithWhereUniqueWithoutQuestionInput[];
    createMany?: AnswerCreateManyQuestionInputEnvelope;
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
    update?:
      | AnswerUpdateWithWhereUniqueWithoutQuestionInput
      | AnswerUpdateWithWhereUniqueWithoutQuestionInput[];
    updateMany?:
      | AnswerUpdateManyWithWhereWithoutQuestionInput
      | AnswerUpdateManyWithWhereWithoutQuestionInput[];
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[];
  };

  export type LectureUpdateOneWithoutQuestionNestedInput = {
    create?: XOR<
      LectureCreateWithoutQuestionInput,
      LectureUncheckedCreateWithoutQuestionInput
    >;
    connectOrCreate?: LectureCreateOrConnectWithoutQuestionInput;
    upsert?: LectureUpsertWithoutQuestionInput;
    disconnect?: LectureWhereInput | boolean;
    delete?: LectureWhereInput | boolean;
    connect?: LectureWhereUniqueInput;
    update?: XOR<
      XOR<
        LectureUpdateToOneWithWhereWithoutQuestionInput,
        LectureUpdateWithoutQuestionInput
      >,
      LectureUncheckedUpdateWithoutQuestionInput
    >;
  };

  export type UserUpdateOneWithoutQuestionNestedInput = {
    create?: XOR<
      UserCreateWithoutQuestionInput,
      UserUncheckedCreateWithoutQuestionInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutQuestionInput;
    upsert?: UserUpsertWithoutQuestionInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutQuestionInput,
        UserUpdateWithoutQuestionInput
      >,
      UserUncheckedUpdateWithoutQuestionInput
    >;
  };

  export type AnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?:
      | XOR<
          AnswerCreateWithoutQuestionInput,
          AnswerUncheckedCreateWithoutQuestionInput
        >
      | AnswerCreateWithoutQuestionInput[]
      | AnswerUncheckedCreateWithoutQuestionInput[];
    connectOrCreate?:
      | AnswerCreateOrConnectWithoutQuestionInput
      | AnswerCreateOrConnectWithoutQuestionInput[];
    upsert?:
      | AnswerUpsertWithWhereUniqueWithoutQuestionInput
      | AnswerUpsertWithWhereUniqueWithoutQuestionInput[];
    createMany?: AnswerCreateManyQuestionInputEnvelope;
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
    update?:
      | AnswerUpdateWithWhereUniqueWithoutQuestionInput
      | AnswerUpdateWithWhereUniqueWithoutQuestionInput[];
    updateMany?:
      | AnswerUpdateManyWithWhereWithoutQuestionInput
      | AnswerUpdateManyWithWhereWithoutQuestionInput[];
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutReportInput = {
    create?: XOR<
      UserCreateWithoutReportInput,
      UserUncheckedCreateWithoutReportInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutReportInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneWithoutReportNestedInput = {
    create?: XOR<
      UserCreateWithoutReportInput,
      UserUncheckedCreateWithoutReportInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutReportInput;
    upsert?: UserUpsertWithoutReportInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutReportInput,
        UserUpdateWithoutReportInput
      >,
      UserUncheckedUpdateWithoutReportInput
    >;
  };

  export type CourseCreateNestedOneWithoutReviewInput = {
    create?: XOR<
      CourseCreateWithoutReviewInput,
      CourseUncheckedCreateWithoutReviewInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutReviewInput;
    connect?: CourseWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutReviewInput = {
    create?: XOR<
      UserCreateWithoutReviewInput,
      UserUncheckedCreateWithoutReviewInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutReviewInput;
    connect?: UserWhereUniqueInput;
  };

  export type CourseUpdateOneWithoutReviewNestedInput = {
    create?: XOR<
      CourseCreateWithoutReviewInput,
      CourseUncheckedCreateWithoutReviewInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutReviewInput;
    upsert?: CourseUpsertWithoutReviewInput;
    disconnect?: CourseWhereInput | boolean;
    delete?: CourseWhereInput | boolean;
    connect?: CourseWhereUniqueInput;
    update?: XOR<
      XOR<
        CourseUpdateToOneWithWhereWithoutReviewInput,
        CourseUpdateWithoutReviewInput
      >,
      CourseUncheckedUpdateWithoutReviewInput
    >;
  };

  export type UserUpdateOneWithoutReviewNestedInput = {
    create?: XOR<
      UserCreateWithoutReviewInput,
      UserUncheckedCreateWithoutReviewInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutReviewInput;
    upsert?: UserUpsertWithoutReviewInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutReviewInput,
        UserUpdateWithoutReviewInput
      >,
      UserUncheckedUpdateWithoutReviewInput
    >;
  };

  export type LectureCreateNestedManyWithoutSectionInput = {
    create?:
      | XOR<
          LectureCreateWithoutSectionInput,
          LectureUncheckedCreateWithoutSectionInput
        >
      | LectureCreateWithoutSectionInput[]
      | LectureUncheckedCreateWithoutSectionInput[];
    connectOrCreate?:
      | LectureCreateOrConnectWithoutSectionInput
      | LectureCreateOrConnectWithoutSectionInput[];
    createMany?: LectureCreateManySectionInputEnvelope;
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
  };

  export type CourseCreateNestedOneWithoutSectionInput = {
    create?: XOR<
      CourseCreateWithoutSectionInput,
      CourseUncheckedCreateWithoutSectionInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutSectionInput;
    connect?: CourseWhereUniqueInput;
  };

  export type LectureUncheckedCreateNestedManyWithoutSectionInput = {
    create?:
      | XOR<
          LectureCreateWithoutSectionInput,
          LectureUncheckedCreateWithoutSectionInput
        >
      | LectureCreateWithoutSectionInput[]
      | LectureUncheckedCreateWithoutSectionInput[];
    connectOrCreate?:
      | LectureCreateOrConnectWithoutSectionInput
      | LectureCreateOrConnectWithoutSectionInput[];
    createMany?: LectureCreateManySectionInputEnvelope;
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
  };

  export type LectureUpdateManyWithoutSectionNestedInput = {
    create?:
      | XOR<
          LectureCreateWithoutSectionInput,
          LectureUncheckedCreateWithoutSectionInput
        >
      | LectureCreateWithoutSectionInput[]
      | LectureUncheckedCreateWithoutSectionInput[];
    connectOrCreate?:
      | LectureCreateOrConnectWithoutSectionInput
      | LectureCreateOrConnectWithoutSectionInput[];
    upsert?:
      | LectureUpsertWithWhereUniqueWithoutSectionInput
      | LectureUpsertWithWhereUniqueWithoutSectionInput[];
    createMany?: LectureCreateManySectionInputEnvelope;
    set?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    disconnect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    delete?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    update?:
      | LectureUpdateWithWhereUniqueWithoutSectionInput
      | LectureUpdateWithWhereUniqueWithoutSectionInput[];
    updateMany?:
      | LectureUpdateManyWithWhereWithoutSectionInput
      | LectureUpdateManyWithWhereWithoutSectionInput[];
    deleteMany?: LectureScalarWhereInput | LectureScalarWhereInput[];
  };

  export type CourseUpdateOneRequiredWithoutSectionNestedInput = {
    create?: XOR<
      CourseCreateWithoutSectionInput,
      CourseUncheckedCreateWithoutSectionInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutSectionInput;
    upsert?: CourseUpsertWithoutSectionInput;
    connect?: CourseWhereUniqueInput;
    update?: XOR<
      XOR<
        CourseUpdateToOneWithWhereWithoutSectionInput,
        CourseUpdateWithoutSectionInput
      >,
      CourseUncheckedUpdateWithoutSectionInput
    >;
  };

  export type LectureUncheckedUpdateManyWithoutSectionNestedInput = {
    create?:
      | XOR<
          LectureCreateWithoutSectionInput,
          LectureUncheckedCreateWithoutSectionInput
        >
      | LectureCreateWithoutSectionInput[]
      | LectureUncheckedCreateWithoutSectionInput[];
    connectOrCreate?:
      | LectureCreateOrConnectWithoutSectionInput
      | LectureCreateOrConnectWithoutSectionInput[];
    upsert?:
      | LectureUpsertWithWhereUniqueWithoutSectionInput
      | LectureUpsertWithWhereUniqueWithoutSectionInput[];
    createMany?: LectureCreateManySectionInputEnvelope;
    set?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    disconnect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    delete?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    update?:
      | LectureUpdateWithWhereUniqueWithoutSectionInput
      | LectureUpdateWithWhereUniqueWithoutSectionInput[];
    updateMany?:
      | LectureUpdateManyWithWhereWithoutSectionInput
      | LectureUpdateManyWithWhereWithoutSectionInput[];
    deleteMany?: LectureScalarWhereInput | LectureScalarWhereInput[];
  };

  export type CourseCreateNestedOneWithoutStudyRemindInput = {
    create?: XOR<
      CourseCreateWithoutStudyRemindInput,
      CourseUncheckedCreateWithoutStudyRemindInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutStudyRemindInput;
    connect?: CourseWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutStudyRemindInput = {
    create?: XOR<
      UserCreateWithoutStudyRemindInput,
      UserUncheckedCreateWithoutStudyRemindInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutStudyRemindInput;
    connect?: UserWhereUniqueInput;
  };

  export type CourseUpdateOneWithoutStudyRemindNestedInput = {
    create?: XOR<
      CourseCreateWithoutStudyRemindInput,
      CourseUncheckedCreateWithoutStudyRemindInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutStudyRemindInput;
    upsert?: CourseUpsertWithoutStudyRemindInput;
    disconnect?: CourseWhereInput | boolean;
    delete?: CourseWhereInput | boolean;
    connect?: CourseWhereUniqueInput;
    update?: XOR<
      XOR<
        CourseUpdateToOneWithWhereWithoutStudyRemindInput,
        CourseUpdateWithoutStudyRemindInput
      >,
      CourseUncheckedUpdateWithoutStudyRemindInput
    >;
  };

  export type UserUpdateOneWithoutStudyRemindNestedInput = {
    create?: XOR<
      UserCreateWithoutStudyRemindInput,
      UserUncheckedCreateWithoutStudyRemindInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutStudyRemindInput;
    upsert?: UserUpsertWithoutStudyRemindInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutStudyRemindInput,
        UserUpdateWithoutStudyRemindInput
      >,
      UserUncheckedUpdateWithoutStudyRemindInput
    >;
  };

  export type AnswerCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AnswerCreateWithoutUserInput, AnswerUncheckedCreateWithoutUserInput>
      | AnswerCreateWithoutUserInput[]
      | AnswerUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AnswerCreateOrConnectWithoutUserInput
      | AnswerCreateOrConnectWithoutUserInput[];
    createMany?: AnswerCreateManyUserInputEnvelope;
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
  };

  export type CartCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
      | CartCreateWithoutUserInput[]
      | CartUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CartCreateOrConnectWithoutUserInput
      | CartCreateOrConnectWithoutUserInput[];
    createMany?: CartCreateManyUserInputEnvelope;
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[];
  };

  export type CouponCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<CouponCreateWithoutUserInput, CouponUncheckedCreateWithoutUserInput>
      | CouponCreateWithoutUserInput[]
      | CouponUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CouponCreateOrConnectWithoutUserInput
      | CouponCreateOrConnectWithoutUserInput[];
    createMany?: CouponCreateManyUserInputEnvelope;
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[];
  };

  export type CourseCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput>
      | CourseCreateWithoutUserInput[]
      | CourseUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CourseCreateOrConnectWithoutUserInput
      | CourseCreateOrConnectWithoutUserInput[];
    createMany?: CourseCreateManyUserInputEnvelope;
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[];
  };

  export type EnrollmentCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          EnrollmentCreateWithoutUserInput,
          EnrollmentUncheckedCreateWithoutUserInput
        >
      | EnrollmentCreateWithoutUserInput[]
      | EnrollmentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | EnrollmentCreateOrConnectWithoutUserInput
      | EnrollmentCreateOrConnectWithoutUserInput[];
    createMany?: EnrollmentCreateManyUserInputEnvelope;
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
  };

  export type FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput = {
    create?:
      | XOR<
          FollowCreateWithoutUser_Follow_idFollowerToUserInput,
          FollowUncheckedCreateWithoutUser_Follow_idFollowerToUserInput
        >
      | FollowCreateWithoutUser_Follow_idFollowerToUserInput[]
      | FollowUncheckedCreateWithoutUser_Follow_idFollowerToUserInput[];
    connectOrCreate?:
      | FollowCreateOrConnectWithoutUser_Follow_idFollowerToUserInput
      | FollowCreateOrConnectWithoutUser_Follow_idFollowerToUserInput[];
    createMany?: FollowCreateManyUser_Follow_idFollowerToUserInputEnvelope;
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
  };

  export type FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput =
    {
      create?:
        | XOR<
            FollowCreateWithoutUser_Follow_idFollowingToUserInput,
            FollowUncheckedCreateWithoutUser_Follow_idFollowingToUserInput
          >
        | FollowCreateWithoutUser_Follow_idFollowingToUserInput[]
        | FollowUncheckedCreateWithoutUser_Follow_idFollowingToUserInput[];
      connectOrCreate?:
        | FollowCreateOrConnectWithoutUser_Follow_idFollowingToUserInput
        | FollowCreateOrConnectWithoutUser_Follow_idFollowingToUserInput[];
      createMany?: FollowCreateManyUser_Follow_idFollowingToUserInputEnvelope;
      connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
    };

  export type MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput =
    {
      create?:
        | XOR<
            MessageCreateWithoutUser_Message_idUserReceiverToUserInput,
            MessageUncheckedCreateWithoutUser_Message_idUserReceiverToUserInput
          >
        | MessageCreateWithoutUser_Message_idUserReceiverToUserInput[]
        | MessageUncheckedCreateWithoutUser_Message_idUserReceiverToUserInput[];
      connectOrCreate?:
        | MessageCreateOrConnectWithoutUser_Message_idUserReceiverToUserInput
        | MessageCreateOrConnectWithoutUser_Message_idUserReceiverToUserInput[];
      createMany?: MessageCreateManyUser_Message_idUserReceiverToUserInputEnvelope;
      connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    };

  export type MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput =
    {
      create?:
        | XOR<
            MessageCreateWithoutUser_Message_idUserSenderToUserInput,
            MessageUncheckedCreateWithoutUser_Message_idUserSenderToUserInput
          >
        | MessageCreateWithoutUser_Message_idUserSenderToUserInput[]
        | MessageUncheckedCreateWithoutUser_Message_idUserSenderToUserInput[];
      connectOrCreate?:
        | MessageCreateOrConnectWithoutUser_Message_idUserSenderToUserInput
        | MessageCreateOrConnectWithoutUser_Message_idUserSenderToUserInput[];
      createMany?: MessageCreateManyUser_Message_idUserSenderToUserInputEnvelope;
      connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    };

  export type NoteCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput>
      | NoteCreateWithoutUserInput[]
      | NoteUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NoteCreateOrConnectWithoutUserInput
      | NoteCreateOrConnectWithoutUserInput[];
    createMany?: NoteCreateManyUserInputEnvelope;
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
  };

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          NotificationCreateWithoutUserInput,
          NotificationUncheckedCreateWithoutUserInput
        >
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type NotificationReceiverCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          NotificationReceiverCreateWithoutUserInput,
          NotificationReceiverUncheckedCreateWithoutUserInput
        >
      | NotificationReceiverCreateWithoutUserInput[]
      | NotificationReceiverUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationReceiverCreateOrConnectWithoutUserInput
      | NotificationReceiverCreateOrConnectWithoutUserInput[];
    createMany?: NotificationReceiverCreateManyUserInputEnvelope;
    connect?:
      | NotificationReceiverWhereUniqueInput
      | NotificationReceiverWhereUniqueInput[];
  };

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          PaymentCreateWithoutUserInput,
          PaymentUncheckedCreateWithoutUserInput
        >
      | PaymentCreateWithoutUserInput[]
      | PaymentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PaymentCreateOrConnectWithoutUserInput
      | PaymentCreateOrConnectWithoutUserInput[];
    createMany?: PaymentCreateManyUserInputEnvelope;
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
  };

  export type QuestionCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          QuestionCreateWithoutUserInput,
          QuestionUncheckedCreateWithoutUserInput
        >
      | QuestionCreateWithoutUserInput[]
      | QuestionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | QuestionCreateOrConnectWithoutUserInput
      | QuestionCreateOrConnectWithoutUserInput[];
    createMany?: QuestionCreateManyUserInputEnvelope;
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
  };

  export type ReportCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput>
      | ReportCreateWithoutUserInput[]
      | ReportUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ReportCreateOrConnectWithoutUserInput
      | ReportCreateOrConnectWithoutUserInput[];
    createMany?: ReportCreateManyUserInputEnvelope;
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
  };

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
      | ReviewCreateWithoutUserInput[]
      | ReviewUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutUserInput
      | ReviewCreateOrConnectWithoutUserInput[];
    createMany?: ReviewCreateManyUserInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type StudyRemindCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          StudyRemindCreateWithoutUserInput,
          StudyRemindUncheckedCreateWithoutUserInput
        >
      | StudyRemindCreateWithoutUserInput[]
      | StudyRemindUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | StudyRemindCreateOrConnectWithoutUserInput
      | StudyRemindCreateOrConnectWithoutUserInput[];
    createMany?: StudyRemindCreateManyUserInputEnvelope;
    connect?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
  };

  export type UserCertificateCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          UserCertificateCreateWithoutUserInput,
          UserCertificateUncheckedCreateWithoutUserInput
        >
      | UserCertificateCreateWithoutUserInput[]
      | UserCertificateUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserCertificateCreateOrConnectWithoutUserInput
      | UserCertificateCreateOrConnectWithoutUserInput[];
    createMany?: UserCertificateCreateManyUserInputEnvelope;
    connect?:
      | UserCertificateWhereUniqueInput
      | UserCertificateWhereUniqueInput[];
  };

  export type UserCouponCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          UserCouponCreateWithoutUserInput,
          UserCouponUncheckedCreateWithoutUserInput
        >
      | UserCouponCreateWithoutUserInput[]
      | UserCouponUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserCouponCreateOrConnectWithoutUserInput
      | UserCouponCreateOrConnectWithoutUserInput[];
    createMany?: UserCouponCreateManyUserInputEnvelope;
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
  };

  export type WishlistCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          WishlistCreateWithoutUserInput,
          WishlistUncheckedCreateWithoutUserInput
        >
      | WishlistCreateWithoutUserInput[]
      | WishlistUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | WishlistCreateOrConnectWithoutUserInput
      | WishlistCreateOrConnectWithoutUserInput[];
    createMany?: WishlistCreateManyUserInputEnvelope;
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
  };

  export type AnswerUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AnswerCreateWithoutUserInput, AnswerUncheckedCreateWithoutUserInput>
      | AnswerCreateWithoutUserInput[]
      | AnswerUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AnswerCreateOrConnectWithoutUserInput
      | AnswerCreateOrConnectWithoutUserInput[];
    createMany?: AnswerCreateManyUserInputEnvelope;
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
  };

  export type CartUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
      | CartCreateWithoutUserInput[]
      | CartUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CartCreateOrConnectWithoutUserInput
      | CartCreateOrConnectWithoutUserInput[];
    createMany?: CartCreateManyUserInputEnvelope;
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[];
  };

  export type CouponUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<CouponCreateWithoutUserInput, CouponUncheckedCreateWithoutUserInput>
      | CouponCreateWithoutUserInput[]
      | CouponUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CouponCreateOrConnectWithoutUserInput
      | CouponCreateOrConnectWithoutUserInput[];
    createMany?: CouponCreateManyUserInputEnvelope;
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[];
  };

  export type CourseUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput>
      | CourseCreateWithoutUserInput[]
      | CourseUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CourseCreateOrConnectWithoutUserInput
      | CourseCreateOrConnectWithoutUserInput[];
    createMany?: CourseCreateManyUserInputEnvelope;
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[];
  };

  export type EnrollmentUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          EnrollmentCreateWithoutUserInput,
          EnrollmentUncheckedCreateWithoutUserInput
        >
      | EnrollmentCreateWithoutUserInput[]
      | EnrollmentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | EnrollmentCreateOrConnectWithoutUserInput
      | EnrollmentCreateOrConnectWithoutUserInput[];
    createMany?: EnrollmentCreateManyUserInputEnvelope;
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
  };

  export type FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput =
    {
      create?:
        | XOR<
            FollowCreateWithoutUser_Follow_idFollowerToUserInput,
            FollowUncheckedCreateWithoutUser_Follow_idFollowerToUserInput
          >
        | FollowCreateWithoutUser_Follow_idFollowerToUserInput[]
        | FollowUncheckedCreateWithoutUser_Follow_idFollowerToUserInput[];
      connectOrCreate?:
        | FollowCreateOrConnectWithoutUser_Follow_idFollowerToUserInput
        | FollowCreateOrConnectWithoutUser_Follow_idFollowerToUserInput[];
      createMany?: FollowCreateManyUser_Follow_idFollowerToUserInputEnvelope;
      connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
    };

  export type FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput =
    {
      create?:
        | XOR<
            FollowCreateWithoutUser_Follow_idFollowingToUserInput,
            FollowUncheckedCreateWithoutUser_Follow_idFollowingToUserInput
          >
        | FollowCreateWithoutUser_Follow_idFollowingToUserInput[]
        | FollowUncheckedCreateWithoutUser_Follow_idFollowingToUserInput[];
      connectOrCreate?:
        | FollowCreateOrConnectWithoutUser_Follow_idFollowingToUserInput
        | FollowCreateOrConnectWithoutUser_Follow_idFollowingToUserInput[];
      createMany?: FollowCreateManyUser_Follow_idFollowingToUserInputEnvelope;
      connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
    };

  export type MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput =
    {
      create?:
        | XOR<
            MessageCreateWithoutUser_Message_idUserReceiverToUserInput,
            MessageUncheckedCreateWithoutUser_Message_idUserReceiverToUserInput
          >
        | MessageCreateWithoutUser_Message_idUserReceiverToUserInput[]
        | MessageUncheckedCreateWithoutUser_Message_idUserReceiverToUserInput[];
      connectOrCreate?:
        | MessageCreateOrConnectWithoutUser_Message_idUserReceiverToUserInput
        | MessageCreateOrConnectWithoutUser_Message_idUserReceiverToUserInput[];
      createMany?: MessageCreateManyUser_Message_idUserReceiverToUserInputEnvelope;
      connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    };

  export type MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput =
    {
      create?:
        | XOR<
            MessageCreateWithoutUser_Message_idUserSenderToUserInput,
            MessageUncheckedCreateWithoutUser_Message_idUserSenderToUserInput
          >
        | MessageCreateWithoutUser_Message_idUserSenderToUserInput[]
        | MessageUncheckedCreateWithoutUser_Message_idUserSenderToUserInput[];
      connectOrCreate?:
        | MessageCreateOrConnectWithoutUser_Message_idUserSenderToUserInput
        | MessageCreateOrConnectWithoutUser_Message_idUserSenderToUserInput[];
      createMany?: MessageCreateManyUser_Message_idUserSenderToUserInputEnvelope;
      connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    };

  export type NoteUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput>
      | NoteCreateWithoutUserInput[]
      | NoteUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NoteCreateOrConnectWithoutUserInput
      | NoteCreateOrConnectWithoutUserInput[];
    createMany?: NoteCreateManyUserInputEnvelope;
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
  };

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          NotificationCreateWithoutUserInput,
          NotificationUncheckedCreateWithoutUserInput
        >
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type NotificationReceiverUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          NotificationReceiverCreateWithoutUserInput,
          NotificationReceiverUncheckedCreateWithoutUserInput
        >
      | NotificationReceiverCreateWithoutUserInput[]
      | NotificationReceiverUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationReceiverCreateOrConnectWithoutUserInput
      | NotificationReceiverCreateOrConnectWithoutUserInput[];
    createMany?: NotificationReceiverCreateManyUserInputEnvelope;
    connect?:
      | NotificationReceiverWhereUniqueInput
      | NotificationReceiverWhereUniqueInput[];
  };

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          PaymentCreateWithoutUserInput,
          PaymentUncheckedCreateWithoutUserInput
        >
      | PaymentCreateWithoutUserInput[]
      | PaymentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PaymentCreateOrConnectWithoutUserInput
      | PaymentCreateOrConnectWithoutUserInput[];
    createMany?: PaymentCreateManyUserInputEnvelope;
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
  };

  export type QuestionUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          QuestionCreateWithoutUserInput,
          QuestionUncheckedCreateWithoutUserInput
        >
      | QuestionCreateWithoutUserInput[]
      | QuestionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | QuestionCreateOrConnectWithoutUserInput
      | QuestionCreateOrConnectWithoutUserInput[];
    createMany?: QuestionCreateManyUserInputEnvelope;
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
  };

  export type ReportUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput>
      | ReportCreateWithoutUserInput[]
      | ReportUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ReportCreateOrConnectWithoutUserInput
      | ReportCreateOrConnectWithoutUserInput[];
    createMany?: ReportCreateManyUserInputEnvelope;
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
  };

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
      | ReviewCreateWithoutUserInput[]
      | ReviewUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutUserInput
      | ReviewCreateOrConnectWithoutUserInput[];
    createMany?: ReviewCreateManyUserInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type StudyRemindUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          StudyRemindCreateWithoutUserInput,
          StudyRemindUncheckedCreateWithoutUserInput
        >
      | StudyRemindCreateWithoutUserInput[]
      | StudyRemindUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | StudyRemindCreateOrConnectWithoutUserInput
      | StudyRemindCreateOrConnectWithoutUserInput[];
    createMany?: StudyRemindCreateManyUserInputEnvelope;
    connect?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
  };

  export type UserCertificateUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          UserCertificateCreateWithoutUserInput,
          UserCertificateUncheckedCreateWithoutUserInput
        >
      | UserCertificateCreateWithoutUserInput[]
      | UserCertificateUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserCertificateCreateOrConnectWithoutUserInput
      | UserCertificateCreateOrConnectWithoutUserInput[];
    createMany?: UserCertificateCreateManyUserInputEnvelope;
    connect?:
      | UserCertificateWhereUniqueInput
      | UserCertificateWhereUniqueInput[];
  };

  export type UserCouponUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          UserCouponCreateWithoutUserInput,
          UserCouponUncheckedCreateWithoutUserInput
        >
      | UserCouponCreateWithoutUserInput[]
      | UserCouponUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserCouponCreateOrConnectWithoutUserInput
      | UserCouponCreateOrConnectWithoutUserInput[];
    createMany?: UserCouponCreateManyUserInputEnvelope;
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
  };

  export type WishlistUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          WishlistCreateWithoutUserInput,
          WishlistUncheckedCreateWithoutUserInput
        >
      | WishlistCreateWithoutUserInput[]
      | WishlistUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | WishlistCreateOrConnectWithoutUserInput
      | WishlistCreateOrConnectWithoutUserInput[];
    createMany?: WishlistCreateManyUserInputEnvelope;
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
  };

  export type AnswerUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AnswerCreateWithoutUserInput, AnswerUncheckedCreateWithoutUserInput>
      | AnswerCreateWithoutUserInput[]
      | AnswerUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AnswerCreateOrConnectWithoutUserInput
      | AnswerCreateOrConnectWithoutUserInput[];
    upsert?:
      | AnswerUpsertWithWhereUniqueWithoutUserInput
      | AnswerUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AnswerCreateManyUserInputEnvelope;
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
    update?:
      | AnswerUpdateWithWhereUniqueWithoutUserInput
      | AnswerUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AnswerUpdateManyWithWhereWithoutUserInput
      | AnswerUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[];
  };

  export type CartUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
      | CartCreateWithoutUserInput[]
      | CartUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CartCreateOrConnectWithoutUserInput
      | CartCreateOrConnectWithoutUserInput[];
    upsert?:
      | CartUpsertWithWhereUniqueWithoutUserInput
      | CartUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: CartCreateManyUserInputEnvelope;
    set?: CartWhereUniqueInput | CartWhereUniqueInput[];
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[];
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[];
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[];
    update?:
      | CartUpdateWithWhereUniqueWithoutUserInput
      | CartUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | CartUpdateManyWithWhereWithoutUserInput
      | CartUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[];
  };

  export type CouponUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<CouponCreateWithoutUserInput, CouponUncheckedCreateWithoutUserInput>
      | CouponCreateWithoutUserInput[]
      | CouponUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CouponCreateOrConnectWithoutUserInput
      | CouponCreateOrConnectWithoutUserInput[];
    upsert?:
      | CouponUpsertWithWhereUniqueWithoutUserInput
      | CouponUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: CouponCreateManyUserInputEnvelope;
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[];
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[];
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[];
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[];
    update?:
      | CouponUpdateWithWhereUniqueWithoutUserInput
      | CouponUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | CouponUpdateManyWithWhereWithoutUserInput
      | CouponUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[];
  };

  export type CourseUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput>
      | CourseCreateWithoutUserInput[]
      | CourseUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CourseCreateOrConnectWithoutUserInput
      | CourseCreateOrConnectWithoutUserInput[];
    upsert?:
      | CourseUpsertWithWhereUniqueWithoutUserInput
      | CourseUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: CourseCreateManyUserInputEnvelope;
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[];
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[];
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[];
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[];
    update?:
      | CourseUpdateWithWhereUniqueWithoutUserInput
      | CourseUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | CourseUpdateManyWithWhereWithoutUserInput
      | CourseUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[];
  };

  export type EnrollmentUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          EnrollmentCreateWithoutUserInput,
          EnrollmentUncheckedCreateWithoutUserInput
        >
      | EnrollmentCreateWithoutUserInput[]
      | EnrollmentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | EnrollmentCreateOrConnectWithoutUserInput
      | EnrollmentCreateOrConnectWithoutUserInput[];
    upsert?:
      | EnrollmentUpsertWithWhereUniqueWithoutUserInput
      | EnrollmentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: EnrollmentCreateManyUserInputEnvelope;
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
    update?:
      | EnrollmentUpdateWithWhereUniqueWithoutUserInput
      | EnrollmentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | EnrollmentUpdateManyWithWhereWithoutUserInput
      | EnrollmentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[];
  };

  export type FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput = {
    create?:
      | XOR<
          FollowCreateWithoutUser_Follow_idFollowerToUserInput,
          FollowUncheckedCreateWithoutUser_Follow_idFollowerToUserInput
        >
      | FollowCreateWithoutUser_Follow_idFollowerToUserInput[]
      | FollowUncheckedCreateWithoutUser_Follow_idFollowerToUserInput[];
    connectOrCreate?:
      | FollowCreateOrConnectWithoutUser_Follow_idFollowerToUserInput
      | FollowCreateOrConnectWithoutUser_Follow_idFollowerToUserInput[];
    upsert?:
      | FollowUpsertWithWhereUniqueWithoutUser_Follow_idFollowerToUserInput
      | FollowUpsertWithWhereUniqueWithoutUser_Follow_idFollowerToUserInput[];
    createMany?: FollowCreateManyUser_Follow_idFollowerToUserInputEnvelope;
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
    update?:
      | FollowUpdateWithWhereUniqueWithoutUser_Follow_idFollowerToUserInput
      | FollowUpdateWithWhereUniqueWithoutUser_Follow_idFollowerToUserInput[];
    updateMany?:
      | FollowUpdateManyWithWhereWithoutUser_Follow_idFollowerToUserInput
      | FollowUpdateManyWithWhereWithoutUser_Follow_idFollowerToUserInput[];
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[];
  };

  export type FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput =
    {
      create?:
        | XOR<
            FollowCreateWithoutUser_Follow_idFollowingToUserInput,
            FollowUncheckedCreateWithoutUser_Follow_idFollowingToUserInput
          >
        | FollowCreateWithoutUser_Follow_idFollowingToUserInput[]
        | FollowUncheckedCreateWithoutUser_Follow_idFollowingToUserInput[];
      connectOrCreate?:
        | FollowCreateOrConnectWithoutUser_Follow_idFollowingToUserInput
        | FollowCreateOrConnectWithoutUser_Follow_idFollowingToUserInput[];
      upsert?:
        | FollowUpsertWithWhereUniqueWithoutUser_Follow_idFollowingToUserInput
        | FollowUpsertWithWhereUniqueWithoutUser_Follow_idFollowingToUserInput[];
      createMany?: FollowCreateManyUser_Follow_idFollowingToUserInputEnvelope;
      set?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
      disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
      delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
      connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
      update?:
        | FollowUpdateWithWhereUniqueWithoutUser_Follow_idFollowingToUserInput
        | FollowUpdateWithWhereUniqueWithoutUser_Follow_idFollowingToUserInput[];
      updateMany?:
        | FollowUpdateManyWithWhereWithoutUser_Follow_idFollowingToUserInput
        | FollowUpdateManyWithWhereWithoutUser_Follow_idFollowingToUserInput[];
      deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[];
    };

  export type MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput =
    {
      create?:
        | XOR<
            MessageCreateWithoutUser_Message_idUserReceiverToUserInput,
            MessageUncheckedCreateWithoutUser_Message_idUserReceiverToUserInput
          >
        | MessageCreateWithoutUser_Message_idUserReceiverToUserInput[]
        | MessageUncheckedCreateWithoutUser_Message_idUserReceiverToUserInput[];
      connectOrCreate?:
        | MessageCreateOrConnectWithoutUser_Message_idUserReceiverToUserInput
        | MessageCreateOrConnectWithoutUser_Message_idUserReceiverToUserInput[];
      upsert?:
        | MessageUpsertWithWhereUniqueWithoutUser_Message_idUserReceiverToUserInput
        | MessageUpsertWithWhereUniqueWithoutUser_Message_idUserReceiverToUserInput[];
      createMany?: MessageCreateManyUser_Message_idUserReceiverToUserInputEnvelope;
      set?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
      disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
      delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
      connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
      update?:
        | MessageUpdateWithWhereUniqueWithoutUser_Message_idUserReceiverToUserInput
        | MessageUpdateWithWhereUniqueWithoutUser_Message_idUserReceiverToUserInput[];
      updateMany?:
        | MessageUpdateManyWithWhereWithoutUser_Message_idUserReceiverToUserInput
        | MessageUpdateManyWithWhereWithoutUser_Message_idUserReceiverToUserInput[];
      deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[];
    };

  export type MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput =
    {
      create?:
        | XOR<
            MessageCreateWithoutUser_Message_idUserSenderToUserInput,
            MessageUncheckedCreateWithoutUser_Message_idUserSenderToUserInput
          >
        | MessageCreateWithoutUser_Message_idUserSenderToUserInput[]
        | MessageUncheckedCreateWithoutUser_Message_idUserSenderToUserInput[];
      connectOrCreate?:
        | MessageCreateOrConnectWithoutUser_Message_idUserSenderToUserInput
        | MessageCreateOrConnectWithoutUser_Message_idUserSenderToUserInput[];
      upsert?:
        | MessageUpsertWithWhereUniqueWithoutUser_Message_idUserSenderToUserInput
        | MessageUpsertWithWhereUniqueWithoutUser_Message_idUserSenderToUserInput[];
      createMany?: MessageCreateManyUser_Message_idUserSenderToUserInputEnvelope;
      set?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
      disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
      delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
      connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
      update?:
        | MessageUpdateWithWhereUniqueWithoutUser_Message_idUserSenderToUserInput
        | MessageUpdateWithWhereUniqueWithoutUser_Message_idUserSenderToUserInput[];
      updateMany?:
        | MessageUpdateManyWithWhereWithoutUser_Message_idUserSenderToUserInput
        | MessageUpdateManyWithWhereWithoutUser_Message_idUserSenderToUserInput[];
      deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[];
    };

  export type NoteUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput>
      | NoteCreateWithoutUserInput[]
      | NoteUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NoteCreateOrConnectWithoutUserInput
      | NoteCreateOrConnectWithoutUserInput[];
    upsert?:
      | NoteUpsertWithWhereUniqueWithoutUserInput
      | NoteUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NoteCreateManyUserInputEnvelope;
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
    update?:
      | NoteUpdateWithWhereUniqueWithoutUserInput
      | NoteUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NoteUpdateManyWithWhereWithoutUserInput
      | NoteUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[];
  };

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          NotificationCreateWithoutUserInput,
          NotificationUncheckedCreateWithoutUserInput
        >
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutUserInput
      | NotificationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutUserInput
      | NotificationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutUserInput
      | NotificationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type NotificationReceiverUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          NotificationReceiverCreateWithoutUserInput,
          NotificationReceiverUncheckedCreateWithoutUserInput
        >
      | NotificationReceiverCreateWithoutUserInput[]
      | NotificationReceiverUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationReceiverCreateOrConnectWithoutUserInput
      | NotificationReceiverCreateOrConnectWithoutUserInput[];
    upsert?:
      | NotificationReceiverUpsertWithWhereUniqueWithoutUserInput
      | NotificationReceiverUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationReceiverCreateManyUserInputEnvelope;
    set?:
      | NotificationReceiverWhereUniqueInput
      | NotificationReceiverWhereUniqueInput[];
    disconnect?:
      | NotificationReceiverWhereUniqueInput
      | NotificationReceiverWhereUniqueInput[];
    delete?:
      | NotificationReceiverWhereUniqueInput
      | NotificationReceiverWhereUniqueInput[];
    connect?:
      | NotificationReceiverWhereUniqueInput
      | NotificationReceiverWhereUniqueInput[];
    update?:
      | NotificationReceiverUpdateWithWhereUniqueWithoutUserInput
      | NotificationReceiverUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NotificationReceiverUpdateManyWithWhereWithoutUserInput
      | NotificationReceiverUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | NotificationReceiverScalarWhereInput
      | NotificationReceiverScalarWhereInput[];
  };

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          PaymentCreateWithoutUserInput,
          PaymentUncheckedCreateWithoutUserInput
        >
      | PaymentCreateWithoutUserInput[]
      | PaymentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PaymentCreateOrConnectWithoutUserInput
      | PaymentCreateOrConnectWithoutUserInput[];
    upsert?:
      | PaymentUpsertWithWhereUniqueWithoutUserInput
      | PaymentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: PaymentCreateManyUserInputEnvelope;
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    update?:
      | PaymentUpdateWithWhereUniqueWithoutUserInput
      | PaymentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | PaymentUpdateManyWithWhereWithoutUserInput
      | PaymentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
  };

  export type QuestionUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          QuestionCreateWithoutUserInput,
          QuestionUncheckedCreateWithoutUserInput
        >
      | QuestionCreateWithoutUserInput[]
      | QuestionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | QuestionCreateOrConnectWithoutUserInput
      | QuestionCreateOrConnectWithoutUserInput[];
    upsert?:
      | QuestionUpsertWithWhereUniqueWithoutUserInput
      | QuestionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: QuestionCreateManyUserInputEnvelope;
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
    update?:
      | QuestionUpdateWithWhereUniqueWithoutUserInput
      | QuestionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | QuestionUpdateManyWithWhereWithoutUserInput
      | QuestionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[];
  };

  export type ReportUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput>
      | ReportCreateWithoutUserInput[]
      | ReportUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ReportCreateOrConnectWithoutUserInput
      | ReportCreateOrConnectWithoutUserInput[];
    upsert?:
      | ReportUpsertWithWhereUniqueWithoutUserInput
      | ReportUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ReportCreateManyUserInputEnvelope;
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
    update?:
      | ReportUpdateWithWhereUniqueWithoutUserInput
      | ReportUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ReportUpdateManyWithWhereWithoutUserInput
      | ReportUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[];
  };

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
      | ReviewCreateWithoutUserInput[]
      | ReviewUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutUserInput
      | ReviewCreateOrConnectWithoutUserInput[];
    upsert?:
      | ReviewUpsertWithWhereUniqueWithoutUserInput
      | ReviewUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ReviewCreateManyUserInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?:
      | ReviewUpdateWithWhereUniqueWithoutUserInput
      | ReviewUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ReviewUpdateManyWithWhereWithoutUserInput
      | ReviewUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type StudyRemindUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          StudyRemindCreateWithoutUserInput,
          StudyRemindUncheckedCreateWithoutUserInput
        >
      | StudyRemindCreateWithoutUserInput[]
      | StudyRemindUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | StudyRemindCreateOrConnectWithoutUserInput
      | StudyRemindCreateOrConnectWithoutUserInput[];
    upsert?:
      | StudyRemindUpsertWithWhereUniqueWithoutUserInput
      | StudyRemindUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: StudyRemindCreateManyUserInputEnvelope;
    set?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
    disconnect?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
    delete?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
    connect?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
    update?:
      | StudyRemindUpdateWithWhereUniqueWithoutUserInput
      | StudyRemindUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | StudyRemindUpdateManyWithWhereWithoutUserInput
      | StudyRemindUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: StudyRemindScalarWhereInput | StudyRemindScalarWhereInput[];
  };

  export type UserCertificateUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          UserCertificateCreateWithoutUserInput,
          UserCertificateUncheckedCreateWithoutUserInput
        >
      | UserCertificateCreateWithoutUserInput[]
      | UserCertificateUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserCertificateCreateOrConnectWithoutUserInput
      | UserCertificateCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserCertificateUpsertWithWhereUniqueWithoutUserInput
      | UserCertificateUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserCertificateCreateManyUserInputEnvelope;
    set?: UserCertificateWhereUniqueInput | UserCertificateWhereUniqueInput[];
    disconnect?:
      | UserCertificateWhereUniqueInput
      | UserCertificateWhereUniqueInput[];
    delete?:
      | UserCertificateWhereUniqueInput
      | UserCertificateWhereUniqueInput[];
    connect?:
      | UserCertificateWhereUniqueInput
      | UserCertificateWhereUniqueInput[];
    update?:
      | UserCertificateUpdateWithWhereUniqueWithoutUserInput
      | UserCertificateUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserCertificateUpdateManyWithWhereWithoutUserInput
      | UserCertificateUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | UserCertificateScalarWhereInput
      | UserCertificateScalarWhereInput[];
  };

  export type UserCouponUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          UserCouponCreateWithoutUserInput,
          UserCouponUncheckedCreateWithoutUserInput
        >
      | UserCouponCreateWithoutUserInput[]
      | UserCouponUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserCouponCreateOrConnectWithoutUserInput
      | UserCouponCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserCouponUpsertWithWhereUniqueWithoutUserInput
      | UserCouponUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserCouponCreateManyUserInputEnvelope;
    set?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
    disconnect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
    delete?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
    update?:
      | UserCouponUpdateWithWhereUniqueWithoutUserInput
      | UserCouponUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserCouponUpdateManyWithWhereWithoutUserInput
      | UserCouponUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserCouponScalarWhereInput | UserCouponScalarWhereInput[];
  };

  export type WishlistUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          WishlistCreateWithoutUserInput,
          WishlistUncheckedCreateWithoutUserInput
        >
      | WishlistCreateWithoutUserInput[]
      | WishlistUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | WishlistCreateOrConnectWithoutUserInput
      | WishlistCreateOrConnectWithoutUserInput[];
    upsert?:
      | WishlistUpsertWithWhereUniqueWithoutUserInput
      | WishlistUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: WishlistCreateManyUserInputEnvelope;
    set?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
    disconnect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
    delete?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
    update?:
      | WishlistUpdateWithWhereUniqueWithoutUserInput
      | WishlistUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | WishlistUpdateManyWithWhereWithoutUserInput
      | WishlistUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: WishlistScalarWhereInput | WishlistScalarWhereInput[];
  };

  export type AnswerUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AnswerCreateWithoutUserInput, AnswerUncheckedCreateWithoutUserInput>
      | AnswerCreateWithoutUserInput[]
      | AnswerUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AnswerCreateOrConnectWithoutUserInput
      | AnswerCreateOrConnectWithoutUserInput[];
    upsert?:
      | AnswerUpsertWithWhereUniqueWithoutUserInput
      | AnswerUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AnswerCreateManyUserInputEnvelope;
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[];
    update?:
      | AnswerUpdateWithWhereUniqueWithoutUserInput
      | AnswerUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AnswerUpdateManyWithWhereWithoutUserInput
      | AnswerUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[];
  };

  export type CartUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
      | CartCreateWithoutUserInput[]
      | CartUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CartCreateOrConnectWithoutUserInput
      | CartCreateOrConnectWithoutUserInput[];
    upsert?:
      | CartUpsertWithWhereUniqueWithoutUserInput
      | CartUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: CartCreateManyUserInputEnvelope;
    set?: CartWhereUniqueInput | CartWhereUniqueInput[];
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[];
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[];
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[];
    update?:
      | CartUpdateWithWhereUniqueWithoutUserInput
      | CartUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | CartUpdateManyWithWhereWithoutUserInput
      | CartUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[];
  };

  export type CouponUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<CouponCreateWithoutUserInput, CouponUncheckedCreateWithoutUserInput>
      | CouponCreateWithoutUserInput[]
      | CouponUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CouponCreateOrConnectWithoutUserInput
      | CouponCreateOrConnectWithoutUserInput[];
    upsert?:
      | CouponUpsertWithWhereUniqueWithoutUserInput
      | CouponUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: CouponCreateManyUserInputEnvelope;
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[];
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[];
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[];
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[];
    update?:
      | CouponUpdateWithWhereUniqueWithoutUserInput
      | CouponUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | CouponUpdateManyWithWhereWithoutUserInput
      | CouponUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[];
  };

  export type CourseUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput>
      | CourseCreateWithoutUserInput[]
      | CourseUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CourseCreateOrConnectWithoutUserInput
      | CourseCreateOrConnectWithoutUserInput[];
    upsert?:
      | CourseUpsertWithWhereUniqueWithoutUserInput
      | CourseUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: CourseCreateManyUserInputEnvelope;
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[];
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[];
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[];
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[];
    update?:
      | CourseUpdateWithWhereUniqueWithoutUserInput
      | CourseUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | CourseUpdateManyWithWhereWithoutUserInput
      | CourseUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[];
  };

  export type EnrollmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          EnrollmentCreateWithoutUserInput,
          EnrollmentUncheckedCreateWithoutUserInput
        >
      | EnrollmentCreateWithoutUserInput[]
      | EnrollmentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | EnrollmentCreateOrConnectWithoutUserInput
      | EnrollmentCreateOrConnectWithoutUserInput[];
    upsert?:
      | EnrollmentUpsertWithWhereUniqueWithoutUserInput
      | EnrollmentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: EnrollmentCreateManyUserInputEnvelope;
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[];
    update?:
      | EnrollmentUpdateWithWhereUniqueWithoutUserInput
      | EnrollmentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | EnrollmentUpdateManyWithWhereWithoutUserInput
      | EnrollmentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[];
  };

  export type FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput =
    {
      create?:
        | XOR<
            FollowCreateWithoutUser_Follow_idFollowerToUserInput,
            FollowUncheckedCreateWithoutUser_Follow_idFollowerToUserInput
          >
        | FollowCreateWithoutUser_Follow_idFollowerToUserInput[]
        | FollowUncheckedCreateWithoutUser_Follow_idFollowerToUserInput[];
      connectOrCreate?:
        | FollowCreateOrConnectWithoutUser_Follow_idFollowerToUserInput
        | FollowCreateOrConnectWithoutUser_Follow_idFollowerToUserInput[];
      upsert?:
        | FollowUpsertWithWhereUniqueWithoutUser_Follow_idFollowerToUserInput
        | FollowUpsertWithWhereUniqueWithoutUser_Follow_idFollowerToUserInput[];
      createMany?: FollowCreateManyUser_Follow_idFollowerToUserInputEnvelope;
      set?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
      disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
      delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
      connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
      update?:
        | FollowUpdateWithWhereUniqueWithoutUser_Follow_idFollowerToUserInput
        | FollowUpdateWithWhereUniqueWithoutUser_Follow_idFollowerToUserInput[];
      updateMany?:
        | FollowUpdateManyWithWhereWithoutUser_Follow_idFollowerToUserInput
        | FollowUpdateManyWithWhereWithoutUser_Follow_idFollowerToUserInput[];
      deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[];
    };

  export type FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput =
    {
      create?:
        | XOR<
            FollowCreateWithoutUser_Follow_idFollowingToUserInput,
            FollowUncheckedCreateWithoutUser_Follow_idFollowingToUserInput
          >
        | FollowCreateWithoutUser_Follow_idFollowingToUserInput[]
        | FollowUncheckedCreateWithoutUser_Follow_idFollowingToUserInput[];
      connectOrCreate?:
        | FollowCreateOrConnectWithoutUser_Follow_idFollowingToUserInput
        | FollowCreateOrConnectWithoutUser_Follow_idFollowingToUserInput[];
      upsert?:
        | FollowUpsertWithWhereUniqueWithoutUser_Follow_idFollowingToUserInput
        | FollowUpsertWithWhereUniqueWithoutUser_Follow_idFollowingToUserInput[];
      createMany?: FollowCreateManyUser_Follow_idFollowingToUserInputEnvelope;
      set?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
      disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
      delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
      connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[];
      update?:
        | FollowUpdateWithWhereUniqueWithoutUser_Follow_idFollowingToUserInput
        | FollowUpdateWithWhereUniqueWithoutUser_Follow_idFollowingToUserInput[];
      updateMany?:
        | FollowUpdateManyWithWhereWithoutUser_Follow_idFollowingToUserInput
        | FollowUpdateManyWithWhereWithoutUser_Follow_idFollowingToUserInput[];
      deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[];
    };

  export type MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput =
    {
      create?:
        | XOR<
            MessageCreateWithoutUser_Message_idUserReceiverToUserInput,
            MessageUncheckedCreateWithoutUser_Message_idUserReceiverToUserInput
          >
        | MessageCreateWithoutUser_Message_idUserReceiverToUserInput[]
        | MessageUncheckedCreateWithoutUser_Message_idUserReceiverToUserInput[];
      connectOrCreate?:
        | MessageCreateOrConnectWithoutUser_Message_idUserReceiverToUserInput
        | MessageCreateOrConnectWithoutUser_Message_idUserReceiverToUserInput[];
      upsert?:
        | MessageUpsertWithWhereUniqueWithoutUser_Message_idUserReceiverToUserInput
        | MessageUpsertWithWhereUniqueWithoutUser_Message_idUserReceiverToUserInput[];
      createMany?: MessageCreateManyUser_Message_idUserReceiverToUserInputEnvelope;
      set?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
      disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
      delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
      connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
      update?:
        | MessageUpdateWithWhereUniqueWithoutUser_Message_idUserReceiverToUserInput
        | MessageUpdateWithWhereUniqueWithoutUser_Message_idUserReceiverToUserInput[];
      updateMany?:
        | MessageUpdateManyWithWhereWithoutUser_Message_idUserReceiverToUserInput
        | MessageUpdateManyWithWhereWithoutUser_Message_idUserReceiverToUserInput[];
      deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[];
    };

  export type MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput =
    {
      create?:
        | XOR<
            MessageCreateWithoutUser_Message_idUserSenderToUserInput,
            MessageUncheckedCreateWithoutUser_Message_idUserSenderToUserInput
          >
        | MessageCreateWithoutUser_Message_idUserSenderToUserInput[]
        | MessageUncheckedCreateWithoutUser_Message_idUserSenderToUserInput[];
      connectOrCreate?:
        | MessageCreateOrConnectWithoutUser_Message_idUserSenderToUserInput
        | MessageCreateOrConnectWithoutUser_Message_idUserSenderToUserInput[];
      upsert?:
        | MessageUpsertWithWhereUniqueWithoutUser_Message_idUserSenderToUserInput
        | MessageUpsertWithWhereUniqueWithoutUser_Message_idUserSenderToUserInput[];
      createMany?: MessageCreateManyUser_Message_idUserSenderToUserInputEnvelope;
      set?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
      disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
      delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
      connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
      update?:
        | MessageUpdateWithWhereUniqueWithoutUser_Message_idUserSenderToUserInput
        | MessageUpdateWithWhereUniqueWithoutUser_Message_idUserSenderToUserInput[];
      updateMany?:
        | MessageUpdateManyWithWhereWithoutUser_Message_idUserSenderToUserInput
        | MessageUpdateManyWithWhereWithoutUser_Message_idUserSenderToUserInput[];
      deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[];
    };

  export type NoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput>
      | NoteCreateWithoutUserInput[]
      | NoteUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NoteCreateOrConnectWithoutUserInput
      | NoteCreateOrConnectWithoutUserInput[];
    upsert?:
      | NoteUpsertWithWhereUniqueWithoutUserInput
      | NoteUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NoteCreateManyUserInputEnvelope;
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[];
    update?:
      | NoteUpdateWithWhereUniqueWithoutUserInput
      | NoteUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NoteUpdateManyWithWhereWithoutUserInput
      | NoteUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[];
  };

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          NotificationCreateWithoutUserInput,
          NotificationUncheckedCreateWithoutUserInput
        >
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutUserInput
      | NotificationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutUserInput
      | NotificationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutUserInput
      | NotificationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          NotificationReceiverCreateWithoutUserInput,
          NotificationReceiverUncheckedCreateWithoutUserInput
        >
      | NotificationReceiverCreateWithoutUserInput[]
      | NotificationReceiverUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationReceiverCreateOrConnectWithoutUserInput
      | NotificationReceiverCreateOrConnectWithoutUserInput[];
    upsert?:
      | NotificationReceiverUpsertWithWhereUniqueWithoutUserInput
      | NotificationReceiverUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationReceiverCreateManyUserInputEnvelope;
    set?:
      | NotificationReceiverWhereUniqueInput
      | NotificationReceiverWhereUniqueInput[];
    disconnect?:
      | NotificationReceiverWhereUniqueInput
      | NotificationReceiverWhereUniqueInput[];
    delete?:
      | NotificationReceiverWhereUniqueInput
      | NotificationReceiverWhereUniqueInput[];
    connect?:
      | NotificationReceiverWhereUniqueInput
      | NotificationReceiverWhereUniqueInput[];
    update?:
      | NotificationReceiverUpdateWithWhereUniqueWithoutUserInput
      | NotificationReceiverUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NotificationReceiverUpdateManyWithWhereWithoutUserInput
      | NotificationReceiverUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | NotificationReceiverScalarWhereInput
      | NotificationReceiverScalarWhereInput[];
  };

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          PaymentCreateWithoutUserInput,
          PaymentUncheckedCreateWithoutUserInput
        >
      | PaymentCreateWithoutUserInput[]
      | PaymentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PaymentCreateOrConnectWithoutUserInput
      | PaymentCreateOrConnectWithoutUserInput[];
    upsert?:
      | PaymentUpsertWithWhereUniqueWithoutUserInput
      | PaymentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: PaymentCreateManyUserInputEnvelope;
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    update?:
      | PaymentUpdateWithWhereUniqueWithoutUserInput
      | PaymentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | PaymentUpdateManyWithWhereWithoutUserInput
      | PaymentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
  };

  export type QuestionUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          QuestionCreateWithoutUserInput,
          QuestionUncheckedCreateWithoutUserInput
        >
      | QuestionCreateWithoutUserInput[]
      | QuestionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | QuestionCreateOrConnectWithoutUserInput
      | QuestionCreateOrConnectWithoutUserInput[];
    upsert?:
      | QuestionUpsertWithWhereUniqueWithoutUserInput
      | QuestionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: QuestionCreateManyUserInputEnvelope;
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[];
    update?:
      | QuestionUpdateWithWhereUniqueWithoutUserInput
      | QuestionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | QuestionUpdateManyWithWhereWithoutUserInput
      | QuestionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[];
  };

  export type ReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput>
      | ReportCreateWithoutUserInput[]
      | ReportUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ReportCreateOrConnectWithoutUserInput
      | ReportCreateOrConnectWithoutUserInput[];
    upsert?:
      | ReportUpsertWithWhereUniqueWithoutUserInput
      | ReportUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ReportCreateManyUserInputEnvelope;
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
    update?:
      | ReportUpdateWithWhereUniqueWithoutUserInput
      | ReportUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ReportUpdateManyWithWhereWithoutUserInput
      | ReportUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[];
  };

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
      | ReviewCreateWithoutUserInput[]
      | ReviewUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutUserInput
      | ReviewCreateOrConnectWithoutUserInput[];
    upsert?:
      | ReviewUpsertWithWhereUniqueWithoutUserInput
      | ReviewUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ReviewCreateManyUserInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?:
      | ReviewUpdateWithWhereUniqueWithoutUserInput
      | ReviewUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ReviewUpdateManyWithWhereWithoutUserInput
      | ReviewUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type StudyRemindUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          StudyRemindCreateWithoutUserInput,
          StudyRemindUncheckedCreateWithoutUserInput
        >
      | StudyRemindCreateWithoutUserInput[]
      | StudyRemindUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | StudyRemindCreateOrConnectWithoutUserInput
      | StudyRemindCreateOrConnectWithoutUserInput[];
    upsert?:
      | StudyRemindUpsertWithWhereUniqueWithoutUserInput
      | StudyRemindUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: StudyRemindCreateManyUserInputEnvelope;
    set?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
    disconnect?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
    delete?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
    connect?: StudyRemindWhereUniqueInput | StudyRemindWhereUniqueInput[];
    update?:
      | StudyRemindUpdateWithWhereUniqueWithoutUserInput
      | StudyRemindUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | StudyRemindUpdateManyWithWhereWithoutUserInput
      | StudyRemindUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: StudyRemindScalarWhereInput | StudyRemindScalarWhereInput[];
  };

  export type UserCertificateUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          UserCertificateCreateWithoutUserInput,
          UserCertificateUncheckedCreateWithoutUserInput
        >
      | UserCertificateCreateWithoutUserInput[]
      | UserCertificateUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserCertificateCreateOrConnectWithoutUserInput
      | UserCertificateCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserCertificateUpsertWithWhereUniqueWithoutUserInput
      | UserCertificateUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserCertificateCreateManyUserInputEnvelope;
    set?: UserCertificateWhereUniqueInput | UserCertificateWhereUniqueInput[];
    disconnect?:
      | UserCertificateWhereUniqueInput
      | UserCertificateWhereUniqueInput[];
    delete?:
      | UserCertificateWhereUniqueInput
      | UserCertificateWhereUniqueInput[];
    connect?:
      | UserCertificateWhereUniqueInput
      | UserCertificateWhereUniqueInput[];
    update?:
      | UserCertificateUpdateWithWhereUniqueWithoutUserInput
      | UserCertificateUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserCertificateUpdateManyWithWhereWithoutUserInput
      | UserCertificateUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | UserCertificateScalarWhereInput
      | UserCertificateScalarWhereInput[];
  };

  export type UserCouponUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          UserCouponCreateWithoutUserInput,
          UserCouponUncheckedCreateWithoutUserInput
        >
      | UserCouponCreateWithoutUserInput[]
      | UserCouponUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserCouponCreateOrConnectWithoutUserInput
      | UserCouponCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserCouponUpsertWithWhereUniqueWithoutUserInput
      | UserCouponUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserCouponCreateManyUserInputEnvelope;
    set?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
    disconnect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
    delete?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[];
    update?:
      | UserCouponUpdateWithWhereUniqueWithoutUserInput
      | UserCouponUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserCouponUpdateManyWithWhereWithoutUserInput
      | UserCouponUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserCouponScalarWhereInput | UserCouponScalarWhereInput[];
  };

  export type WishlistUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          WishlistCreateWithoutUserInput,
          WishlistUncheckedCreateWithoutUserInput
        >
      | WishlistCreateWithoutUserInput[]
      | WishlistUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | WishlistCreateOrConnectWithoutUserInput
      | WishlistCreateOrConnectWithoutUserInput[];
    upsert?:
      | WishlistUpsertWithWhereUniqueWithoutUserInput
      | WishlistUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: WishlistCreateManyUserInputEnvelope;
    set?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
    disconnect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
    delete?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[];
    update?:
      | WishlistUpdateWithWhereUniqueWithoutUserInput
      | WishlistUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | WishlistUpdateManyWithWhereWithoutUserInput
      | WishlistUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: WishlistScalarWhereInput | WishlistScalarWhereInput[];
  };

  export type CertificateCreateNestedOneWithoutUserCertificateInput = {
    create?: XOR<
      CertificateCreateWithoutUserCertificateInput,
      CertificateUncheckedCreateWithoutUserCertificateInput
    >;
    connectOrCreate?: CertificateCreateOrConnectWithoutUserCertificateInput;
    connect?: CertificateWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutUserCertificateInput = {
    create?: XOR<
      UserCreateWithoutUserCertificateInput,
      UserUncheckedCreateWithoutUserCertificateInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutUserCertificateInput;
    connect?: UserWhereUniqueInput;
  };

  export type CertificateUpdateOneRequiredWithoutUserCertificateNestedInput = {
    create?: XOR<
      CertificateCreateWithoutUserCertificateInput,
      CertificateUncheckedCreateWithoutUserCertificateInput
    >;
    connectOrCreate?: CertificateCreateOrConnectWithoutUserCertificateInput;
    upsert?: CertificateUpsertWithoutUserCertificateInput;
    connect?: CertificateWhereUniqueInput;
    update?: XOR<
      XOR<
        CertificateUpdateToOneWithWhereWithoutUserCertificateInput,
        CertificateUpdateWithoutUserCertificateInput
      >,
      CertificateUncheckedUpdateWithoutUserCertificateInput
    >;
  };

  export type UserUpdateOneRequiredWithoutUserCertificateNestedInput = {
    create?: XOR<
      UserCreateWithoutUserCertificateInput,
      UserUncheckedCreateWithoutUserCertificateInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutUserCertificateInput;
    upsert?: UserUpsertWithoutUserCertificateInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutUserCertificateInput,
        UserUpdateWithoutUserCertificateInput
      >,
      UserUncheckedUpdateWithoutUserCertificateInput
    >;
  };

  export type CouponCreateNestedOneWithoutUserCouponInput = {
    create?: XOR<
      CouponCreateWithoutUserCouponInput,
      CouponUncheckedCreateWithoutUserCouponInput
    >;
    connectOrCreate?: CouponCreateOrConnectWithoutUserCouponInput;
    connect?: CouponWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutUserCouponInput = {
    create?: XOR<
      UserCreateWithoutUserCouponInput,
      UserUncheckedCreateWithoutUserCouponInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutUserCouponInput;
    connect?: UserWhereUniqueInput;
  };

  export type CouponUpdateOneRequiredWithoutUserCouponNestedInput = {
    create?: XOR<
      CouponCreateWithoutUserCouponInput,
      CouponUncheckedCreateWithoutUserCouponInput
    >;
    connectOrCreate?: CouponCreateOrConnectWithoutUserCouponInput;
    upsert?: CouponUpsertWithoutUserCouponInput;
    connect?: CouponWhereUniqueInput;
    update?: XOR<
      XOR<
        CouponUpdateToOneWithWhereWithoutUserCouponInput,
        CouponUpdateWithoutUserCouponInput
      >,
      CouponUncheckedUpdateWithoutUserCouponInput
    >;
  };

  export type UserUpdateOneRequiredWithoutUserCouponNestedInput = {
    create?: XOR<
      UserCreateWithoutUserCouponInput,
      UserUncheckedCreateWithoutUserCouponInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutUserCouponInput;
    upsert?: UserUpsertWithoutUserCouponInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutUserCouponInput,
        UserUpdateWithoutUserCouponInput
      >,
      UserUncheckedUpdateWithoutUserCouponInput
    >;
  };

  export type CourseCreateNestedOneWithoutWishlistInput = {
    create?: XOR<
      CourseCreateWithoutWishlistInput,
      CourseUncheckedCreateWithoutWishlistInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutWishlistInput;
    connect?: CourseWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutWishlistInput = {
    create?: XOR<
      UserCreateWithoutWishlistInput,
      UserUncheckedCreateWithoutWishlistInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutWishlistInput;
    connect?: UserWhereUniqueInput;
  };

  export type CourseUpdateOneRequiredWithoutWishlistNestedInput = {
    create?: XOR<
      CourseCreateWithoutWishlistInput,
      CourseUncheckedCreateWithoutWishlistInput
    >;
    connectOrCreate?: CourseCreateOrConnectWithoutWishlistInput;
    upsert?: CourseUpsertWithoutWishlistInput;
    connect?: CourseWhereUniqueInput;
    update?: XOR<
      XOR<
        CourseUpdateToOneWithWhereWithoutWishlistInput,
        CourseUpdateWithoutWishlistInput
      >,
      CourseUncheckedUpdateWithoutWishlistInput
    >;
  };

  export type UserUpdateOneRequiredWithoutWishlistNestedInput = {
    create?: XOR<
      UserCreateWithoutWishlistInput,
      UserUncheckedCreateWithoutWishlistInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutWishlistInput;
    upsert?: UserUpsertWithoutWishlistInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutWishlistInput,
        UserUpdateWithoutWishlistInput
      >,
      UserUncheckedUpdateWithoutWishlistInput
    >;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | null;
    notIn?: string[] | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | null;
    notIn?: string[] | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
      | null;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null;
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | null;
    notIn?: Date[] | string[] | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>
        | null;
      in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null;
      notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null;
      lt?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>;
      lte?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>;
      gt?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>;
      gte?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>;
      not?:
        | NestedDecimalNullableWithAggregatesFilter<$PrismaModel>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _avg?: NestedDecimalNullableFilter<$PrismaModel>;
      _sum?: NestedDecimalNullableFilter<$PrismaModel>;
      _min?: NestedDecimalNullableFilter<$PrismaModel>;
      _max?: NestedDecimalNullableFilter<$PrismaModel>;
    };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | null;
      notIn?: Date[] | string[] | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    };

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null;
  };

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedBoolNullableFilter<$PrismaModel>;
    _max?: NestedBoolNullableFilter<$PrismaModel>;
  };

  export type QuestionCreateWithoutAnswerInput = {
    contentQuestion?: string | null;
    Lecture?: LectureCreateNestedOneWithoutQuestionInput;
    User?: UserCreateNestedOneWithoutQuestionInput;
  };

  export type QuestionUncheckedCreateWithoutAnswerInput = {
    idQuestion?: number;
    idUser?: number | null;
    idCourse?: number | null;
    idSection?: number | null;
    idLecture?: number | null;
    contentQuestion?: string | null;
  };

  export type QuestionCreateOrConnectWithoutAnswerInput = {
    where: QuestionWhereUniqueInput;
    create: XOR<
      QuestionCreateWithoutAnswerInput,
      QuestionUncheckedCreateWithoutAnswerInput
    >;
  };

  export type UserCreateWithoutAnswerInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutAnswerInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
    Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
    Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutAnswerInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAnswerInput,
      UserUncheckedCreateWithoutAnswerInput
    >;
  };

  export type QuestionUpsertWithoutAnswerInput = {
    update: XOR<
      QuestionUpdateWithoutAnswerInput,
      QuestionUncheckedUpdateWithoutAnswerInput
    >;
    create: XOR<
      QuestionCreateWithoutAnswerInput,
      QuestionUncheckedCreateWithoutAnswerInput
    >;
    where?: QuestionWhereInput;
  };

  export type QuestionUpdateToOneWithWhereWithoutAnswerInput = {
    where?: QuestionWhereInput;
    data: XOR<
      QuestionUpdateWithoutAnswerInput,
      QuestionUncheckedUpdateWithoutAnswerInput
    >;
  };

  export type QuestionUpdateWithoutAnswerInput = {
    contentQuestion?: NullableStringFieldUpdateOperationsInput | string | null;
    Lecture?: LectureUpdateOneWithoutQuestionNestedInput;
    User?: UserUpdateOneWithoutQuestionNestedInput;
  };

  export type QuestionUncheckedUpdateWithoutAnswerInput = {
    idQuestion?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    idCourse?: NullableIntFieldUpdateOperationsInput | number | null;
    idSection?: NullableIntFieldUpdateOperationsInput | number | null;
    idLecture?: NullableIntFieldUpdateOperationsInput | number | null;
    contentQuestion?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UserUpsertWithoutAnswerInput = {
    update: XOR<
      UserUpdateWithoutAnswerInput,
      UserUncheckedUpdateWithoutAnswerInput
    >;
    create: XOR<
      UserCreateWithoutAnswerInput,
      UserUncheckedCreateWithoutAnswerInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAnswerInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutAnswerInput,
      UserUncheckedUpdateWithoutAnswerInput
    >;
  };

  export type UserUpdateWithoutAnswerInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAnswerInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
    Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type CourseCreateWithoutCartInput = {
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Certificate?: CertificateCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseCreateNestedManyWithoutCourseInput;
    User?: UserCreateNestedOneWithoutCourseInput;
    CourseCategory?: CourseCategoryCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailCreateNestedManyWithoutCourseInput;
    Review?: ReviewCreateNestedManyWithoutCourseInput;
    Section?: SectionCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistCreateNestedManyWithoutCourseInput;
  };

  export type CourseUncheckedCreateWithoutCartInput = {
    idCourse?: number;
    idUser?: number | null;
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Certificate?: CertificateUncheckedCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseUncheckedCreateNestedManyWithoutCourseInput;
    CourseCategory?: CourseCategoryUncheckedCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailUncheckedCreateNestedManyWithoutCourseInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutCourseInput;
    Section?: SectionUncheckedCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutCourseInput;
  };

  export type CourseCreateOrConnectWithoutCartInput = {
    where: CourseWhereUniqueInput;
    create: XOR<
      CourseCreateWithoutCartInput,
      CourseUncheckedCreateWithoutCartInput
    >;
  };

  export type UserCreateWithoutCartInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutCartInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
    Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
    Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutCartInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutCartInput,
      UserUncheckedCreateWithoutCartInput
    >;
  };

  export type CourseUpsertWithoutCartInput = {
    update: XOR<
      CourseUpdateWithoutCartInput,
      CourseUncheckedUpdateWithoutCartInput
    >;
    create: XOR<
      CourseCreateWithoutCartInput,
      CourseUncheckedCreateWithoutCartInput
    >;
    where?: CourseWhereInput;
  };

  export type CourseUpdateToOneWithWhereWithoutCartInput = {
    where?: CourseWhereInput;
    data: XOR<
      CourseUpdateWithoutCartInput,
      CourseUncheckedUpdateWithoutCartInput
    >;
  };

  export type CourseUpdateWithoutCartInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Certificate?: CertificateUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUpdateManyWithoutCourseNestedInput;
    User?: UserUpdateOneWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUpdateManyWithoutCourseNestedInput;
    Section?: SectionUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUpdateManyWithoutCourseNestedInput;
  };

  export type CourseUncheckedUpdateWithoutCartInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Certificate?: CertificateUncheckedUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUncheckedUpdateManyWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUncheckedUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutCourseNestedInput;
    Section?: SectionUncheckedUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutCourseNestedInput;
  };

  export type UserUpsertWithoutCartInput = {
    update: XOR<
      UserUpdateWithoutCartInput,
      UserUncheckedUpdateWithoutCartInput
    >;
    create: XOR<
      UserCreateWithoutCartInput,
      UserUncheckedCreateWithoutCartInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutCartInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutCartInput, UserUncheckedUpdateWithoutCartInput>;
  };

  export type UserUpdateWithoutCartInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutCartInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
    Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type CourseCategoryCreateWithoutCategoryInput = {
    Course: CourseCreateNestedOneWithoutCourseCategoryInput;
  };

  export type CourseCategoryUncheckedCreateWithoutCategoryInput = {
    idCourse: number;
  };

  export type CourseCategoryCreateOrConnectWithoutCategoryInput = {
    where: CourseCategoryWhereUniqueInput;
    create: XOR<
      CourseCategoryCreateWithoutCategoryInput,
      CourseCategoryUncheckedCreateWithoutCategoryInput
    >;
  };

  export type CourseCategoryCreateManyCategoryInputEnvelope = {
    data:
      | CourseCategoryCreateManyCategoryInput
      | CourseCategoryCreateManyCategoryInput[];
    skipDuplicates?: boolean;
  };

  export type CourseCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: CourseCategoryWhereUniqueInput;
    update: XOR<
      CourseCategoryUpdateWithoutCategoryInput,
      CourseCategoryUncheckedUpdateWithoutCategoryInput
    >;
    create: XOR<
      CourseCategoryCreateWithoutCategoryInput,
      CourseCategoryUncheckedCreateWithoutCategoryInput
    >;
  };

  export type CourseCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: CourseCategoryWhereUniqueInput;
    data: XOR<
      CourseCategoryUpdateWithoutCategoryInput,
      CourseCategoryUncheckedUpdateWithoutCategoryInput
    >;
  };

  export type CourseCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: CourseCategoryScalarWhereInput;
    data: XOR<
      CourseCategoryUpdateManyMutationInput,
      CourseCategoryUncheckedUpdateManyWithoutCategoryInput
    >;
  };

  export type CourseCategoryScalarWhereInput = {
    AND?: CourseCategoryScalarWhereInput | CourseCategoryScalarWhereInput[];
    OR?: CourseCategoryScalarWhereInput[];
    NOT?: CourseCategoryScalarWhereInput | CourseCategoryScalarWhereInput[];
    idCourse?: IntFilter<'CourseCategory'> | number;
    idCategory?: IntFilter<'CourseCategory'> | number;
  };

  export type CourseCreateWithoutCertificateInput = {
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartCreateNestedManyWithoutCourseInput;
    CouponCourse?: CouponCourseCreateNestedManyWithoutCourseInput;
    User?: UserCreateNestedOneWithoutCourseInput;
    CourseCategory?: CourseCategoryCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailCreateNestedManyWithoutCourseInput;
    Review?: ReviewCreateNestedManyWithoutCourseInput;
    Section?: SectionCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistCreateNestedManyWithoutCourseInput;
  };

  export type CourseUncheckedCreateWithoutCertificateInput = {
    idCourse?: number;
    idUser?: number | null;
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartUncheckedCreateNestedManyWithoutCourseInput;
    CouponCourse?: CouponCourseUncheckedCreateNestedManyWithoutCourseInput;
    CourseCategory?: CourseCategoryUncheckedCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailUncheckedCreateNestedManyWithoutCourseInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutCourseInput;
    Section?: SectionUncheckedCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutCourseInput;
  };

  export type CourseCreateOrConnectWithoutCertificateInput = {
    where: CourseWhereUniqueInput;
    create: XOR<
      CourseCreateWithoutCertificateInput,
      CourseUncheckedCreateWithoutCertificateInput
    >;
  };

  export type UserCertificateCreateWithoutCertificateInput = {
    User: UserCreateNestedOneWithoutUserCertificateInput;
  };

  export type UserCertificateUncheckedCreateWithoutCertificateInput = {
    idUser: number;
  };

  export type UserCertificateCreateOrConnectWithoutCertificateInput = {
    where: UserCertificateWhereUniqueInput;
    create: XOR<
      UserCertificateCreateWithoutCertificateInput,
      UserCertificateUncheckedCreateWithoutCertificateInput
    >;
  };

  export type UserCertificateCreateManyCertificateInputEnvelope = {
    data:
      | UserCertificateCreateManyCertificateInput
      | UserCertificateCreateManyCertificateInput[];
    skipDuplicates?: boolean;
  };

  export type CourseUpsertWithoutCertificateInput = {
    update: XOR<
      CourseUpdateWithoutCertificateInput,
      CourseUncheckedUpdateWithoutCertificateInput
    >;
    create: XOR<
      CourseCreateWithoutCertificateInput,
      CourseUncheckedCreateWithoutCertificateInput
    >;
    where?: CourseWhereInput;
  };

  export type CourseUpdateToOneWithWhereWithoutCertificateInput = {
    where?: CourseWhereInput;
    data: XOR<
      CourseUpdateWithoutCertificateInput,
      CourseUncheckedUpdateWithoutCertificateInput
    >;
  };

  export type CourseUpdateWithoutCertificateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUpdateManyWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUpdateManyWithoutCourseNestedInput;
    User?: UserUpdateOneWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUpdateManyWithoutCourseNestedInput;
    Section?: SectionUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUpdateManyWithoutCourseNestedInput;
  };

  export type CourseUncheckedUpdateWithoutCertificateInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUncheckedUpdateManyWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUncheckedUpdateManyWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUncheckedUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutCourseNestedInput;
    Section?: SectionUncheckedUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutCourseNestedInput;
  };

  export type UserCertificateUpsertWithWhereUniqueWithoutCertificateInput = {
    where: UserCertificateWhereUniqueInput;
    update: XOR<
      UserCertificateUpdateWithoutCertificateInput,
      UserCertificateUncheckedUpdateWithoutCertificateInput
    >;
    create: XOR<
      UserCertificateCreateWithoutCertificateInput,
      UserCertificateUncheckedCreateWithoutCertificateInput
    >;
  };

  export type UserCertificateUpdateWithWhereUniqueWithoutCertificateInput = {
    where: UserCertificateWhereUniqueInput;
    data: XOR<
      UserCertificateUpdateWithoutCertificateInput,
      UserCertificateUncheckedUpdateWithoutCertificateInput
    >;
  };

  export type UserCertificateUpdateManyWithWhereWithoutCertificateInput = {
    where: UserCertificateScalarWhereInput;
    data: XOR<
      UserCertificateUpdateManyMutationInput,
      UserCertificateUncheckedUpdateManyWithoutCertificateInput
    >;
  };

  export type UserCertificateScalarWhereInput = {
    AND?: UserCertificateScalarWhereInput | UserCertificateScalarWhereInput[];
    OR?: UserCertificateScalarWhereInput[];
    NOT?: UserCertificateScalarWhereInput | UserCertificateScalarWhereInput[];
    idCourse?: IntFilter<'UserCertificate'> | number;
    idUser?: IntFilter<'UserCertificate'> | number;
  };

  export type UserCreateWithoutCouponInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutCouponInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
    Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutCouponInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutCouponInput,
      UserUncheckedCreateWithoutCouponInput
    >;
  };

  export type CouponCourseCreateWithoutCouponInput = {
    Course: CourseCreateNestedOneWithoutCouponCourseInput;
  };

  export type CouponCourseUncheckedCreateWithoutCouponInput = {
    idCourse: number;
  };

  export type CouponCourseCreateOrConnectWithoutCouponInput = {
    where: CouponCourseWhereUniqueInput;
    create: XOR<
      CouponCourseCreateWithoutCouponInput,
      CouponCourseUncheckedCreateWithoutCouponInput
    >;
  };

  export type CouponCourseCreateManyCouponInputEnvelope = {
    data:
      | CouponCourseCreateManyCouponInput
      | CouponCourseCreateManyCouponInput[];
    skipDuplicates?: boolean;
  };

  export type UserCouponCreateWithoutCouponInput = {
    User: UserCreateNestedOneWithoutUserCouponInput;
  };

  export type UserCouponUncheckedCreateWithoutCouponInput = {
    idUser: number;
  };

  export type UserCouponCreateOrConnectWithoutCouponInput = {
    where: UserCouponWhereUniqueInput;
    create: XOR<
      UserCouponCreateWithoutCouponInput,
      UserCouponUncheckedCreateWithoutCouponInput
    >;
  };

  export type UserCouponCreateManyCouponInputEnvelope = {
    data: UserCouponCreateManyCouponInput | UserCouponCreateManyCouponInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutCouponInput = {
    update: XOR<
      UserUpdateWithoutCouponInput,
      UserUncheckedUpdateWithoutCouponInput
    >;
    create: XOR<
      UserCreateWithoutCouponInput,
      UserUncheckedCreateWithoutCouponInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutCouponInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutCouponInput,
      UserUncheckedUpdateWithoutCouponInput
    >;
  };

  export type UserUpdateWithoutCouponInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutCouponInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
    Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type CouponCourseUpsertWithWhereUniqueWithoutCouponInput = {
    where: CouponCourseWhereUniqueInput;
    update: XOR<
      CouponCourseUpdateWithoutCouponInput,
      CouponCourseUncheckedUpdateWithoutCouponInput
    >;
    create: XOR<
      CouponCourseCreateWithoutCouponInput,
      CouponCourseUncheckedCreateWithoutCouponInput
    >;
  };

  export type CouponCourseUpdateWithWhereUniqueWithoutCouponInput = {
    where: CouponCourseWhereUniqueInput;
    data: XOR<
      CouponCourseUpdateWithoutCouponInput,
      CouponCourseUncheckedUpdateWithoutCouponInput
    >;
  };

  export type CouponCourseUpdateManyWithWhereWithoutCouponInput = {
    where: CouponCourseScalarWhereInput;
    data: XOR<
      CouponCourseUpdateManyMutationInput,
      CouponCourseUncheckedUpdateManyWithoutCouponInput
    >;
  };

  export type CouponCourseScalarWhereInput = {
    AND?: CouponCourseScalarWhereInput | CouponCourseScalarWhereInput[];
    OR?: CouponCourseScalarWhereInput[];
    NOT?: CouponCourseScalarWhereInput | CouponCourseScalarWhereInput[];
    idCoupon?: IntFilter<'CouponCourse'> | number;
    idCourse?: IntFilter<'CouponCourse'> | number;
  };

  export type UserCouponUpsertWithWhereUniqueWithoutCouponInput = {
    where: UserCouponWhereUniqueInput;
    update: XOR<
      UserCouponUpdateWithoutCouponInput,
      UserCouponUncheckedUpdateWithoutCouponInput
    >;
    create: XOR<
      UserCouponCreateWithoutCouponInput,
      UserCouponUncheckedCreateWithoutCouponInput
    >;
  };

  export type UserCouponUpdateWithWhereUniqueWithoutCouponInput = {
    where: UserCouponWhereUniqueInput;
    data: XOR<
      UserCouponUpdateWithoutCouponInput,
      UserCouponUncheckedUpdateWithoutCouponInput
    >;
  };

  export type UserCouponUpdateManyWithWhereWithoutCouponInput = {
    where: UserCouponScalarWhereInput;
    data: XOR<
      UserCouponUpdateManyMutationInput,
      UserCouponUncheckedUpdateManyWithoutCouponInput
    >;
  };

  export type UserCouponScalarWhereInput = {
    AND?: UserCouponScalarWhereInput | UserCouponScalarWhereInput[];
    OR?: UserCouponScalarWhereInput[];
    NOT?: UserCouponScalarWhereInput | UserCouponScalarWhereInput[];
    idUser?: IntFilter<'UserCoupon'> | number;
    idCoupon?: IntFilter<'UserCoupon'> | number;
  };

  export type CouponCreateWithoutCouponCourseInput = {
    type?: string | null;
    value?: Decimal | DecimalJsLike | number | string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    quantity?: number | null;
    appliedAmount?: number | null;
    minRequire?: Decimal | DecimalJsLike | number | string | null;
    maxValueDiscount?: Decimal | DecimalJsLike | number | string | null;
    code?: string | null;
    User?: UserCreateNestedOneWithoutCouponInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutCouponInput;
  };

  export type CouponUncheckedCreateWithoutCouponCourseInput = {
    idCoupon?: number;
    type?: string | null;
    value?: Decimal | DecimalJsLike | number | string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    quantity?: number | null;
    appliedAmount?: number | null;
    minRequire?: Decimal | DecimalJsLike | number | string | null;
    maxValueDiscount?: Decimal | DecimalJsLike | number | string | null;
    code?: string | null;
    idUser?: number | null;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutCouponInput;
  };

  export type CouponCreateOrConnectWithoutCouponCourseInput = {
    where: CouponWhereUniqueInput;
    create: XOR<
      CouponCreateWithoutCouponCourseInput,
      CouponUncheckedCreateWithoutCouponCourseInput
    >;
  };

  export type CourseCreateWithoutCouponCourseInput = {
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateCreateNestedOneWithoutCourseInput;
    User?: UserCreateNestedOneWithoutCourseInput;
    CourseCategory?: CourseCategoryCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailCreateNestedManyWithoutCourseInput;
    Review?: ReviewCreateNestedManyWithoutCourseInput;
    Section?: SectionCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistCreateNestedManyWithoutCourseInput;
  };

  export type CourseUncheckedCreateWithoutCouponCourseInput = {
    idCourse?: number;
    idUser?: number | null;
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartUncheckedCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateUncheckedCreateNestedOneWithoutCourseInput;
    CourseCategory?: CourseCategoryUncheckedCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailUncheckedCreateNestedManyWithoutCourseInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutCourseInput;
    Section?: SectionUncheckedCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutCourseInput;
  };

  export type CourseCreateOrConnectWithoutCouponCourseInput = {
    where: CourseWhereUniqueInput;
    create: XOR<
      CourseCreateWithoutCouponCourseInput,
      CourseUncheckedCreateWithoutCouponCourseInput
    >;
  };

  export type CouponUpsertWithoutCouponCourseInput = {
    update: XOR<
      CouponUpdateWithoutCouponCourseInput,
      CouponUncheckedUpdateWithoutCouponCourseInput
    >;
    create: XOR<
      CouponCreateWithoutCouponCourseInput,
      CouponUncheckedCreateWithoutCouponCourseInput
    >;
    where?: CouponWhereInput;
  };

  export type CouponUpdateToOneWithWhereWithoutCouponCourseInput = {
    where?: CouponWhereInput;
    data: XOR<
      CouponUpdateWithoutCouponCourseInput,
      CouponUncheckedUpdateWithoutCouponCourseInput
    >;
  };

  export type CouponUpdateWithoutCouponCourseInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    quantity?: NullableIntFieldUpdateOperationsInput | number | null;
    appliedAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    minRequire?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxValueDiscount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    code?: NullableStringFieldUpdateOperationsInput | string | null;
    User?: UserUpdateOneWithoutCouponNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutCouponNestedInput;
  };

  export type CouponUncheckedUpdateWithoutCouponCourseInput = {
    idCoupon?: IntFieldUpdateOperationsInput | number;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    quantity?: NullableIntFieldUpdateOperationsInput | number | null;
    appliedAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    minRequire?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxValueDiscount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    code?: NullableStringFieldUpdateOperationsInput | string | null;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutCouponNestedInput;
  };

  export type CourseUpsertWithoutCouponCourseInput = {
    update: XOR<
      CourseUpdateWithoutCouponCourseInput,
      CourseUncheckedUpdateWithoutCouponCourseInput
    >;
    create: XOR<
      CourseCreateWithoutCouponCourseInput,
      CourseUncheckedCreateWithoutCouponCourseInput
    >;
    where?: CourseWhereInput;
  };

  export type CourseUpdateToOneWithWhereWithoutCouponCourseInput = {
    where?: CourseWhereInput;
    data: XOR<
      CourseUpdateWithoutCouponCourseInput,
      CourseUncheckedUpdateWithoutCouponCourseInput
    >;
  };

  export type CourseUpdateWithoutCouponCourseInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUpdateOneWithoutCourseNestedInput;
    User?: UserUpdateOneWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUpdateManyWithoutCourseNestedInput;
    Section?: SectionUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUpdateManyWithoutCourseNestedInput;
  };

  export type CourseUncheckedUpdateWithoutCouponCourseInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUncheckedUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUncheckedUpdateOneWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUncheckedUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutCourseNestedInput;
    Section?: SectionUncheckedUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutCourseNestedInput;
  };

  export type CartCreateWithoutCourseInput = {
    User: UserCreateNestedOneWithoutCartInput;
  };

  export type CartUncheckedCreateWithoutCourseInput = {
    idUser: number;
  };

  export type CartCreateOrConnectWithoutCourseInput = {
    where: CartWhereUniqueInput;
    create: XOR<
      CartCreateWithoutCourseInput,
      CartUncheckedCreateWithoutCourseInput
    >;
  };

  export type CartCreateManyCourseInputEnvelope = {
    data: CartCreateManyCourseInput | CartCreateManyCourseInput[];
    skipDuplicates?: boolean;
  };

  export type CertificateCreateWithoutCourseInput = {
    certificate?: string | null;
    UserCertificate?: UserCertificateCreateNestedManyWithoutCertificateInput;
  };

  export type CertificateUncheckedCreateWithoutCourseInput = {
    certificate?: string | null;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutCertificateInput;
  };

  export type CertificateCreateOrConnectWithoutCourseInput = {
    where: CertificateWhereUniqueInput;
    create: XOR<
      CertificateCreateWithoutCourseInput,
      CertificateUncheckedCreateWithoutCourseInput
    >;
  };

  export type CouponCourseCreateWithoutCourseInput = {
    Coupon: CouponCreateNestedOneWithoutCouponCourseInput;
  };

  export type CouponCourseUncheckedCreateWithoutCourseInput = {
    idCoupon: number;
  };

  export type CouponCourseCreateOrConnectWithoutCourseInput = {
    where: CouponCourseWhereUniqueInput;
    create: XOR<
      CouponCourseCreateWithoutCourseInput,
      CouponCourseUncheckedCreateWithoutCourseInput
    >;
  };

  export type CouponCourseCreateManyCourseInputEnvelope = {
    data:
      | CouponCourseCreateManyCourseInput
      | CouponCourseCreateManyCourseInput[];
    skipDuplicates?: boolean;
  };

  export type UserCreateWithoutCourseInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutCourseInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
    Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutCourseInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutCourseInput,
      UserUncheckedCreateWithoutCourseInput
    >;
  };

  export type CourseCategoryCreateWithoutCourseInput = {
    Category: CategoryCreateNestedOneWithoutCourseCategoryInput;
  };

  export type CourseCategoryUncheckedCreateWithoutCourseInput = {
    idCategory: number;
  };

  export type CourseCategoryCreateOrConnectWithoutCourseInput = {
    where: CourseCategoryWhereUniqueInput;
    create: XOR<
      CourseCategoryCreateWithoutCourseInput,
      CourseCategoryUncheckedCreateWithoutCourseInput
    >;
  };

  export type CourseCategoryCreateManyCourseInputEnvelope = {
    data:
      | CourseCategoryCreateManyCourseInput
      | CourseCategoryCreateManyCourseInput[];
    skipDuplicates?: boolean;
  };

  export type CourseObjectiveCreateWithoutCourseInput = {
    idCourseObjective: number;
    content?: string | null;
  };

  export type CourseObjectiveUncheckedCreateWithoutCourseInput = {
    idCourseObjective: number;
    content?: string | null;
  };

  export type CourseObjectiveCreateOrConnectWithoutCourseInput = {
    where: CourseObjectiveWhereUniqueInput;
    create: XOR<
      CourseObjectiveCreateWithoutCourseInput,
      CourseObjectiveUncheckedCreateWithoutCourseInput
    >;
  };

  export type CourseObjectiveCreateManyCourseInputEnvelope = {
    data:
      | CourseObjectiveCreateManyCourseInput
      | CourseObjectiveCreateManyCourseInput[];
    skipDuplicates?: boolean;
  };

  export type EnrollmentCreateWithoutCourseInput = {
    dateRegister?: Date | string | null;
    finishStatus?: boolean | null;
    progress?: Decimal | DecimalJsLike | number | string | null;
    User: UserCreateNestedOneWithoutEnrollmentInput;
  };

  export type EnrollmentUncheckedCreateWithoutCourseInput = {
    idUser: number;
    dateRegister?: Date | string | null;
    finishStatus?: boolean | null;
    progress?: Decimal | DecimalJsLike | number | string | null;
  };

  export type EnrollmentCreateOrConnectWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput;
    create: XOR<
      EnrollmentCreateWithoutCourseInput,
      EnrollmentUncheckedCreateWithoutCourseInput
    >;
  };

  export type EnrollmentCreateManyCourseInputEnvelope = {
    data: EnrollmentCreateManyCourseInput | EnrollmentCreateManyCourseInput[];
    skipDuplicates?: boolean;
  };

  export type PaymentDetailCreateWithoutCourseInput = {
    price?: Decimal | DecimalJsLike | number | string | null;
    Payment: PaymentCreateNestedOneWithoutPaymentDetailInput;
  };

  export type PaymentDetailUncheckedCreateWithoutCourseInput = {
    idPayment: number;
    price?: Decimal | DecimalJsLike | number | string | null;
  };

  export type PaymentDetailCreateOrConnectWithoutCourseInput = {
    where: PaymentDetailWhereUniqueInput;
    create: XOR<
      PaymentDetailCreateWithoutCourseInput,
      PaymentDetailUncheckedCreateWithoutCourseInput
    >;
  };

  export type PaymentDetailCreateManyCourseInputEnvelope = {
    data:
      | PaymentDetailCreateManyCourseInput
      | PaymentDetailCreateManyCourseInput[];
    skipDuplicates?: boolean;
  };

  export type ReviewCreateWithoutCourseInput = {
    rating?: number | null;
    review?: string | null;
    User?: UserCreateNestedOneWithoutReviewInput;
  };

  export type ReviewUncheckedCreateWithoutCourseInput = {
    idReview?: number;
    idUser?: number | null;
    rating?: number | null;
    review?: string | null;
  };

  export type ReviewCreateOrConnectWithoutCourseInput = {
    where: ReviewWhereUniqueInput;
    create: XOR<
      ReviewCreateWithoutCourseInput,
      ReviewUncheckedCreateWithoutCourseInput
    >;
  };

  export type ReviewCreateManyCourseInputEnvelope = {
    data: ReviewCreateManyCourseInput | ReviewCreateManyCourseInput[];
    skipDuplicates?: boolean;
  };

  export type SectionCreateWithoutCourseInput = {
    idSection: number;
    nameSection?: string | null;
    Lecture?: LectureCreateNestedManyWithoutSectionInput;
  };

  export type SectionUncheckedCreateWithoutCourseInput = {
    idSection: number;
    nameSection?: string | null;
    Lecture?: LectureUncheckedCreateNestedManyWithoutSectionInput;
  };

  export type SectionCreateOrConnectWithoutCourseInput = {
    where: SectionWhereUniqueInput;
    create: XOR<
      SectionCreateWithoutCourseInput,
      SectionUncheckedCreateWithoutCourseInput
    >;
  };

  export type SectionCreateManyCourseInputEnvelope = {
    data: SectionCreateManyCourseInput | SectionCreateManyCourseInput[];
    skipDuplicates?: boolean;
  };

  export type StudyRemindCreateWithoutCourseInput = {
    timeRemind?: Date | string | null;
    typeRemind?: string | null;
    User?: UserCreateNestedOneWithoutStudyRemindInput;
  };

  export type StudyRemindUncheckedCreateWithoutCourseInput = {
    idStudyRemind?: number;
    idUser?: number | null;
    timeRemind?: Date | string | null;
    typeRemind?: string | null;
  };

  export type StudyRemindCreateOrConnectWithoutCourseInput = {
    where: StudyRemindWhereUniqueInput;
    create: XOR<
      StudyRemindCreateWithoutCourseInput,
      StudyRemindUncheckedCreateWithoutCourseInput
    >;
  };

  export type StudyRemindCreateManyCourseInputEnvelope = {
    data: StudyRemindCreateManyCourseInput | StudyRemindCreateManyCourseInput[];
    skipDuplicates?: boolean;
  };

  export type WishlistCreateWithoutCourseInput = {
    User: UserCreateNestedOneWithoutWishlistInput;
  };

  export type WishlistUncheckedCreateWithoutCourseInput = {
    idUser: number;
  };

  export type WishlistCreateOrConnectWithoutCourseInput = {
    where: WishlistWhereUniqueInput;
    create: XOR<
      WishlistCreateWithoutCourseInput,
      WishlistUncheckedCreateWithoutCourseInput
    >;
  };

  export type WishlistCreateManyCourseInputEnvelope = {
    data: WishlistCreateManyCourseInput | WishlistCreateManyCourseInput[];
    skipDuplicates?: boolean;
  };

  export type CartUpsertWithWhereUniqueWithoutCourseInput = {
    where: CartWhereUniqueInput;
    update: XOR<
      CartUpdateWithoutCourseInput,
      CartUncheckedUpdateWithoutCourseInput
    >;
    create: XOR<
      CartCreateWithoutCourseInput,
      CartUncheckedCreateWithoutCourseInput
    >;
  };

  export type CartUpdateWithWhereUniqueWithoutCourseInput = {
    where: CartWhereUniqueInput;
    data: XOR<
      CartUpdateWithoutCourseInput,
      CartUncheckedUpdateWithoutCourseInput
    >;
  };

  export type CartUpdateManyWithWhereWithoutCourseInput = {
    where: CartScalarWhereInput;
    data: XOR<
      CartUpdateManyMutationInput,
      CartUncheckedUpdateManyWithoutCourseInput
    >;
  };

  export type CartScalarWhereInput = {
    AND?: CartScalarWhereInput | CartScalarWhereInput[];
    OR?: CartScalarWhereInput[];
    NOT?: CartScalarWhereInput | CartScalarWhereInput[];
    idUser?: IntFilter<'Cart'> | number;
    idCourse?: IntFilter<'Cart'> | number;
  };

  export type CertificateUpsertWithoutCourseInput = {
    update: XOR<
      CertificateUpdateWithoutCourseInput,
      CertificateUncheckedUpdateWithoutCourseInput
    >;
    create: XOR<
      CertificateCreateWithoutCourseInput,
      CertificateUncheckedCreateWithoutCourseInput
    >;
    where?: CertificateWhereInput;
  };

  export type CertificateUpdateToOneWithWhereWithoutCourseInput = {
    where?: CertificateWhereInput;
    data: XOR<
      CertificateUpdateWithoutCourseInput,
      CertificateUncheckedUpdateWithoutCourseInput
    >;
  };

  export type CertificateUpdateWithoutCourseInput = {
    certificate?: NullableStringFieldUpdateOperationsInput | string | null;
    UserCertificate?: UserCertificateUpdateManyWithoutCertificateNestedInput;
  };

  export type CertificateUncheckedUpdateWithoutCourseInput = {
    certificate?: NullableStringFieldUpdateOperationsInput | string | null;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutCertificateNestedInput;
  };

  export type CouponCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: CouponCourseWhereUniqueInput;
    update: XOR<
      CouponCourseUpdateWithoutCourseInput,
      CouponCourseUncheckedUpdateWithoutCourseInput
    >;
    create: XOR<
      CouponCourseCreateWithoutCourseInput,
      CouponCourseUncheckedCreateWithoutCourseInput
    >;
  };

  export type CouponCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: CouponCourseWhereUniqueInput;
    data: XOR<
      CouponCourseUpdateWithoutCourseInput,
      CouponCourseUncheckedUpdateWithoutCourseInput
    >;
  };

  export type CouponCourseUpdateManyWithWhereWithoutCourseInput = {
    where: CouponCourseScalarWhereInput;
    data: XOR<
      CouponCourseUpdateManyMutationInput,
      CouponCourseUncheckedUpdateManyWithoutCourseInput
    >;
  };

  export type UserUpsertWithoutCourseInput = {
    update: XOR<
      UserUpdateWithoutCourseInput,
      UserUncheckedUpdateWithoutCourseInput
    >;
    create: XOR<
      UserCreateWithoutCourseInput,
      UserUncheckedCreateWithoutCourseInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutCourseInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutCourseInput,
      UserUncheckedUpdateWithoutCourseInput
    >;
  };

  export type UserUpdateWithoutCourseInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutCourseInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type CourseCategoryUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseCategoryWhereUniqueInput;
    update: XOR<
      CourseCategoryUpdateWithoutCourseInput,
      CourseCategoryUncheckedUpdateWithoutCourseInput
    >;
    create: XOR<
      CourseCategoryCreateWithoutCourseInput,
      CourseCategoryUncheckedCreateWithoutCourseInput
    >;
  };

  export type CourseCategoryUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseCategoryWhereUniqueInput;
    data: XOR<
      CourseCategoryUpdateWithoutCourseInput,
      CourseCategoryUncheckedUpdateWithoutCourseInput
    >;
  };

  export type CourseCategoryUpdateManyWithWhereWithoutCourseInput = {
    where: CourseCategoryScalarWhereInput;
    data: XOR<
      CourseCategoryUpdateManyMutationInput,
      CourseCategoryUncheckedUpdateManyWithoutCourseInput
    >;
  };

  export type CourseObjectiveUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseObjectiveWhereUniqueInput;
    update: XOR<
      CourseObjectiveUpdateWithoutCourseInput,
      CourseObjectiveUncheckedUpdateWithoutCourseInput
    >;
    create: XOR<
      CourseObjectiveCreateWithoutCourseInput,
      CourseObjectiveUncheckedCreateWithoutCourseInput
    >;
  };

  export type CourseObjectiveUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseObjectiveWhereUniqueInput;
    data: XOR<
      CourseObjectiveUpdateWithoutCourseInput,
      CourseObjectiveUncheckedUpdateWithoutCourseInput
    >;
  };

  export type CourseObjectiveUpdateManyWithWhereWithoutCourseInput = {
    where: CourseObjectiveScalarWhereInput;
    data: XOR<
      CourseObjectiveUpdateManyMutationInput,
      CourseObjectiveUncheckedUpdateManyWithoutCourseInput
    >;
  };

  export type CourseObjectiveScalarWhereInput = {
    AND?: CourseObjectiveScalarWhereInput | CourseObjectiveScalarWhereInput[];
    OR?: CourseObjectiveScalarWhereInput[];
    NOT?: CourseObjectiveScalarWhereInput | CourseObjectiveScalarWhereInput[];
    idCourse?: IntFilter<'CourseObjective'> | number;
    idCourseObjective?: IntFilter<'CourseObjective'> | number;
    content?: StringNullableFilter<'CourseObjective'> | string | null;
  };

  export type EnrollmentUpsertWithWhereUniqueWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput;
    update: XOR<
      EnrollmentUpdateWithoutCourseInput,
      EnrollmentUncheckedUpdateWithoutCourseInput
    >;
    create: XOR<
      EnrollmentCreateWithoutCourseInput,
      EnrollmentUncheckedCreateWithoutCourseInput
    >;
  };

  export type EnrollmentUpdateWithWhereUniqueWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput;
    data: XOR<
      EnrollmentUpdateWithoutCourseInput,
      EnrollmentUncheckedUpdateWithoutCourseInput
    >;
  };

  export type EnrollmentUpdateManyWithWhereWithoutCourseInput = {
    where: EnrollmentScalarWhereInput;
    data: XOR<
      EnrollmentUpdateManyMutationInput,
      EnrollmentUncheckedUpdateManyWithoutCourseInput
    >;
  };

  export type EnrollmentScalarWhereInput = {
    AND?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[];
    OR?: EnrollmentScalarWhereInput[];
    NOT?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[];
    idUser?: IntFilter<'Enrollment'> | number;
    idCourse?: IntFilter<'Enrollment'> | number;
    dateRegister?: DateTimeNullableFilter<'Enrollment'> | Date | string | null;
    finishStatus?: BoolNullableFilter<'Enrollment'> | boolean | null;
    progress?:
      | DecimalNullableFilter<'Enrollment'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type PaymentDetailUpsertWithWhereUniqueWithoutCourseInput = {
    where: PaymentDetailWhereUniqueInput;
    update: XOR<
      PaymentDetailUpdateWithoutCourseInput,
      PaymentDetailUncheckedUpdateWithoutCourseInput
    >;
    create: XOR<
      PaymentDetailCreateWithoutCourseInput,
      PaymentDetailUncheckedCreateWithoutCourseInput
    >;
  };

  export type PaymentDetailUpdateWithWhereUniqueWithoutCourseInput = {
    where: PaymentDetailWhereUniqueInput;
    data: XOR<
      PaymentDetailUpdateWithoutCourseInput,
      PaymentDetailUncheckedUpdateWithoutCourseInput
    >;
  };

  export type PaymentDetailUpdateManyWithWhereWithoutCourseInput = {
    where: PaymentDetailScalarWhereInput;
    data: XOR<
      PaymentDetailUpdateManyMutationInput,
      PaymentDetailUncheckedUpdateManyWithoutCourseInput
    >;
  };

  export type PaymentDetailScalarWhereInput = {
    AND?: PaymentDetailScalarWhereInput | PaymentDetailScalarWhereInput[];
    OR?: PaymentDetailScalarWhereInput[];
    NOT?: PaymentDetailScalarWhereInput | PaymentDetailScalarWhereInput[];
    idPayment?: IntFilter<'PaymentDetail'> | number;
    idCourse?: IntFilter<'PaymentDetail'> | number;
    price?:
      | DecimalNullableFilter<'PaymentDetail'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type ReviewUpsertWithWhereUniqueWithoutCourseInput = {
    where: ReviewWhereUniqueInput;
    update: XOR<
      ReviewUpdateWithoutCourseInput,
      ReviewUncheckedUpdateWithoutCourseInput
    >;
    create: XOR<
      ReviewCreateWithoutCourseInput,
      ReviewUncheckedCreateWithoutCourseInput
    >;
  };

  export type ReviewUpdateWithWhereUniqueWithoutCourseInput = {
    where: ReviewWhereUniqueInput;
    data: XOR<
      ReviewUpdateWithoutCourseInput,
      ReviewUncheckedUpdateWithoutCourseInput
    >;
  };

  export type ReviewUpdateManyWithWhereWithoutCourseInput = {
    where: ReviewScalarWhereInput;
    data: XOR<
      ReviewUpdateManyMutationInput,
      ReviewUncheckedUpdateManyWithoutCourseInput
    >;
  };

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
    OR?: ReviewScalarWhereInput[];
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
    idReview?: IntFilter<'Review'> | number;
    idUser?: IntNullableFilter<'Review'> | number | null;
    idCourse?: IntNullableFilter<'Review'> | number | null;
    rating?: IntNullableFilter<'Review'> | number | null;
    review?: StringNullableFilter<'Review'> | string | null;
  };

  export type SectionUpsertWithWhereUniqueWithoutCourseInput = {
    where: SectionWhereUniqueInput;
    update: XOR<
      SectionUpdateWithoutCourseInput,
      SectionUncheckedUpdateWithoutCourseInput
    >;
    create: XOR<
      SectionCreateWithoutCourseInput,
      SectionUncheckedCreateWithoutCourseInput
    >;
  };

  export type SectionUpdateWithWhereUniqueWithoutCourseInput = {
    where: SectionWhereUniqueInput;
    data: XOR<
      SectionUpdateWithoutCourseInput,
      SectionUncheckedUpdateWithoutCourseInput
    >;
  };

  export type SectionUpdateManyWithWhereWithoutCourseInput = {
    where: SectionScalarWhereInput;
    data: XOR<
      SectionUpdateManyMutationInput,
      SectionUncheckedUpdateManyWithoutCourseInput
    >;
  };

  export type SectionScalarWhereInput = {
    AND?: SectionScalarWhereInput | SectionScalarWhereInput[];
    OR?: SectionScalarWhereInput[];
    NOT?: SectionScalarWhereInput | SectionScalarWhereInput[];
    idCourse?: IntFilter<'Section'> | number;
    idSection?: IntFilter<'Section'> | number;
    nameSection?: StringNullableFilter<'Section'> | string | null;
  };

  export type StudyRemindUpsertWithWhereUniqueWithoutCourseInput = {
    where: StudyRemindWhereUniqueInput;
    update: XOR<
      StudyRemindUpdateWithoutCourseInput,
      StudyRemindUncheckedUpdateWithoutCourseInput
    >;
    create: XOR<
      StudyRemindCreateWithoutCourseInput,
      StudyRemindUncheckedCreateWithoutCourseInput
    >;
  };

  export type StudyRemindUpdateWithWhereUniqueWithoutCourseInput = {
    where: StudyRemindWhereUniqueInput;
    data: XOR<
      StudyRemindUpdateWithoutCourseInput,
      StudyRemindUncheckedUpdateWithoutCourseInput
    >;
  };

  export type StudyRemindUpdateManyWithWhereWithoutCourseInput = {
    where: StudyRemindScalarWhereInput;
    data: XOR<
      StudyRemindUpdateManyMutationInput,
      StudyRemindUncheckedUpdateManyWithoutCourseInput
    >;
  };

  export type StudyRemindScalarWhereInput = {
    AND?: StudyRemindScalarWhereInput | StudyRemindScalarWhereInput[];
    OR?: StudyRemindScalarWhereInput[];
    NOT?: StudyRemindScalarWhereInput | StudyRemindScalarWhereInput[];
    idStudyRemind?: IntFilter<'StudyRemind'> | number;
    idUser?: IntNullableFilter<'StudyRemind'> | number | null;
    idCourse?: IntNullableFilter<'StudyRemind'> | number | null;
    timeRemind?: DateTimeNullableFilter<'StudyRemind'> | Date | string | null;
    typeRemind?: StringNullableFilter<'StudyRemind'> | string | null;
  };

  export type WishlistUpsertWithWhereUniqueWithoutCourseInput = {
    where: WishlistWhereUniqueInput;
    update: XOR<
      WishlistUpdateWithoutCourseInput,
      WishlistUncheckedUpdateWithoutCourseInput
    >;
    create: XOR<
      WishlistCreateWithoutCourseInput,
      WishlistUncheckedCreateWithoutCourseInput
    >;
  };

  export type WishlistUpdateWithWhereUniqueWithoutCourseInput = {
    where: WishlistWhereUniqueInput;
    data: XOR<
      WishlistUpdateWithoutCourseInput,
      WishlistUncheckedUpdateWithoutCourseInput
    >;
  };

  export type WishlistUpdateManyWithWhereWithoutCourseInput = {
    where: WishlistScalarWhereInput;
    data: XOR<
      WishlistUpdateManyMutationInput,
      WishlistUncheckedUpdateManyWithoutCourseInput
    >;
  };

  export type WishlistScalarWhereInput = {
    AND?: WishlistScalarWhereInput | WishlistScalarWhereInput[];
    OR?: WishlistScalarWhereInput[];
    NOT?: WishlistScalarWhereInput | WishlistScalarWhereInput[];
    idUser?: IntFilter<'Wishlist'> | number;
    idCourse?: IntFilter<'Wishlist'> | number;
  };

  export type CategoryCreateWithoutCourseCategoryInput = {
    nameCategory?: string | null;
  };

  export type CategoryUncheckedCreateWithoutCourseCategoryInput = {
    idCategory?: number;
    nameCategory?: string | null;
  };

  export type CategoryCreateOrConnectWithoutCourseCategoryInput = {
    where: CategoryWhereUniqueInput;
    create: XOR<
      CategoryCreateWithoutCourseCategoryInput,
      CategoryUncheckedCreateWithoutCourseCategoryInput
    >;
  };

  export type CourseCreateWithoutCourseCategoryInput = {
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseCreateNestedManyWithoutCourseInput;
    User?: UserCreateNestedOneWithoutCourseInput;
    CourseObjective?: CourseObjectiveCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailCreateNestedManyWithoutCourseInput;
    Review?: ReviewCreateNestedManyWithoutCourseInput;
    Section?: SectionCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistCreateNestedManyWithoutCourseInput;
  };

  export type CourseUncheckedCreateWithoutCourseCategoryInput = {
    idCourse?: number;
    idUser?: number | null;
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartUncheckedCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateUncheckedCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseUncheckedCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailUncheckedCreateNestedManyWithoutCourseInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutCourseInput;
    Section?: SectionUncheckedCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutCourseInput;
  };

  export type CourseCreateOrConnectWithoutCourseCategoryInput = {
    where: CourseWhereUniqueInput;
    create: XOR<
      CourseCreateWithoutCourseCategoryInput,
      CourseUncheckedCreateWithoutCourseCategoryInput
    >;
  };

  export type CategoryUpsertWithoutCourseCategoryInput = {
    update: XOR<
      CategoryUpdateWithoutCourseCategoryInput,
      CategoryUncheckedUpdateWithoutCourseCategoryInput
    >;
    create: XOR<
      CategoryCreateWithoutCourseCategoryInput,
      CategoryUncheckedCreateWithoutCourseCategoryInput
    >;
    where?: CategoryWhereInput;
  };

  export type CategoryUpdateToOneWithWhereWithoutCourseCategoryInput = {
    where?: CategoryWhereInput;
    data: XOR<
      CategoryUpdateWithoutCourseCategoryInput,
      CategoryUncheckedUpdateWithoutCourseCategoryInput
    >;
  };

  export type CategoryUpdateWithoutCourseCategoryInput = {
    nameCategory?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CategoryUncheckedUpdateWithoutCourseCategoryInput = {
    idCategory?: IntFieldUpdateOperationsInput | number;
    nameCategory?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CourseUpsertWithoutCourseCategoryInput = {
    update: XOR<
      CourseUpdateWithoutCourseCategoryInput,
      CourseUncheckedUpdateWithoutCourseCategoryInput
    >;
    create: XOR<
      CourseCreateWithoutCourseCategoryInput,
      CourseUncheckedCreateWithoutCourseCategoryInput
    >;
    where?: CourseWhereInput;
  };

  export type CourseUpdateToOneWithWhereWithoutCourseCategoryInput = {
    where?: CourseWhereInput;
    data: XOR<
      CourseUpdateWithoutCourseCategoryInput,
      CourseUncheckedUpdateWithoutCourseCategoryInput
    >;
  };

  export type CourseUpdateWithoutCourseCategoryInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUpdateManyWithoutCourseNestedInput;
    User?: UserUpdateOneWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUpdateManyWithoutCourseNestedInput;
    Section?: SectionUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUpdateManyWithoutCourseNestedInput;
  };

  export type CourseUncheckedUpdateWithoutCourseCategoryInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUncheckedUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUncheckedUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUncheckedUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUncheckedUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutCourseNestedInput;
    Section?: SectionUncheckedUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutCourseNestedInput;
  };

  export type CourseCreateWithoutCourseObjectiveInput = {
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseCreateNestedManyWithoutCourseInput;
    User?: UserCreateNestedOneWithoutCourseInput;
    CourseCategory?: CourseCategoryCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailCreateNestedManyWithoutCourseInput;
    Review?: ReviewCreateNestedManyWithoutCourseInput;
    Section?: SectionCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistCreateNestedManyWithoutCourseInput;
  };

  export type CourseUncheckedCreateWithoutCourseObjectiveInput = {
    idCourse?: number;
    idUser?: number | null;
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartUncheckedCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateUncheckedCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseUncheckedCreateNestedManyWithoutCourseInput;
    CourseCategory?: CourseCategoryUncheckedCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailUncheckedCreateNestedManyWithoutCourseInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutCourseInput;
    Section?: SectionUncheckedCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutCourseInput;
  };

  export type CourseCreateOrConnectWithoutCourseObjectiveInput = {
    where: CourseWhereUniqueInput;
    create: XOR<
      CourseCreateWithoutCourseObjectiveInput,
      CourseUncheckedCreateWithoutCourseObjectiveInput
    >;
  };

  export type CourseUpsertWithoutCourseObjectiveInput = {
    update: XOR<
      CourseUpdateWithoutCourseObjectiveInput,
      CourseUncheckedUpdateWithoutCourseObjectiveInput
    >;
    create: XOR<
      CourseCreateWithoutCourseObjectiveInput,
      CourseUncheckedCreateWithoutCourseObjectiveInput
    >;
    where?: CourseWhereInput;
  };

  export type CourseUpdateToOneWithWhereWithoutCourseObjectiveInput = {
    where?: CourseWhereInput;
    data: XOR<
      CourseUpdateWithoutCourseObjectiveInput,
      CourseUncheckedUpdateWithoutCourseObjectiveInput
    >;
  };

  export type CourseUpdateWithoutCourseObjectiveInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUpdateManyWithoutCourseNestedInput;
    User?: UserUpdateOneWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUpdateManyWithoutCourseNestedInput;
    Section?: SectionUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUpdateManyWithoutCourseNestedInput;
  };

  export type CourseUncheckedUpdateWithoutCourseObjectiveInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUncheckedUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUncheckedUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUncheckedUpdateManyWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUncheckedUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutCourseNestedInput;
    Section?: SectionUncheckedUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutCourseNestedInput;
  };

  export type CourseCreateWithoutEnrollmentInput = {
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseCreateNestedManyWithoutCourseInput;
    User?: UserCreateNestedOneWithoutCourseInput;
    CourseCategory?: CourseCategoryCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailCreateNestedManyWithoutCourseInput;
    Review?: ReviewCreateNestedManyWithoutCourseInput;
    Section?: SectionCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistCreateNestedManyWithoutCourseInput;
  };

  export type CourseUncheckedCreateWithoutEnrollmentInput = {
    idCourse?: number;
    idUser?: number | null;
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartUncheckedCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateUncheckedCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseUncheckedCreateNestedManyWithoutCourseInput;
    CourseCategory?: CourseCategoryUncheckedCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailUncheckedCreateNestedManyWithoutCourseInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutCourseInput;
    Section?: SectionUncheckedCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutCourseInput;
  };

  export type CourseCreateOrConnectWithoutEnrollmentInput = {
    where: CourseWhereUniqueInput;
    create: XOR<
      CourseCreateWithoutEnrollmentInput,
      CourseUncheckedCreateWithoutEnrollmentInput
    >;
  };

  export type UserCreateWithoutEnrollmentInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutEnrollmentInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
    Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
    Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutEnrollmentInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutEnrollmentInput,
      UserUncheckedCreateWithoutEnrollmentInput
    >;
  };

  export type CourseUpsertWithoutEnrollmentInput = {
    update: XOR<
      CourseUpdateWithoutEnrollmentInput,
      CourseUncheckedUpdateWithoutEnrollmentInput
    >;
    create: XOR<
      CourseCreateWithoutEnrollmentInput,
      CourseUncheckedCreateWithoutEnrollmentInput
    >;
    where?: CourseWhereInput;
  };

  export type CourseUpdateToOneWithWhereWithoutEnrollmentInput = {
    where?: CourseWhereInput;
    data: XOR<
      CourseUpdateWithoutEnrollmentInput,
      CourseUncheckedUpdateWithoutEnrollmentInput
    >;
  };

  export type CourseUpdateWithoutEnrollmentInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUpdateManyWithoutCourseNestedInput;
    User?: UserUpdateOneWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUpdateManyWithoutCourseNestedInput;
    Section?: SectionUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUpdateManyWithoutCourseNestedInput;
  };

  export type CourseUncheckedUpdateWithoutEnrollmentInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUncheckedUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUncheckedUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUncheckedUpdateManyWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUncheckedUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutCourseNestedInput;
    Section?: SectionUncheckedUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutCourseNestedInput;
  };

  export type UserUpsertWithoutEnrollmentInput = {
    update: XOR<
      UserUpdateWithoutEnrollmentInput,
      UserUncheckedUpdateWithoutEnrollmentInput
    >;
    create: XOR<
      UserCreateWithoutEnrollmentInput,
      UserUncheckedCreateWithoutEnrollmentInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutEnrollmentInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutEnrollmentInput,
      UserUncheckedUpdateWithoutEnrollmentInput
    >;
  };

  export type UserUpdateWithoutEnrollmentInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutEnrollmentInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
    Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutFollow_Follow_idFollowerToUserInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutFollow_Follow_idFollowerToUserInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
    Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
    Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutFollow_Follow_idFollowerToUserInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutFollow_Follow_idFollowerToUserInput,
      UserUncheckedCreateWithoutFollow_Follow_idFollowerToUserInput
    >;
  };

  export type UserCreateWithoutFollow_Follow_idFollowingToUserInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutFollow_Follow_idFollowingToUserInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
    Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
    Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutFollow_Follow_idFollowingToUserInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutFollow_Follow_idFollowingToUserInput,
      UserUncheckedCreateWithoutFollow_Follow_idFollowingToUserInput
    >;
  };

  export type UserUpsertWithoutFollow_Follow_idFollowerToUserInput = {
    update: XOR<
      UserUpdateWithoutFollow_Follow_idFollowerToUserInput,
      UserUncheckedUpdateWithoutFollow_Follow_idFollowerToUserInput
    >;
    create: XOR<
      UserCreateWithoutFollow_Follow_idFollowerToUserInput,
      UserUncheckedCreateWithoutFollow_Follow_idFollowerToUserInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutFollow_Follow_idFollowerToUserInput =
    {
      where?: UserWhereInput;
      data: XOR<
        UserUpdateWithoutFollow_Follow_idFollowerToUserInput,
        UserUncheckedUpdateWithoutFollow_Follow_idFollowerToUserInput
      >;
    };

  export type UserUpdateWithoutFollow_Follow_idFollowerToUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutFollow_Follow_idFollowerToUserInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
    Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserUpsertWithoutFollow_Follow_idFollowingToUserInput = {
    update: XOR<
      UserUpdateWithoutFollow_Follow_idFollowingToUserInput,
      UserUncheckedUpdateWithoutFollow_Follow_idFollowingToUserInput
    >;
    create: XOR<
      UserCreateWithoutFollow_Follow_idFollowingToUserInput,
      UserUncheckedCreateWithoutFollow_Follow_idFollowingToUserInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutFollow_Follow_idFollowingToUserInput =
    {
      where?: UserWhereInput;
      data: XOR<
        UserUpdateWithoutFollow_Follow_idFollowingToUserInput,
        UserUncheckedUpdateWithoutFollow_Follow_idFollowingToUserInput
      >;
    };

  export type UserUpdateWithoutFollow_Follow_idFollowingToUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutFollow_Follow_idFollowingToUserInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
    Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type SectionCreateWithoutLectureInput = {
    idSection: number;
    nameSection?: string | null;
    Course: CourseCreateNestedOneWithoutSectionInput;
  };

  export type SectionUncheckedCreateWithoutLectureInput = {
    idCourse: number;
    idSection: number;
    nameSection?: string | null;
  };

  export type SectionCreateOrConnectWithoutLectureInput = {
    where: SectionWhereUniqueInput;
    create: XOR<
      SectionCreateWithoutLectureInput,
      SectionUncheckedCreateWithoutLectureInput
    >;
  };

  export type NoteCreateWithoutLectureInput = {
    timeNote?: Date | string | null;
    note?: string | null;
    User?: UserCreateNestedOneWithoutNoteInput;
  };

  export type NoteUncheckedCreateWithoutLectureInput = {
    idNote?: number;
    timeNote?: Date | string | null;
    note?: string | null;
    idUser?: number | null;
  };

  export type NoteCreateOrConnectWithoutLectureInput = {
    where: NoteWhereUniqueInput;
    create: XOR<
      NoteCreateWithoutLectureInput,
      NoteUncheckedCreateWithoutLectureInput
    >;
  };

  export type NoteCreateManyLectureInputEnvelope = {
    data: NoteCreateManyLectureInput | NoteCreateManyLectureInput[];
    skipDuplicates?: boolean;
  };

  export type QuestionCreateWithoutLectureInput = {
    contentQuestion?: string | null;
    Answer?: AnswerCreateNestedManyWithoutQuestionInput;
    User?: UserCreateNestedOneWithoutQuestionInput;
  };

  export type QuestionUncheckedCreateWithoutLectureInput = {
    idQuestion?: number;
    idUser?: number | null;
    contentQuestion?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutQuestionInput;
  };

  export type QuestionCreateOrConnectWithoutLectureInput = {
    where: QuestionWhereUniqueInput;
    create: XOR<
      QuestionCreateWithoutLectureInput,
      QuestionUncheckedCreateWithoutLectureInput
    >;
  };

  export type QuestionCreateManyLectureInputEnvelope = {
    data: QuestionCreateManyLectureInput | QuestionCreateManyLectureInput[];
    skipDuplicates?: boolean;
  };

  export type SectionUpsertWithoutLectureInput = {
    update: XOR<
      SectionUpdateWithoutLectureInput,
      SectionUncheckedUpdateWithoutLectureInput
    >;
    create: XOR<
      SectionCreateWithoutLectureInput,
      SectionUncheckedCreateWithoutLectureInput
    >;
    where?: SectionWhereInput;
  };

  export type SectionUpdateToOneWithWhereWithoutLectureInput = {
    where?: SectionWhereInput;
    data: XOR<
      SectionUpdateWithoutLectureInput,
      SectionUncheckedUpdateWithoutLectureInput
    >;
  };

  export type SectionUpdateWithoutLectureInput = {
    idSection?: IntFieldUpdateOperationsInput | number;
    nameSection?: NullableStringFieldUpdateOperationsInput | string | null;
    Course?: CourseUpdateOneRequiredWithoutSectionNestedInput;
  };

  export type SectionUncheckedUpdateWithoutLectureInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idSection?: IntFieldUpdateOperationsInput | number;
    nameSection?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type NoteUpsertWithWhereUniqueWithoutLectureInput = {
    where: NoteWhereUniqueInput;
    update: XOR<
      NoteUpdateWithoutLectureInput,
      NoteUncheckedUpdateWithoutLectureInput
    >;
    create: XOR<
      NoteCreateWithoutLectureInput,
      NoteUncheckedCreateWithoutLectureInput
    >;
  };

  export type NoteUpdateWithWhereUniqueWithoutLectureInput = {
    where: NoteWhereUniqueInput;
    data: XOR<
      NoteUpdateWithoutLectureInput,
      NoteUncheckedUpdateWithoutLectureInput
    >;
  };

  export type NoteUpdateManyWithWhereWithoutLectureInput = {
    where: NoteScalarWhereInput;
    data: XOR<
      NoteUpdateManyMutationInput,
      NoteUncheckedUpdateManyWithoutLectureInput
    >;
  };

  export type NoteScalarWhereInput = {
    AND?: NoteScalarWhereInput | NoteScalarWhereInput[];
    OR?: NoteScalarWhereInput[];
    NOT?: NoteScalarWhereInput | NoteScalarWhereInput[];
    idNote?: IntFilter<'Note'> | number;
    timeNote?: DateTimeNullableFilter<'Note'> | Date | string | null;
    note?: StringNullableFilter<'Note'> | string | null;
    idUser?: IntNullableFilter<'Note'> | number | null;
    idCourse?: IntNullableFilter<'Note'> | number | null;
    idSection?: IntNullableFilter<'Note'> | number | null;
    idLecture?: IntNullableFilter<'Note'> | number | null;
  };

  export type QuestionUpsertWithWhereUniqueWithoutLectureInput = {
    where: QuestionWhereUniqueInput;
    update: XOR<
      QuestionUpdateWithoutLectureInput,
      QuestionUncheckedUpdateWithoutLectureInput
    >;
    create: XOR<
      QuestionCreateWithoutLectureInput,
      QuestionUncheckedCreateWithoutLectureInput
    >;
  };

  export type QuestionUpdateWithWhereUniqueWithoutLectureInput = {
    where: QuestionWhereUniqueInput;
    data: XOR<
      QuestionUpdateWithoutLectureInput,
      QuestionUncheckedUpdateWithoutLectureInput
    >;
  };

  export type QuestionUpdateManyWithWhereWithoutLectureInput = {
    where: QuestionScalarWhereInput;
    data: XOR<
      QuestionUpdateManyMutationInput,
      QuestionUncheckedUpdateManyWithoutLectureInput
    >;
  };

  export type QuestionScalarWhereInput = {
    AND?: QuestionScalarWhereInput | QuestionScalarWhereInput[];
    OR?: QuestionScalarWhereInput[];
    NOT?: QuestionScalarWhereInput | QuestionScalarWhereInput[];
    idQuestion?: IntFilter<'Question'> | number;
    idUser?: IntNullableFilter<'Question'> | number | null;
    idCourse?: IntNullableFilter<'Question'> | number | null;
    idSection?: IntNullableFilter<'Question'> | number | null;
    idLecture?: IntNullableFilter<'Question'> | number | null;
    contentQuestion?: StringNullableFilter<'Question'> | string | null;
  };

  export type UserCreateWithoutMessage_Message_idUserReceiverToUserInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutMessage_Message_idUserReceiverToUserInput =
    {
      idUser?: number;
      name?: string | null;
      biography?: string | null;
      role?: string | null;
      gender?: string | null;
      birthday?: Date | string | null;
      codeExpired?: string | null;
      codeId?: string | null;
      email?: string | null;
      password?: string | null;
      Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
      Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
      Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
      Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
      Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
      Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
      Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
      Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
      Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
      Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
      NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
      Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
      Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
      Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
      Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
      StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
      UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
      UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
      Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
    };

  export type UserCreateOrConnectWithoutMessage_Message_idUserReceiverToUserInput =
    {
      where: UserWhereUniqueInput;
      create: XOR<
        UserCreateWithoutMessage_Message_idUserReceiverToUserInput,
        UserUncheckedCreateWithoutMessage_Message_idUserReceiverToUserInput
      >;
    };

  export type UserCreateWithoutMessage_Message_idUserSenderToUserInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutMessage_Message_idUserSenderToUserInput =
    {
      idUser?: number;
      name?: string | null;
      biography?: string | null;
      role?: string | null;
      gender?: string | null;
      birthday?: Date | string | null;
      codeExpired?: string | null;
      codeId?: string | null;
      email?: string | null;
      password?: string | null;
      Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
      Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
      Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
      Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
      Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
      Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
      Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
      Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
      Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
      Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
      NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
      Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
      Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
      Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
      Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
      StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
      UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
      UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
      Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
    };

  export type UserCreateOrConnectWithoutMessage_Message_idUserSenderToUserInput =
    {
      where: UserWhereUniqueInput;
      create: XOR<
        UserCreateWithoutMessage_Message_idUserSenderToUserInput,
        UserUncheckedCreateWithoutMessage_Message_idUserSenderToUserInput
      >;
    };

  export type UserUpsertWithoutMessage_Message_idUserReceiverToUserInput = {
    update: XOR<
      UserUpdateWithoutMessage_Message_idUserReceiverToUserInput,
      UserUncheckedUpdateWithoutMessage_Message_idUserReceiverToUserInput
    >;
    create: XOR<
      UserCreateWithoutMessage_Message_idUserReceiverToUserInput,
      UserUncheckedCreateWithoutMessage_Message_idUserReceiverToUserInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutMessage_Message_idUserReceiverToUserInput =
    {
      where?: UserWhereInput;
      data: XOR<
        UserUpdateWithoutMessage_Message_idUserReceiverToUserInput,
        UserUncheckedUpdateWithoutMessage_Message_idUserReceiverToUserInput
      >;
    };

  export type UserUpdateWithoutMessage_Message_idUserReceiverToUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutMessage_Message_idUserReceiverToUserInput =
    {
      idUser?: IntFieldUpdateOperationsInput | number;
      name?: NullableStringFieldUpdateOperationsInput | string | null;
      biography?: NullableStringFieldUpdateOperationsInput | string | null;
      role?: NullableStringFieldUpdateOperationsInput | string | null;
      gender?: NullableStringFieldUpdateOperationsInput | string | null;
      birthday?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
      codeId?: NullableStringFieldUpdateOperationsInput | string | null;
      email?: NullableStringFieldUpdateOperationsInput | string | null;
      password?: NullableStringFieldUpdateOperationsInput | string | null;
      Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
      Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
      Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
      Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
      Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
      Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
      Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
      Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
      Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
      Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
      NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
      Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
      Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
      Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
      Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
      StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
      UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
      UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
      Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
    };

  export type UserUpsertWithoutMessage_Message_idUserSenderToUserInput = {
    update: XOR<
      UserUpdateWithoutMessage_Message_idUserSenderToUserInput,
      UserUncheckedUpdateWithoutMessage_Message_idUserSenderToUserInput
    >;
    create: XOR<
      UserCreateWithoutMessage_Message_idUserSenderToUserInput,
      UserUncheckedCreateWithoutMessage_Message_idUserSenderToUserInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutMessage_Message_idUserSenderToUserInput =
    {
      where?: UserWhereInput;
      data: XOR<
        UserUpdateWithoutMessage_Message_idUserSenderToUserInput,
        UserUncheckedUpdateWithoutMessage_Message_idUserSenderToUserInput
      >;
    };

  export type UserUpdateWithoutMessage_Message_idUserSenderToUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutMessage_Message_idUserSenderToUserInput =
    {
      idUser?: IntFieldUpdateOperationsInput | number;
      name?: NullableStringFieldUpdateOperationsInput | string | null;
      biography?: NullableStringFieldUpdateOperationsInput | string | null;
      role?: NullableStringFieldUpdateOperationsInput | string | null;
      gender?: NullableStringFieldUpdateOperationsInput | string | null;
      birthday?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
      codeId?: NullableStringFieldUpdateOperationsInput | string | null;
      email?: NullableStringFieldUpdateOperationsInput | string | null;
      password?: NullableStringFieldUpdateOperationsInput | string | null;
      Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
      Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
      Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
      Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
      Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
      Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
      Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
      Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
      Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
      Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
      NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
      Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
      Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
      Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
      Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
      StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
      UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
      UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
      Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
    };

  export type LectureCreateWithoutNoteInput = {
    idLecture: number;
    nameLecture?: string | null;
    isDone?: boolean | null;
    Section: SectionCreateNestedOneWithoutLectureInput;
    Question?: QuestionCreateNestedManyWithoutLectureInput;
  };

  export type LectureUncheckedCreateWithoutNoteInput = {
    idCourse: number;
    idSection: number;
    idLecture: number;
    nameLecture?: string | null;
    isDone?: boolean | null;
    Question?: QuestionUncheckedCreateNestedManyWithoutLectureInput;
  };

  export type LectureCreateOrConnectWithoutNoteInput = {
    where: LectureWhereUniqueInput;
    create: XOR<
      LectureCreateWithoutNoteInput,
      LectureUncheckedCreateWithoutNoteInput
    >;
  };

  export type UserCreateWithoutNoteInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutNoteInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
    Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
    Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutNoteInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutNoteInput,
      UserUncheckedCreateWithoutNoteInput
    >;
  };

  export type LectureUpsertWithoutNoteInput = {
    update: XOR<
      LectureUpdateWithoutNoteInput,
      LectureUncheckedUpdateWithoutNoteInput
    >;
    create: XOR<
      LectureCreateWithoutNoteInput,
      LectureUncheckedCreateWithoutNoteInput
    >;
    where?: LectureWhereInput;
  };

  export type LectureUpdateToOneWithWhereWithoutNoteInput = {
    where?: LectureWhereInput;
    data: XOR<
      LectureUpdateWithoutNoteInput,
      LectureUncheckedUpdateWithoutNoteInput
    >;
  };

  export type LectureUpdateWithoutNoteInput = {
    idLecture?: IntFieldUpdateOperationsInput | number;
    nameLecture?: NullableStringFieldUpdateOperationsInput | string | null;
    isDone?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    Section?: SectionUpdateOneRequiredWithoutLectureNestedInput;
    Question?: QuestionUpdateManyWithoutLectureNestedInput;
  };

  export type LectureUncheckedUpdateWithoutNoteInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idSection?: IntFieldUpdateOperationsInput | number;
    idLecture?: IntFieldUpdateOperationsInput | number;
    nameLecture?: NullableStringFieldUpdateOperationsInput | string | null;
    isDone?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    Question?: QuestionUncheckedUpdateManyWithoutLectureNestedInput;
  };

  export type UserUpsertWithoutNoteInput = {
    update: XOR<
      UserUpdateWithoutNoteInput,
      UserUncheckedUpdateWithoutNoteInput
    >;
    create: XOR<
      UserCreateWithoutNoteInput,
      UserUncheckedCreateWithoutNoteInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutNoteInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutNoteInput, UserUncheckedUpdateWithoutNoteInput>;
  };

  export type UserUpdateWithoutNoteInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutNoteInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
    Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutNotificationInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutNotificationInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
    Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
    Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutNotificationInput,
      UserUncheckedCreateWithoutNotificationInput
    >;
  };

  export type NotificationReceiverCreateWithoutNotificationInput = {
    timeGetNotification?: Date | string | null;
    User: UserCreateNestedOneWithoutNotificationReceiverInput;
  };

  export type NotificationReceiverUncheckedCreateWithoutNotificationInput = {
    idUser: number;
    timeGetNotification?: Date | string | null;
  };

  export type NotificationReceiverCreateOrConnectWithoutNotificationInput = {
    where: NotificationReceiverWhereUniqueInput;
    create: XOR<
      NotificationReceiverCreateWithoutNotificationInput,
      NotificationReceiverUncheckedCreateWithoutNotificationInput
    >;
  };

  export type NotificationReceiverCreateManyNotificationInputEnvelope = {
    data:
      | NotificationReceiverCreateManyNotificationInput
      | NotificationReceiverCreateManyNotificationInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<
      UserUpdateWithoutNotificationInput,
      UserUncheckedUpdateWithoutNotificationInput
    >;
    create: XOR<
      UserCreateWithoutNotificationInput,
      UserUncheckedCreateWithoutNotificationInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutNotificationInput,
      UserUncheckedUpdateWithoutNotificationInput
    >;
  };

  export type UserUpdateWithoutNotificationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutNotificationInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
    Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type NotificationReceiverUpsertWithWhereUniqueWithoutNotificationInput =
    {
      where: NotificationReceiverWhereUniqueInput;
      update: XOR<
        NotificationReceiverUpdateWithoutNotificationInput,
        NotificationReceiverUncheckedUpdateWithoutNotificationInput
      >;
      create: XOR<
        NotificationReceiverCreateWithoutNotificationInput,
        NotificationReceiverUncheckedCreateWithoutNotificationInput
      >;
    };

  export type NotificationReceiverUpdateWithWhereUniqueWithoutNotificationInput =
    {
      where: NotificationReceiverWhereUniqueInput;
      data: XOR<
        NotificationReceiverUpdateWithoutNotificationInput,
        NotificationReceiverUncheckedUpdateWithoutNotificationInput
      >;
    };

  export type NotificationReceiverUpdateManyWithWhereWithoutNotificationInput =
    {
      where: NotificationReceiverScalarWhereInput;
      data: XOR<
        NotificationReceiverUpdateManyMutationInput,
        NotificationReceiverUncheckedUpdateManyWithoutNotificationInput
      >;
    };

  export type NotificationReceiverScalarWhereInput = {
    AND?:
      | NotificationReceiverScalarWhereInput
      | NotificationReceiverScalarWhereInput[];
    OR?: NotificationReceiverScalarWhereInput[];
    NOT?:
      | NotificationReceiverScalarWhereInput
      | NotificationReceiverScalarWhereInput[];
    idNotification?: IntFilter<'NotificationReceiver'> | number;
    idUser?: IntFilter<'NotificationReceiver'> | number;
    timeGetNotification?:
      | DateTimeNullableFilter<'NotificationReceiver'>
      | Date
      | string
      | null;
  };

  export type NotificationCreateWithoutNotificationReceiverInput = {
    contentNotification?: string | null;
    User?: UserCreateNestedOneWithoutNotificationInput;
  };

  export type NotificationUncheckedCreateWithoutNotificationReceiverInput = {
    idNotification?: number;
    contentNotification?: string | null;
    idUser?: number | null;
  };

  export type NotificationCreateOrConnectWithoutNotificationReceiverInput = {
    where: NotificationWhereUniqueInput;
    create: XOR<
      NotificationCreateWithoutNotificationReceiverInput,
      NotificationUncheckedCreateWithoutNotificationReceiverInput
    >;
  };

  export type UserCreateWithoutNotificationReceiverInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutNotificationReceiverInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
    Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
    Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutNotificationReceiverInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutNotificationReceiverInput,
      UserUncheckedCreateWithoutNotificationReceiverInput
    >;
  };

  export type NotificationUpsertWithoutNotificationReceiverInput = {
    update: XOR<
      NotificationUpdateWithoutNotificationReceiverInput,
      NotificationUncheckedUpdateWithoutNotificationReceiverInput
    >;
    create: XOR<
      NotificationCreateWithoutNotificationReceiverInput,
      NotificationUncheckedCreateWithoutNotificationReceiverInput
    >;
    where?: NotificationWhereInput;
  };

  export type NotificationUpdateToOneWithWhereWithoutNotificationReceiverInput =
    {
      where?: NotificationWhereInput;
      data: XOR<
        NotificationUpdateWithoutNotificationReceiverInput,
        NotificationUncheckedUpdateWithoutNotificationReceiverInput
      >;
    };

  export type NotificationUpdateWithoutNotificationReceiverInput = {
    contentNotification?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    User?: UserUpdateOneWithoutNotificationNestedInput;
  };

  export type NotificationUncheckedUpdateWithoutNotificationReceiverInput = {
    idNotification?: IntFieldUpdateOperationsInput | number;
    contentNotification?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type UserUpsertWithoutNotificationReceiverInput = {
    update: XOR<
      UserUpdateWithoutNotificationReceiverInput,
      UserUncheckedUpdateWithoutNotificationReceiverInput
    >;
    create: XOR<
      UserCreateWithoutNotificationReceiverInput,
      UserUncheckedCreateWithoutNotificationReceiverInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutNotificationReceiverInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutNotificationReceiverInput,
      UserUncheckedUpdateWithoutNotificationReceiverInput
    >;
  };

  export type UserUpdateWithoutNotificationReceiverInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutNotificationReceiverInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
    Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutPaymentInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutPaymentInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
    Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
    Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutPaymentInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutPaymentInput,
      UserUncheckedCreateWithoutPaymentInput
    >;
  };

  export type PaymentDetailCreateWithoutPaymentInput = {
    price?: Decimal | DecimalJsLike | number | string | null;
    Course: CourseCreateNestedOneWithoutPaymentDetailInput;
  };

  export type PaymentDetailUncheckedCreateWithoutPaymentInput = {
    idCourse: number;
    price?: Decimal | DecimalJsLike | number | string | null;
  };

  export type PaymentDetailCreateOrConnectWithoutPaymentInput = {
    where: PaymentDetailWhereUniqueInput;
    create: XOR<
      PaymentDetailCreateWithoutPaymentInput,
      PaymentDetailUncheckedCreateWithoutPaymentInput
    >;
  };

  export type PaymentDetailCreateManyPaymentInputEnvelope = {
    data:
      | PaymentDetailCreateManyPaymentInput
      | PaymentDetailCreateManyPaymentInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutPaymentInput = {
    update: XOR<
      UserUpdateWithoutPaymentInput,
      UserUncheckedUpdateWithoutPaymentInput
    >;
    create: XOR<
      UserCreateWithoutPaymentInput,
      UserUncheckedCreateWithoutPaymentInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutPaymentInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutPaymentInput,
      UserUncheckedUpdateWithoutPaymentInput
    >;
  };

  export type UserUpdateWithoutPaymentInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutPaymentInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
    Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type PaymentDetailUpsertWithWhereUniqueWithoutPaymentInput = {
    where: PaymentDetailWhereUniqueInput;
    update: XOR<
      PaymentDetailUpdateWithoutPaymentInput,
      PaymentDetailUncheckedUpdateWithoutPaymentInput
    >;
    create: XOR<
      PaymentDetailCreateWithoutPaymentInput,
      PaymentDetailUncheckedCreateWithoutPaymentInput
    >;
  };

  export type PaymentDetailUpdateWithWhereUniqueWithoutPaymentInput = {
    where: PaymentDetailWhereUniqueInput;
    data: XOR<
      PaymentDetailUpdateWithoutPaymentInput,
      PaymentDetailUncheckedUpdateWithoutPaymentInput
    >;
  };

  export type PaymentDetailUpdateManyWithWhereWithoutPaymentInput = {
    where: PaymentDetailScalarWhereInput;
    data: XOR<
      PaymentDetailUpdateManyMutationInput,
      PaymentDetailUncheckedUpdateManyWithoutPaymentInput
    >;
  };

  export type CourseCreateWithoutPaymentDetailInput = {
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseCreateNestedManyWithoutCourseInput;
    User?: UserCreateNestedOneWithoutCourseInput;
    CourseCategory?: CourseCategoryCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutCourseInput;
    Review?: ReviewCreateNestedManyWithoutCourseInput;
    Section?: SectionCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistCreateNestedManyWithoutCourseInput;
  };

  export type CourseUncheckedCreateWithoutPaymentDetailInput = {
    idCourse?: number;
    idUser?: number | null;
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartUncheckedCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateUncheckedCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseUncheckedCreateNestedManyWithoutCourseInput;
    CourseCategory?: CourseCategoryUncheckedCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutCourseInput;
    Section?: SectionUncheckedCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutCourseInput;
  };

  export type CourseCreateOrConnectWithoutPaymentDetailInput = {
    where: CourseWhereUniqueInput;
    create: XOR<
      CourseCreateWithoutPaymentDetailInput,
      CourseUncheckedCreateWithoutPaymentDetailInput
    >;
  };

  export type PaymentCreateWithoutPaymentDetailInput = {
    timePayment?: Date | string | null;
    totalPrice?: Decimal | DecimalJsLike | number | string | null;
    User?: UserCreateNestedOneWithoutPaymentInput;
  };

  export type PaymentUncheckedCreateWithoutPaymentDetailInput = {
    idPayment?: number;
    timePayment?: Date | string | null;
    totalPrice?: Decimal | DecimalJsLike | number | string | null;
    idUser?: number | null;
  };

  export type PaymentCreateOrConnectWithoutPaymentDetailInput = {
    where: PaymentWhereUniqueInput;
    create: XOR<
      PaymentCreateWithoutPaymentDetailInput,
      PaymentUncheckedCreateWithoutPaymentDetailInput
    >;
  };

  export type CourseUpsertWithoutPaymentDetailInput = {
    update: XOR<
      CourseUpdateWithoutPaymentDetailInput,
      CourseUncheckedUpdateWithoutPaymentDetailInput
    >;
    create: XOR<
      CourseCreateWithoutPaymentDetailInput,
      CourseUncheckedCreateWithoutPaymentDetailInput
    >;
    where?: CourseWhereInput;
  };

  export type CourseUpdateToOneWithWhereWithoutPaymentDetailInput = {
    where?: CourseWhereInput;
    data: XOR<
      CourseUpdateWithoutPaymentDetailInput,
      CourseUncheckedUpdateWithoutPaymentDetailInput
    >;
  };

  export type CourseUpdateWithoutPaymentDetailInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUpdateManyWithoutCourseNestedInput;
    User?: UserUpdateOneWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUpdateManyWithoutCourseNestedInput;
    Section?: SectionUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUpdateManyWithoutCourseNestedInput;
  };

  export type CourseUncheckedUpdateWithoutPaymentDetailInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUncheckedUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUncheckedUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUncheckedUpdateManyWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutCourseNestedInput;
    Section?: SectionUncheckedUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutCourseNestedInput;
  };

  export type PaymentUpsertWithoutPaymentDetailInput = {
    update: XOR<
      PaymentUpdateWithoutPaymentDetailInput,
      PaymentUncheckedUpdateWithoutPaymentDetailInput
    >;
    create: XOR<
      PaymentCreateWithoutPaymentDetailInput,
      PaymentUncheckedCreateWithoutPaymentDetailInput
    >;
    where?: PaymentWhereInput;
  };

  export type PaymentUpdateToOneWithWhereWithoutPaymentDetailInput = {
    where?: PaymentWhereInput;
    data: XOR<
      PaymentUpdateWithoutPaymentDetailInput,
      PaymentUncheckedUpdateWithoutPaymentDetailInput
    >;
  };

  export type PaymentUpdateWithoutPaymentDetailInput = {
    timePayment?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    totalPrice?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    User?: UserUpdateOneWithoutPaymentNestedInput;
  };

  export type PaymentUncheckedUpdateWithoutPaymentDetailInput = {
    idPayment?: IntFieldUpdateOperationsInput | number;
    timePayment?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    totalPrice?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type AnswerCreateWithoutQuestionInput = {
    idAnswer: number;
    contentAnswer?: string | null;
    User?: UserCreateNestedOneWithoutAnswerInput;
  };

  export type AnswerUncheckedCreateWithoutQuestionInput = {
    idAnswer: number;
    idUser?: number | null;
    contentAnswer?: string | null;
  };

  export type AnswerCreateOrConnectWithoutQuestionInput = {
    where: AnswerWhereUniqueInput;
    create: XOR<
      AnswerCreateWithoutQuestionInput,
      AnswerUncheckedCreateWithoutQuestionInput
    >;
  };

  export type AnswerCreateManyQuestionInputEnvelope = {
    data: AnswerCreateManyQuestionInput | AnswerCreateManyQuestionInput[];
    skipDuplicates?: boolean;
  };

  export type LectureCreateWithoutQuestionInput = {
    idLecture: number;
    nameLecture?: string | null;
    isDone?: boolean | null;
    Section: SectionCreateNestedOneWithoutLectureInput;
    Note?: NoteCreateNestedManyWithoutLectureInput;
  };

  export type LectureUncheckedCreateWithoutQuestionInput = {
    idCourse: number;
    idSection: number;
    idLecture: number;
    nameLecture?: string | null;
    isDone?: boolean | null;
    Note?: NoteUncheckedCreateNestedManyWithoutLectureInput;
  };

  export type LectureCreateOrConnectWithoutQuestionInput = {
    where: LectureWhereUniqueInput;
    create: XOR<
      LectureCreateWithoutQuestionInput,
      LectureUncheckedCreateWithoutQuestionInput
    >;
  };

  export type UserCreateWithoutQuestionInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutQuestionInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
    Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
    Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutQuestionInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutQuestionInput,
      UserUncheckedCreateWithoutQuestionInput
    >;
  };

  export type AnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: AnswerWhereUniqueInput;
    update: XOR<
      AnswerUpdateWithoutQuestionInput,
      AnswerUncheckedUpdateWithoutQuestionInput
    >;
    create: XOR<
      AnswerCreateWithoutQuestionInput,
      AnswerUncheckedCreateWithoutQuestionInput
    >;
  };

  export type AnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: AnswerWhereUniqueInput;
    data: XOR<
      AnswerUpdateWithoutQuestionInput,
      AnswerUncheckedUpdateWithoutQuestionInput
    >;
  };

  export type AnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: AnswerScalarWhereInput;
    data: XOR<
      AnswerUpdateManyMutationInput,
      AnswerUncheckedUpdateManyWithoutQuestionInput
    >;
  };

  export type AnswerScalarWhereInput = {
    AND?: AnswerScalarWhereInput | AnswerScalarWhereInput[];
    OR?: AnswerScalarWhereInput[];
    NOT?: AnswerScalarWhereInput | AnswerScalarWhereInput[];
    idQuestion?: IntFilter<'Answer'> | number;
    idAnswer?: IntFilter<'Answer'> | number;
    idUser?: IntNullableFilter<'Answer'> | number | null;
    contentAnswer?: StringNullableFilter<'Answer'> | string | null;
  };

  export type LectureUpsertWithoutQuestionInput = {
    update: XOR<
      LectureUpdateWithoutQuestionInput,
      LectureUncheckedUpdateWithoutQuestionInput
    >;
    create: XOR<
      LectureCreateWithoutQuestionInput,
      LectureUncheckedCreateWithoutQuestionInput
    >;
    where?: LectureWhereInput;
  };

  export type LectureUpdateToOneWithWhereWithoutQuestionInput = {
    where?: LectureWhereInput;
    data: XOR<
      LectureUpdateWithoutQuestionInput,
      LectureUncheckedUpdateWithoutQuestionInput
    >;
  };

  export type LectureUpdateWithoutQuestionInput = {
    idLecture?: IntFieldUpdateOperationsInput | number;
    nameLecture?: NullableStringFieldUpdateOperationsInput | string | null;
    isDone?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    Section?: SectionUpdateOneRequiredWithoutLectureNestedInput;
    Note?: NoteUpdateManyWithoutLectureNestedInput;
  };

  export type LectureUncheckedUpdateWithoutQuestionInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idSection?: IntFieldUpdateOperationsInput | number;
    idLecture?: IntFieldUpdateOperationsInput | number;
    nameLecture?: NullableStringFieldUpdateOperationsInput | string | null;
    isDone?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    Note?: NoteUncheckedUpdateManyWithoutLectureNestedInput;
  };

  export type UserUpsertWithoutQuestionInput = {
    update: XOR<
      UserUpdateWithoutQuestionInput,
      UserUncheckedUpdateWithoutQuestionInput
    >;
    create: XOR<
      UserCreateWithoutQuestionInput,
      UserUncheckedCreateWithoutQuestionInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutQuestionInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutQuestionInput,
      UserUncheckedUpdateWithoutQuestionInput
    >;
  };

  export type UserUpdateWithoutQuestionInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutQuestionInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
    Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutReportInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutReportInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
    Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
    Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutReportInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutReportInput,
      UserUncheckedCreateWithoutReportInput
    >;
  };

  export type UserUpsertWithoutReportInput = {
    update: XOR<
      UserUpdateWithoutReportInput,
      UserUncheckedUpdateWithoutReportInput
    >;
    create: XOR<
      UserCreateWithoutReportInput,
      UserUncheckedCreateWithoutReportInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutReportInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutReportInput,
      UserUncheckedUpdateWithoutReportInput
    >;
  };

  export type UserUpdateWithoutReportInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutReportInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
    Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type CourseCreateWithoutReviewInput = {
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseCreateNestedManyWithoutCourseInput;
    User?: UserCreateNestedOneWithoutCourseInput;
    CourseCategory?: CourseCategoryCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailCreateNestedManyWithoutCourseInput;
    Section?: SectionCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistCreateNestedManyWithoutCourseInput;
  };

  export type CourseUncheckedCreateWithoutReviewInput = {
    idCourse?: number;
    idUser?: number | null;
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartUncheckedCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateUncheckedCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseUncheckedCreateNestedManyWithoutCourseInput;
    CourseCategory?: CourseCategoryUncheckedCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailUncheckedCreateNestedManyWithoutCourseInput;
    Section?: SectionUncheckedCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutCourseInput;
  };

  export type CourseCreateOrConnectWithoutReviewInput = {
    where: CourseWhereUniqueInput;
    create: XOR<
      CourseCreateWithoutReviewInput,
      CourseUncheckedCreateWithoutReviewInput
    >;
  };

  export type UserCreateWithoutReviewInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutReviewInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
    Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
    Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutReviewInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutReviewInput,
      UserUncheckedCreateWithoutReviewInput
    >;
  };

  export type CourseUpsertWithoutReviewInput = {
    update: XOR<
      CourseUpdateWithoutReviewInput,
      CourseUncheckedUpdateWithoutReviewInput
    >;
    create: XOR<
      CourseCreateWithoutReviewInput,
      CourseUncheckedCreateWithoutReviewInput
    >;
    where?: CourseWhereInput;
  };

  export type CourseUpdateToOneWithWhereWithoutReviewInput = {
    where?: CourseWhereInput;
    data: XOR<
      CourseUpdateWithoutReviewInput,
      CourseUncheckedUpdateWithoutReviewInput
    >;
  };

  export type CourseUpdateWithoutReviewInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUpdateManyWithoutCourseNestedInput;
    User?: UserUpdateOneWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUpdateManyWithoutCourseNestedInput;
    Section?: SectionUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUpdateManyWithoutCourseNestedInput;
  };

  export type CourseUncheckedUpdateWithoutReviewInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUncheckedUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUncheckedUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUncheckedUpdateManyWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUncheckedUpdateManyWithoutCourseNestedInput;
    Section?: SectionUncheckedUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutCourseNestedInput;
  };

  export type UserUpsertWithoutReviewInput = {
    update: XOR<
      UserUpdateWithoutReviewInput,
      UserUncheckedUpdateWithoutReviewInput
    >;
    create: XOR<
      UserCreateWithoutReviewInput,
      UserUncheckedCreateWithoutReviewInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutReviewInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutReviewInput,
      UserUncheckedUpdateWithoutReviewInput
    >;
  };

  export type UserUpdateWithoutReviewInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutReviewInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
    Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type LectureCreateWithoutSectionInput = {
    idLecture: number;
    nameLecture?: string | null;
    isDone?: boolean | null;
    Note?: NoteCreateNestedManyWithoutLectureInput;
    Question?: QuestionCreateNestedManyWithoutLectureInput;
  };

  export type LectureUncheckedCreateWithoutSectionInput = {
    idLecture: number;
    nameLecture?: string | null;
    isDone?: boolean | null;
    Note?: NoteUncheckedCreateNestedManyWithoutLectureInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutLectureInput;
  };

  export type LectureCreateOrConnectWithoutSectionInput = {
    where: LectureWhereUniqueInput;
    create: XOR<
      LectureCreateWithoutSectionInput,
      LectureUncheckedCreateWithoutSectionInput
    >;
  };

  export type LectureCreateManySectionInputEnvelope = {
    data: LectureCreateManySectionInput | LectureCreateManySectionInput[];
    skipDuplicates?: boolean;
  };

  export type CourseCreateWithoutSectionInput = {
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseCreateNestedManyWithoutCourseInput;
    User?: UserCreateNestedOneWithoutCourseInput;
    CourseCategory?: CourseCategoryCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailCreateNestedManyWithoutCourseInput;
    Review?: ReviewCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistCreateNestedManyWithoutCourseInput;
  };

  export type CourseUncheckedCreateWithoutSectionInput = {
    idCourse?: number;
    idUser?: number | null;
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartUncheckedCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateUncheckedCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseUncheckedCreateNestedManyWithoutCourseInput;
    CourseCategory?: CourseCategoryUncheckedCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailUncheckedCreateNestedManyWithoutCourseInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutCourseInput;
  };

  export type CourseCreateOrConnectWithoutSectionInput = {
    where: CourseWhereUniqueInput;
    create: XOR<
      CourseCreateWithoutSectionInput,
      CourseUncheckedCreateWithoutSectionInput
    >;
  };

  export type LectureUpsertWithWhereUniqueWithoutSectionInput = {
    where: LectureWhereUniqueInput;
    update: XOR<
      LectureUpdateWithoutSectionInput,
      LectureUncheckedUpdateWithoutSectionInput
    >;
    create: XOR<
      LectureCreateWithoutSectionInput,
      LectureUncheckedCreateWithoutSectionInput
    >;
  };

  export type LectureUpdateWithWhereUniqueWithoutSectionInput = {
    where: LectureWhereUniqueInput;
    data: XOR<
      LectureUpdateWithoutSectionInput,
      LectureUncheckedUpdateWithoutSectionInput
    >;
  };

  export type LectureUpdateManyWithWhereWithoutSectionInput = {
    where: LectureScalarWhereInput;
    data: XOR<
      LectureUpdateManyMutationInput,
      LectureUncheckedUpdateManyWithoutSectionInput
    >;
  };

  export type LectureScalarWhereInput = {
    AND?: LectureScalarWhereInput | LectureScalarWhereInput[];
    OR?: LectureScalarWhereInput[];
    NOT?: LectureScalarWhereInput | LectureScalarWhereInput[];
    idCourse?: IntFilter<'Lecture'> | number;
    idSection?: IntFilter<'Lecture'> | number;
    idLecture?: IntFilter<'Lecture'> | number;
    nameLecture?: StringNullableFilter<'Lecture'> | string | null;
    isDone?: BoolNullableFilter<'Lecture'> | boolean | null;
  };

  export type CourseUpsertWithoutSectionInput = {
    update: XOR<
      CourseUpdateWithoutSectionInput,
      CourseUncheckedUpdateWithoutSectionInput
    >;
    create: XOR<
      CourseCreateWithoutSectionInput,
      CourseUncheckedCreateWithoutSectionInput
    >;
    where?: CourseWhereInput;
  };

  export type CourseUpdateToOneWithWhereWithoutSectionInput = {
    where?: CourseWhereInput;
    data: XOR<
      CourseUpdateWithoutSectionInput,
      CourseUncheckedUpdateWithoutSectionInput
    >;
  };

  export type CourseUpdateWithoutSectionInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUpdateManyWithoutCourseNestedInput;
    User?: UserUpdateOneWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUpdateManyWithoutCourseNestedInput;
  };

  export type CourseUncheckedUpdateWithoutSectionInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUncheckedUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUncheckedUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUncheckedUpdateManyWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUncheckedUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutCourseNestedInput;
  };

  export type CourseCreateWithoutStudyRemindInput = {
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseCreateNestedManyWithoutCourseInput;
    User?: UserCreateNestedOneWithoutCourseInput;
    CourseCategory?: CourseCategoryCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailCreateNestedManyWithoutCourseInput;
    Review?: ReviewCreateNestedManyWithoutCourseInput;
    Section?: SectionCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistCreateNestedManyWithoutCourseInput;
  };

  export type CourseUncheckedCreateWithoutStudyRemindInput = {
    idCourse?: number;
    idUser?: number | null;
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartUncheckedCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateUncheckedCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseUncheckedCreateNestedManyWithoutCourseInput;
    CourseCategory?: CourseCategoryUncheckedCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailUncheckedCreateNestedManyWithoutCourseInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutCourseInput;
    Section?: SectionUncheckedCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutCourseInput;
  };

  export type CourseCreateOrConnectWithoutStudyRemindInput = {
    where: CourseWhereUniqueInput;
    create: XOR<
      CourseCreateWithoutStudyRemindInput,
      CourseUncheckedCreateWithoutStudyRemindInput
    >;
  };

  export type UserCreateWithoutStudyRemindInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutStudyRemindInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
    Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
    Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutStudyRemindInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutStudyRemindInput,
      UserUncheckedCreateWithoutStudyRemindInput
    >;
  };

  export type CourseUpsertWithoutStudyRemindInput = {
    update: XOR<
      CourseUpdateWithoutStudyRemindInput,
      CourseUncheckedUpdateWithoutStudyRemindInput
    >;
    create: XOR<
      CourseCreateWithoutStudyRemindInput,
      CourseUncheckedCreateWithoutStudyRemindInput
    >;
    where?: CourseWhereInput;
  };

  export type CourseUpdateToOneWithWhereWithoutStudyRemindInput = {
    where?: CourseWhereInput;
    data: XOR<
      CourseUpdateWithoutStudyRemindInput,
      CourseUncheckedUpdateWithoutStudyRemindInput
    >;
  };

  export type CourseUpdateWithoutStudyRemindInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUpdateManyWithoutCourseNestedInput;
    User?: UserUpdateOneWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUpdateManyWithoutCourseNestedInput;
    Section?: SectionUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUpdateManyWithoutCourseNestedInput;
  };

  export type CourseUncheckedUpdateWithoutStudyRemindInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUncheckedUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUncheckedUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUncheckedUpdateManyWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUncheckedUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutCourseNestedInput;
    Section?: SectionUncheckedUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutCourseNestedInput;
  };

  export type UserUpsertWithoutStudyRemindInput = {
    update: XOR<
      UserUpdateWithoutStudyRemindInput,
      UserUncheckedUpdateWithoutStudyRemindInput
    >;
    create: XOR<
      UserCreateWithoutStudyRemindInput,
      UserUncheckedCreateWithoutStudyRemindInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutStudyRemindInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutStudyRemindInput,
      UserUncheckedUpdateWithoutStudyRemindInput
    >;
  };

  export type UserUpdateWithoutStudyRemindInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutStudyRemindInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
    Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type AnswerCreateWithoutUserInput = {
    idAnswer: number;
    contentAnswer?: string | null;
    Question: QuestionCreateNestedOneWithoutAnswerInput;
  };

  export type AnswerUncheckedCreateWithoutUserInput = {
    idQuestion: number;
    idAnswer: number;
    contentAnswer?: string | null;
  };

  export type AnswerCreateOrConnectWithoutUserInput = {
    where: AnswerWhereUniqueInput;
    create: XOR<
      AnswerCreateWithoutUserInput,
      AnswerUncheckedCreateWithoutUserInput
    >;
  };

  export type AnswerCreateManyUserInputEnvelope = {
    data: AnswerCreateManyUserInput | AnswerCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type CartCreateWithoutUserInput = {
    Course: CourseCreateNestedOneWithoutCartInput;
  };

  export type CartUncheckedCreateWithoutUserInput = {
    idCourse: number;
  };

  export type CartCreateOrConnectWithoutUserInput = {
    where: CartWhereUniqueInput;
    create: XOR<
      CartCreateWithoutUserInput,
      CartUncheckedCreateWithoutUserInput
    >;
  };

  export type CartCreateManyUserInputEnvelope = {
    data: CartCreateManyUserInput | CartCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type CouponCreateWithoutUserInput = {
    type?: string | null;
    value?: Decimal | DecimalJsLike | number | string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    quantity?: number | null;
    appliedAmount?: number | null;
    minRequire?: Decimal | DecimalJsLike | number | string | null;
    maxValueDiscount?: Decimal | DecimalJsLike | number | string | null;
    code?: string | null;
    CouponCourse?: CouponCourseCreateNestedManyWithoutCouponInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutCouponInput;
  };

  export type CouponUncheckedCreateWithoutUserInput = {
    idCoupon?: number;
    type?: string | null;
    value?: Decimal | DecimalJsLike | number | string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    quantity?: number | null;
    appliedAmount?: number | null;
    minRequire?: Decimal | DecimalJsLike | number | string | null;
    maxValueDiscount?: Decimal | DecimalJsLike | number | string | null;
    code?: string | null;
    CouponCourse?: CouponCourseUncheckedCreateNestedManyWithoutCouponInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutCouponInput;
  };

  export type CouponCreateOrConnectWithoutUserInput = {
    where: CouponWhereUniqueInput;
    create: XOR<
      CouponCreateWithoutUserInput,
      CouponUncheckedCreateWithoutUserInput
    >;
  };

  export type CouponCreateManyUserInputEnvelope = {
    data: CouponCreateManyUserInput | CouponCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type CourseCreateWithoutUserInput = {
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseCreateNestedManyWithoutCourseInput;
    CourseCategory?: CourseCategoryCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailCreateNestedManyWithoutCourseInput;
    Review?: ReviewCreateNestedManyWithoutCourseInput;
    Section?: SectionCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistCreateNestedManyWithoutCourseInput;
  };

  export type CourseUncheckedCreateWithoutUserInput = {
    idCourse?: number;
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartUncheckedCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateUncheckedCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseUncheckedCreateNestedManyWithoutCourseInput;
    CourseCategory?: CourseCategoryUncheckedCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailUncheckedCreateNestedManyWithoutCourseInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutCourseInput;
    Section?: SectionUncheckedCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutCourseInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutCourseInput;
  };

  export type CourseCreateOrConnectWithoutUserInput = {
    where: CourseWhereUniqueInput;
    create: XOR<
      CourseCreateWithoutUserInput,
      CourseUncheckedCreateWithoutUserInput
    >;
  };

  export type CourseCreateManyUserInputEnvelope = {
    data: CourseCreateManyUserInput | CourseCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type EnrollmentCreateWithoutUserInput = {
    dateRegister?: Date | string | null;
    finishStatus?: boolean | null;
    progress?: Decimal | DecimalJsLike | number | string | null;
    Course: CourseCreateNestedOneWithoutEnrollmentInput;
  };

  export type EnrollmentUncheckedCreateWithoutUserInput = {
    idCourse: number;
    dateRegister?: Date | string | null;
    finishStatus?: boolean | null;
    progress?: Decimal | DecimalJsLike | number | string | null;
  };

  export type EnrollmentCreateOrConnectWithoutUserInput = {
    where: EnrollmentWhereUniqueInput;
    create: XOR<
      EnrollmentCreateWithoutUserInput,
      EnrollmentUncheckedCreateWithoutUserInput
    >;
  };

  export type EnrollmentCreateManyUserInputEnvelope = {
    data: EnrollmentCreateManyUserInput | EnrollmentCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type FollowCreateWithoutUser_Follow_idFollowerToUserInput = {
    User_Follow_idFollowingToUser: UserCreateNestedOneWithoutFollow_Follow_idFollowingToUserInput;
  };

  export type FollowUncheckedCreateWithoutUser_Follow_idFollowerToUserInput = {
    idFollowing: number;
  };

  export type FollowCreateOrConnectWithoutUser_Follow_idFollowerToUserInput = {
    where: FollowWhereUniqueInput;
    create: XOR<
      FollowCreateWithoutUser_Follow_idFollowerToUserInput,
      FollowUncheckedCreateWithoutUser_Follow_idFollowerToUserInput
    >;
  };

  export type FollowCreateManyUser_Follow_idFollowerToUserInputEnvelope = {
    data:
      | FollowCreateManyUser_Follow_idFollowerToUserInput
      | FollowCreateManyUser_Follow_idFollowerToUserInput[];
    skipDuplicates?: boolean;
  };

  export type FollowCreateWithoutUser_Follow_idFollowingToUserInput = {
    User_Follow_idFollowerToUser: UserCreateNestedOneWithoutFollow_Follow_idFollowerToUserInput;
  };

  export type FollowUncheckedCreateWithoutUser_Follow_idFollowingToUserInput = {
    idFollower: number;
  };

  export type FollowCreateOrConnectWithoutUser_Follow_idFollowingToUserInput = {
    where: FollowWhereUniqueInput;
    create: XOR<
      FollowCreateWithoutUser_Follow_idFollowingToUserInput,
      FollowUncheckedCreateWithoutUser_Follow_idFollowingToUserInput
    >;
  };

  export type FollowCreateManyUser_Follow_idFollowingToUserInputEnvelope = {
    data:
      | FollowCreateManyUser_Follow_idFollowingToUserInput
      | FollowCreateManyUser_Follow_idFollowingToUserInput[];
    skipDuplicates?: boolean;
  };

  export type MessageCreateWithoutUser_Message_idUserReceiverToUserInput = {
    message?: string | null;
    timeSend?: Date | string | null;
    User_Message_idUserSenderToUser?: UserCreateNestedOneWithoutMessage_Message_idUserSenderToUserInput;
  };

  export type MessageUncheckedCreateWithoutUser_Message_idUserReceiverToUserInput =
    {
      idMessage?: number;
      idUserSender?: number | null;
      message?: string | null;
      timeSend?: Date | string | null;
    };

  export type MessageCreateOrConnectWithoutUser_Message_idUserReceiverToUserInput =
    {
      where: MessageWhereUniqueInput;
      create: XOR<
        MessageCreateWithoutUser_Message_idUserReceiverToUserInput,
        MessageUncheckedCreateWithoutUser_Message_idUserReceiverToUserInput
      >;
    };

  export type MessageCreateManyUser_Message_idUserReceiverToUserInputEnvelope =
    {
      data:
        | MessageCreateManyUser_Message_idUserReceiverToUserInput
        | MessageCreateManyUser_Message_idUserReceiverToUserInput[];
      skipDuplicates?: boolean;
    };

  export type MessageCreateWithoutUser_Message_idUserSenderToUserInput = {
    message?: string | null;
    timeSend?: Date | string | null;
    User_Message_idUserReceiverToUser?: UserCreateNestedOneWithoutMessage_Message_idUserReceiverToUserInput;
  };

  export type MessageUncheckedCreateWithoutUser_Message_idUserSenderToUserInput =
    {
      idMessage?: number;
      idUserReceiver?: number | null;
      message?: string | null;
      timeSend?: Date | string | null;
    };

  export type MessageCreateOrConnectWithoutUser_Message_idUserSenderToUserInput =
    {
      where: MessageWhereUniqueInput;
      create: XOR<
        MessageCreateWithoutUser_Message_idUserSenderToUserInput,
        MessageUncheckedCreateWithoutUser_Message_idUserSenderToUserInput
      >;
    };

  export type MessageCreateManyUser_Message_idUserSenderToUserInputEnvelope = {
    data:
      | MessageCreateManyUser_Message_idUserSenderToUserInput
      | MessageCreateManyUser_Message_idUserSenderToUserInput[];
    skipDuplicates?: boolean;
  };

  export type NoteCreateWithoutUserInput = {
    timeNote?: Date | string | null;
    note?: string | null;
    Lecture?: LectureCreateNestedOneWithoutNoteInput;
  };

  export type NoteUncheckedCreateWithoutUserInput = {
    idNote?: number;
    timeNote?: Date | string | null;
    note?: string | null;
    idCourse?: number | null;
    idSection?: number | null;
    idLecture?: number | null;
  };

  export type NoteCreateOrConnectWithoutUserInput = {
    where: NoteWhereUniqueInput;
    create: XOR<
      NoteCreateWithoutUserInput,
      NoteUncheckedCreateWithoutUserInput
    >;
  };

  export type NoteCreateManyUserInputEnvelope = {
    data: NoteCreateManyUserInput | NoteCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type NotificationCreateWithoutUserInput = {
    contentNotification?: string | null;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutNotificationInput;
  };

  export type NotificationUncheckedCreateWithoutUserInput = {
    idNotification?: number;
    contentNotification?: string | null;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutNotificationInput;
  };

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    create: XOR<
      NotificationCreateWithoutUserInput,
      NotificationUncheckedCreateWithoutUserInput
    >;
  };

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type NotificationReceiverCreateWithoutUserInput = {
    timeGetNotification?: Date | string | null;
    Notification: NotificationCreateNestedOneWithoutNotificationReceiverInput;
  };

  export type NotificationReceiverUncheckedCreateWithoutUserInput = {
    idNotification: number;
    timeGetNotification?: Date | string | null;
  };

  export type NotificationReceiverCreateOrConnectWithoutUserInput = {
    where: NotificationReceiverWhereUniqueInput;
    create: XOR<
      NotificationReceiverCreateWithoutUserInput,
      NotificationReceiverUncheckedCreateWithoutUserInput
    >;
  };

  export type NotificationReceiverCreateManyUserInputEnvelope = {
    data:
      | NotificationReceiverCreateManyUserInput
      | NotificationReceiverCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type PaymentCreateWithoutUserInput = {
    timePayment?: Date | string | null;
    totalPrice?: Decimal | DecimalJsLike | number | string | null;
    PaymentDetail?: PaymentDetailCreateNestedManyWithoutPaymentInput;
  };

  export type PaymentUncheckedCreateWithoutUserInput = {
    idPayment?: number;
    timePayment?: Date | string | null;
    totalPrice?: Decimal | DecimalJsLike | number | string | null;
    PaymentDetail?: PaymentDetailUncheckedCreateNestedManyWithoutPaymentInput;
  };

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput;
    create: XOR<
      PaymentCreateWithoutUserInput,
      PaymentUncheckedCreateWithoutUserInput
    >;
  };

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type QuestionCreateWithoutUserInput = {
    contentQuestion?: string | null;
    Answer?: AnswerCreateNestedManyWithoutQuestionInput;
    Lecture?: LectureCreateNestedOneWithoutQuestionInput;
  };

  export type QuestionUncheckedCreateWithoutUserInput = {
    idQuestion?: number;
    idCourse?: number | null;
    idSection?: number | null;
    idLecture?: number | null;
    contentQuestion?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutQuestionInput;
  };

  export type QuestionCreateOrConnectWithoutUserInput = {
    where: QuestionWhereUniqueInput;
    create: XOR<
      QuestionCreateWithoutUserInput,
      QuestionUncheckedCreateWithoutUserInput
    >;
  };

  export type QuestionCreateManyUserInputEnvelope = {
    data: QuestionCreateManyUserInput | QuestionCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type ReportCreateWithoutUserInput = {
    contentReport?: string | null;
  };

  export type ReportUncheckedCreateWithoutUserInput = {
    idReport?: number;
    contentReport?: string | null;
  };

  export type ReportCreateOrConnectWithoutUserInput = {
    where: ReportWhereUniqueInput;
    create: XOR<
      ReportCreateWithoutUserInput,
      ReportUncheckedCreateWithoutUserInput
    >;
  };

  export type ReportCreateManyUserInputEnvelope = {
    data: ReportCreateManyUserInput | ReportCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type ReviewCreateWithoutUserInput = {
    rating?: number | null;
    review?: string | null;
    Course?: CourseCreateNestedOneWithoutReviewInput;
  };

  export type ReviewUncheckedCreateWithoutUserInput = {
    idReview?: number;
    idCourse?: number | null;
    rating?: number | null;
    review?: string | null;
  };

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput;
    create: XOR<
      ReviewCreateWithoutUserInput,
      ReviewUncheckedCreateWithoutUserInput
    >;
  };

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type StudyRemindCreateWithoutUserInput = {
    timeRemind?: Date | string | null;
    typeRemind?: string | null;
    Course?: CourseCreateNestedOneWithoutStudyRemindInput;
  };

  export type StudyRemindUncheckedCreateWithoutUserInput = {
    idStudyRemind?: number;
    idCourse?: number | null;
    timeRemind?: Date | string | null;
    typeRemind?: string | null;
  };

  export type StudyRemindCreateOrConnectWithoutUserInput = {
    where: StudyRemindWhereUniqueInput;
    create: XOR<
      StudyRemindCreateWithoutUserInput,
      StudyRemindUncheckedCreateWithoutUserInput
    >;
  };

  export type StudyRemindCreateManyUserInputEnvelope = {
    data: StudyRemindCreateManyUserInput | StudyRemindCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type UserCertificateCreateWithoutUserInput = {
    Certificate: CertificateCreateNestedOneWithoutUserCertificateInput;
  };

  export type UserCertificateUncheckedCreateWithoutUserInput = {
    idCourse: number;
  };

  export type UserCertificateCreateOrConnectWithoutUserInput = {
    where: UserCertificateWhereUniqueInput;
    create: XOR<
      UserCertificateCreateWithoutUserInput,
      UserCertificateUncheckedCreateWithoutUserInput
    >;
  };

  export type UserCertificateCreateManyUserInputEnvelope = {
    data:
      | UserCertificateCreateManyUserInput
      | UserCertificateCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type UserCouponCreateWithoutUserInput = {
    Coupon: CouponCreateNestedOneWithoutUserCouponInput;
  };

  export type UserCouponUncheckedCreateWithoutUserInput = {
    idCoupon: number;
  };

  export type UserCouponCreateOrConnectWithoutUserInput = {
    where: UserCouponWhereUniqueInput;
    create: XOR<
      UserCouponCreateWithoutUserInput,
      UserCouponUncheckedCreateWithoutUserInput
    >;
  };

  export type UserCouponCreateManyUserInputEnvelope = {
    data: UserCouponCreateManyUserInput | UserCouponCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type WishlistCreateWithoutUserInput = {
    Course: CourseCreateNestedOneWithoutWishlistInput;
  };

  export type WishlistUncheckedCreateWithoutUserInput = {
    idCourse: number;
  };

  export type WishlistCreateOrConnectWithoutUserInput = {
    where: WishlistWhereUniqueInput;
    create: XOR<
      WishlistCreateWithoutUserInput,
      WishlistUncheckedCreateWithoutUserInput
    >;
  };

  export type WishlistCreateManyUserInputEnvelope = {
    data: WishlistCreateManyUserInput | WishlistCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type AnswerUpsertWithWhereUniqueWithoutUserInput = {
    where: AnswerWhereUniqueInput;
    update: XOR<
      AnswerUpdateWithoutUserInput,
      AnswerUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      AnswerCreateWithoutUserInput,
      AnswerUncheckedCreateWithoutUserInput
    >;
  };

  export type AnswerUpdateWithWhereUniqueWithoutUserInput = {
    where: AnswerWhereUniqueInput;
    data: XOR<
      AnswerUpdateWithoutUserInput,
      AnswerUncheckedUpdateWithoutUserInput
    >;
  };

  export type AnswerUpdateManyWithWhereWithoutUserInput = {
    where: AnswerScalarWhereInput;
    data: XOR<
      AnswerUpdateManyMutationInput,
      AnswerUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type CartUpsertWithWhereUniqueWithoutUserInput = {
    where: CartWhereUniqueInput;
    update: XOR<
      CartUpdateWithoutUserInput,
      CartUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      CartCreateWithoutUserInput,
      CartUncheckedCreateWithoutUserInput
    >;
  };

  export type CartUpdateWithWhereUniqueWithoutUserInput = {
    where: CartWhereUniqueInput;
    data: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>;
  };

  export type CartUpdateManyWithWhereWithoutUserInput = {
    where: CartScalarWhereInput;
    data: XOR<
      CartUpdateManyMutationInput,
      CartUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type CouponUpsertWithWhereUniqueWithoutUserInput = {
    where: CouponWhereUniqueInput;
    update: XOR<
      CouponUpdateWithoutUserInput,
      CouponUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      CouponCreateWithoutUserInput,
      CouponUncheckedCreateWithoutUserInput
    >;
  };

  export type CouponUpdateWithWhereUniqueWithoutUserInput = {
    where: CouponWhereUniqueInput;
    data: XOR<
      CouponUpdateWithoutUserInput,
      CouponUncheckedUpdateWithoutUserInput
    >;
  };

  export type CouponUpdateManyWithWhereWithoutUserInput = {
    where: CouponScalarWhereInput;
    data: XOR<
      CouponUpdateManyMutationInput,
      CouponUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type CouponScalarWhereInput = {
    AND?: CouponScalarWhereInput | CouponScalarWhereInput[];
    OR?: CouponScalarWhereInput[];
    NOT?: CouponScalarWhereInput | CouponScalarWhereInput[];
    idCoupon?: IntFilter<'Coupon'> | number;
    type?: StringNullableFilter<'Coupon'> | string | null;
    value?:
      | DecimalNullableFilter<'Coupon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    startDate?: DateTimeNullableFilter<'Coupon'> | Date | string | null;
    endDate?: DateTimeNullableFilter<'Coupon'> | Date | string | null;
    quantity?: IntNullableFilter<'Coupon'> | number | null;
    appliedAmount?: IntNullableFilter<'Coupon'> | number | null;
    minRequire?:
      | DecimalNullableFilter<'Coupon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxValueDiscount?:
      | DecimalNullableFilter<'Coupon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    code?: StringNullableFilter<'Coupon'> | string | null;
    idUser?: IntNullableFilter<'Coupon'> | number | null;
  };

  export type CourseUpsertWithWhereUniqueWithoutUserInput = {
    where: CourseWhereUniqueInput;
    update: XOR<
      CourseUpdateWithoutUserInput,
      CourseUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      CourseCreateWithoutUserInput,
      CourseUncheckedCreateWithoutUserInput
    >;
  };

  export type CourseUpdateWithWhereUniqueWithoutUserInput = {
    where: CourseWhereUniqueInput;
    data: XOR<
      CourseUpdateWithoutUserInput,
      CourseUncheckedUpdateWithoutUserInput
    >;
  };

  export type CourseUpdateManyWithWhereWithoutUserInput = {
    where: CourseScalarWhereInput;
    data: XOR<
      CourseUpdateManyMutationInput,
      CourseUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[];
    OR?: CourseScalarWhereInput[];
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[];
    idCourse?: IntFilter<'Course'> | number;
    idUser?: IntNullableFilter<'Course'> | number | null;
    title?: StringNullableFilter<'Course'> | string | null;
    subTitle?: StringNullableFilter<'Course'> | string | null;
    description?: StringNullableFilter<'Course'> | string | null;
    price?:
      | DecimalNullableFilter<'Course'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: BoolNullableFilter<'Course'> | boolean | null;
    isAccepted?: BoolNullableFilter<'Course'> | boolean | null;
    thumbnail?: StringNullableFilter<'Course'> | string | null;
    requirement?: StringNullableFilter<'Course'> | string | null;
    targetAudience?: StringNullableFilter<'Course'> | string | null;
  };

  export type EnrollmentUpsertWithWhereUniqueWithoutUserInput = {
    where: EnrollmentWhereUniqueInput;
    update: XOR<
      EnrollmentUpdateWithoutUserInput,
      EnrollmentUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      EnrollmentCreateWithoutUserInput,
      EnrollmentUncheckedCreateWithoutUserInput
    >;
  };

  export type EnrollmentUpdateWithWhereUniqueWithoutUserInput = {
    where: EnrollmentWhereUniqueInput;
    data: XOR<
      EnrollmentUpdateWithoutUserInput,
      EnrollmentUncheckedUpdateWithoutUserInput
    >;
  };

  export type EnrollmentUpdateManyWithWhereWithoutUserInput = {
    where: EnrollmentScalarWhereInput;
    data: XOR<
      EnrollmentUpdateManyMutationInput,
      EnrollmentUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type FollowUpsertWithWhereUniqueWithoutUser_Follow_idFollowerToUserInput =
    {
      where: FollowWhereUniqueInput;
      update: XOR<
        FollowUpdateWithoutUser_Follow_idFollowerToUserInput,
        FollowUncheckedUpdateWithoutUser_Follow_idFollowerToUserInput
      >;
      create: XOR<
        FollowCreateWithoutUser_Follow_idFollowerToUserInput,
        FollowUncheckedCreateWithoutUser_Follow_idFollowerToUserInput
      >;
    };

  export type FollowUpdateWithWhereUniqueWithoutUser_Follow_idFollowerToUserInput =
    {
      where: FollowWhereUniqueInput;
      data: XOR<
        FollowUpdateWithoutUser_Follow_idFollowerToUserInput,
        FollowUncheckedUpdateWithoutUser_Follow_idFollowerToUserInput
      >;
    };

  export type FollowUpdateManyWithWhereWithoutUser_Follow_idFollowerToUserInput =
    {
      where: FollowScalarWhereInput;
      data: XOR<
        FollowUpdateManyMutationInput,
        FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserInput
      >;
    };

  export type FollowScalarWhereInput = {
    AND?: FollowScalarWhereInput | FollowScalarWhereInput[];
    OR?: FollowScalarWhereInput[];
    NOT?: FollowScalarWhereInput | FollowScalarWhereInput[];
    idFollower?: IntFilter<'Follow'> | number;
    idFollowing?: IntFilter<'Follow'> | number;
  };

  export type FollowUpsertWithWhereUniqueWithoutUser_Follow_idFollowingToUserInput =
    {
      where: FollowWhereUniqueInput;
      update: XOR<
        FollowUpdateWithoutUser_Follow_idFollowingToUserInput,
        FollowUncheckedUpdateWithoutUser_Follow_idFollowingToUserInput
      >;
      create: XOR<
        FollowCreateWithoutUser_Follow_idFollowingToUserInput,
        FollowUncheckedCreateWithoutUser_Follow_idFollowingToUserInput
      >;
    };

  export type FollowUpdateWithWhereUniqueWithoutUser_Follow_idFollowingToUserInput =
    {
      where: FollowWhereUniqueInput;
      data: XOR<
        FollowUpdateWithoutUser_Follow_idFollowingToUserInput,
        FollowUncheckedUpdateWithoutUser_Follow_idFollowingToUserInput
      >;
    };

  export type FollowUpdateManyWithWhereWithoutUser_Follow_idFollowingToUserInput =
    {
      where: FollowScalarWhereInput;
      data: XOR<
        FollowUpdateManyMutationInput,
        FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserInput
      >;
    };

  export type MessageUpsertWithWhereUniqueWithoutUser_Message_idUserReceiverToUserInput =
    {
      where: MessageWhereUniqueInput;
      update: XOR<
        MessageUpdateWithoutUser_Message_idUserReceiverToUserInput,
        MessageUncheckedUpdateWithoutUser_Message_idUserReceiverToUserInput
      >;
      create: XOR<
        MessageCreateWithoutUser_Message_idUserReceiverToUserInput,
        MessageUncheckedCreateWithoutUser_Message_idUserReceiverToUserInput
      >;
    };

  export type MessageUpdateWithWhereUniqueWithoutUser_Message_idUserReceiverToUserInput =
    {
      where: MessageWhereUniqueInput;
      data: XOR<
        MessageUpdateWithoutUser_Message_idUserReceiverToUserInput,
        MessageUncheckedUpdateWithoutUser_Message_idUserReceiverToUserInput
      >;
    };

  export type MessageUpdateManyWithWhereWithoutUser_Message_idUserReceiverToUserInput =
    {
      where: MessageScalarWhereInput;
      data: XOR<
        MessageUpdateManyMutationInput,
        MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserInput
      >;
    };

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[];
    OR?: MessageScalarWhereInput[];
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[];
    idMessage?: IntFilter<'Message'> | number;
    idUserSender?: IntNullableFilter<'Message'> | number | null;
    idUserReceiver?: IntNullableFilter<'Message'> | number | null;
    message?: StringNullableFilter<'Message'> | string | null;
    timeSend?: DateTimeNullableFilter<'Message'> | Date | string | null;
  };

  export type MessageUpsertWithWhereUniqueWithoutUser_Message_idUserSenderToUserInput =
    {
      where: MessageWhereUniqueInput;
      update: XOR<
        MessageUpdateWithoutUser_Message_idUserSenderToUserInput,
        MessageUncheckedUpdateWithoutUser_Message_idUserSenderToUserInput
      >;
      create: XOR<
        MessageCreateWithoutUser_Message_idUserSenderToUserInput,
        MessageUncheckedCreateWithoutUser_Message_idUserSenderToUserInput
      >;
    };

  export type MessageUpdateWithWhereUniqueWithoutUser_Message_idUserSenderToUserInput =
    {
      where: MessageWhereUniqueInput;
      data: XOR<
        MessageUpdateWithoutUser_Message_idUserSenderToUserInput,
        MessageUncheckedUpdateWithoutUser_Message_idUserSenderToUserInput
      >;
    };

  export type MessageUpdateManyWithWhereWithoutUser_Message_idUserSenderToUserInput =
    {
      where: MessageScalarWhereInput;
      data: XOR<
        MessageUpdateManyMutationInput,
        MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserInput
      >;
    };

  export type NoteUpsertWithWhereUniqueWithoutUserInput = {
    where: NoteWhereUniqueInput;
    update: XOR<
      NoteUpdateWithoutUserInput,
      NoteUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      NoteCreateWithoutUserInput,
      NoteUncheckedCreateWithoutUserInput
    >;
  };

  export type NoteUpdateWithWhereUniqueWithoutUserInput = {
    where: NoteWhereUniqueInput;
    data: XOR<NoteUpdateWithoutUserInput, NoteUncheckedUpdateWithoutUserInput>;
  };

  export type NoteUpdateManyWithWhereWithoutUserInput = {
    where: NoteScalarWhereInput;
    data: XOR<
      NoteUpdateManyMutationInput,
      NoteUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    update: XOR<
      NotificationUpdateWithoutUserInput,
      NotificationUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      NotificationCreateWithoutUserInput,
      NotificationUncheckedCreateWithoutUserInput
    >;
  };

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    data: XOR<
      NotificationUpdateWithoutUserInput,
      NotificationUncheckedUpdateWithoutUserInput
    >;
  };

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput;
    data: XOR<
      NotificationUpdateManyMutationInput,
      NotificationUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    OR?: NotificationScalarWhereInput[];
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    idNotification?: IntFilter<'Notification'> | number;
    contentNotification?: StringNullableFilter<'Notification'> | string | null;
    idUser?: IntNullableFilter<'Notification'> | number | null;
  };

  export type NotificationReceiverUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationReceiverWhereUniqueInput;
    update: XOR<
      NotificationReceiverUpdateWithoutUserInput,
      NotificationReceiverUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      NotificationReceiverCreateWithoutUserInput,
      NotificationReceiverUncheckedCreateWithoutUserInput
    >;
  };

  export type NotificationReceiverUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationReceiverWhereUniqueInput;
    data: XOR<
      NotificationReceiverUpdateWithoutUserInput,
      NotificationReceiverUncheckedUpdateWithoutUserInput
    >;
  };

  export type NotificationReceiverUpdateManyWithWhereWithoutUserInput = {
    where: NotificationReceiverScalarWhereInput;
    data: XOR<
      NotificationReceiverUpdateManyMutationInput,
      NotificationReceiverUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput;
    update: XOR<
      PaymentUpdateWithoutUserInput,
      PaymentUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      PaymentCreateWithoutUserInput,
      PaymentUncheckedCreateWithoutUserInput
    >;
  };

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput;
    data: XOR<
      PaymentUpdateWithoutUserInput,
      PaymentUncheckedUpdateWithoutUserInput
    >;
  };

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput;
    data: XOR<
      PaymentUpdateManyMutationInput,
      PaymentUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
    OR?: PaymentScalarWhereInput[];
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
    idPayment?: IntFilter<'Payment'> | number;
    timePayment?: DateTimeNullableFilter<'Payment'> | Date | string | null;
    totalPrice?:
      | DecimalNullableFilter<'Payment'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    idUser?: IntNullableFilter<'Payment'> | number | null;
  };

  export type QuestionUpsertWithWhereUniqueWithoutUserInput = {
    where: QuestionWhereUniqueInput;
    update: XOR<
      QuestionUpdateWithoutUserInput,
      QuestionUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      QuestionCreateWithoutUserInput,
      QuestionUncheckedCreateWithoutUserInput
    >;
  };

  export type QuestionUpdateWithWhereUniqueWithoutUserInput = {
    where: QuestionWhereUniqueInput;
    data: XOR<
      QuestionUpdateWithoutUserInput,
      QuestionUncheckedUpdateWithoutUserInput
    >;
  };

  export type QuestionUpdateManyWithWhereWithoutUserInput = {
    where: QuestionScalarWhereInput;
    data: XOR<
      QuestionUpdateManyMutationInput,
      QuestionUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type ReportUpsertWithWhereUniqueWithoutUserInput = {
    where: ReportWhereUniqueInput;
    update: XOR<
      ReportUpdateWithoutUserInput,
      ReportUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      ReportCreateWithoutUserInput,
      ReportUncheckedCreateWithoutUserInput
    >;
  };

  export type ReportUpdateWithWhereUniqueWithoutUserInput = {
    where: ReportWhereUniqueInput;
    data: XOR<
      ReportUpdateWithoutUserInput,
      ReportUncheckedUpdateWithoutUserInput
    >;
  };

  export type ReportUpdateManyWithWhereWithoutUserInput = {
    where: ReportScalarWhereInput;
    data: XOR<
      ReportUpdateManyMutationInput,
      ReportUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[];
    OR?: ReportScalarWhereInput[];
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[];
    idReport?: IntFilter<'Report'> | number;
    idUser?: IntNullableFilter<'Report'> | number | null;
    contentReport?: StringNullableFilter<'Report'> | string | null;
  };

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput;
    update: XOR<
      ReviewUpdateWithoutUserInput,
      ReviewUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      ReviewCreateWithoutUserInput,
      ReviewUncheckedCreateWithoutUserInput
    >;
  };

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput;
    data: XOR<
      ReviewUpdateWithoutUserInput,
      ReviewUncheckedUpdateWithoutUserInput
    >;
  };

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput;
    data: XOR<
      ReviewUpdateManyMutationInput,
      ReviewUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type StudyRemindUpsertWithWhereUniqueWithoutUserInput = {
    where: StudyRemindWhereUniqueInput;
    update: XOR<
      StudyRemindUpdateWithoutUserInput,
      StudyRemindUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      StudyRemindCreateWithoutUserInput,
      StudyRemindUncheckedCreateWithoutUserInput
    >;
  };

  export type StudyRemindUpdateWithWhereUniqueWithoutUserInput = {
    where: StudyRemindWhereUniqueInput;
    data: XOR<
      StudyRemindUpdateWithoutUserInput,
      StudyRemindUncheckedUpdateWithoutUserInput
    >;
  };

  export type StudyRemindUpdateManyWithWhereWithoutUserInput = {
    where: StudyRemindScalarWhereInput;
    data: XOR<
      StudyRemindUpdateManyMutationInput,
      StudyRemindUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type UserCertificateUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCertificateWhereUniqueInput;
    update: XOR<
      UserCertificateUpdateWithoutUserInput,
      UserCertificateUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      UserCertificateCreateWithoutUserInput,
      UserCertificateUncheckedCreateWithoutUserInput
    >;
  };

  export type UserCertificateUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCertificateWhereUniqueInput;
    data: XOR<
      UserCertificateUpdateWithoutUserInput,
      UserCertificateUncheckedUpdateWithoutUserInput
    >;
  };

  export type UserCertificateUpdateManyWithWhereWithoutUserInput = {
    where: UserCertificateScalarWhereInput;
    data: XOR<
      UserCertificateUpdateManyMutationInput,
      UserCertificateUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type UserCouponUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCouponWhereUniqueInput;
    update: XOR<
      UserCouponUpdateWithoutUserInput,
      UserCouponUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      UserCouponCreateWithoutUserInput,
      UserCouponUncheckedCreateWithoutUserInput
    >;
  };

  export type UserCouponUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCouponWhereUniqueInput;
    data: XOR<
      UserCouponUpdateWithoutUserInput,
      UserCouponUncheckedUpdateWithoutUserInput
    >;
  };

  export type UserCouponUpdateManyWithWhereWithoutUserInput = {
    where: UserCouponScalarWhereInput;
    data: XOR<
      UserCouponUpdateManyMutationInput,
      UserCouponUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type WishlistUpsertWithWhereUniqueWithoutUserInput = {
    where: WishlistWhereUniqueInput;
    update: XOR<
      WishlistUpdateWithoutUserInput,
      WishlistUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      WishlistCreateWithoutUserInput,
      WishlistUncheckedCreateWithoutUserInput
    >;
  };

  export type WishlistUpdateWithWhereUniqueWithoutUserInput = {
    where: WishlistWhereUniqueInput;
    data: XOR<
      WishlistUpdateWithoutUserInput,
      WishlistUncheckedUpdateWithoutUserInput
    >;
  };

  export type WishlistUpdateManyWithWhereWithoutUserInput = {
    where: WishlistScalarWhereInput;
    data: XOR<
      WishlistUpdateManyMutationInput,
      WishlistUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type CertificateCreateWithoutUserCertificateInput = {
    certificate?: string | null;
    Course: CourseCreateNestedOneWithoutCertificateInput;
  };

  export type CertificateUncheckedCreateWithoutUserCertificateInput = {
    idCourse: number;
    certificate?: string | null;
  };

  export type CertificateCreateOrConnectWithoutUserCertificateInput = {
    where: CertificateWhereUniqueInput;
    create: XOR<
      CertificateCreateWithoutUserCertificateInput,
      CertificateUncheckedCreateWithoutUserCertificateInput
    >;
  };

  export type UserCreateWithoutUserCertificateInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutUserCertificateInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
    Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
    Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutUserCertificateInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutUserCertificateInput,
      UserUncheckedCreateWithoutUserCertificateInput
    >;
  };

  export type CertificateUpsertWithoutUserCertificateInput = {
    update: XOR<
      CertificateUpdateWithoutUserCertificateInput,
      CertificateUncheckedUpdateWithoutUserCertificateInput
    >;
    create: XOR<
      CertificateCreateWithoutUserCertificateInput,
      CertificateUncheckedCreateWithoutUserCertificateInput
    >;
    where?: CertificateWhereInput;
  };

  export type CertificateUpdateToOneWithWhereWithoutUserCertificateInput = {
    where?: CertificateWhereInput;
    data: XOR<
      CertificateUpdateWithoutUserCertificateInput,
      CertificateUncheckedUpdateWithoutUserCertificateInput
    >;
  };

  export type CertificateUpdateWithoutUserCertificateInput = {
    certificate?: NullableStringFieldUpdateOperationsInput | string | null;
    Course?: CourseUpdateOneRequiredWithoutCertificateNestedInput;
  };

  export type CertificateUncheckedUpdateWithoutUserCertificateInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    certificate?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UserUpsertWithoutUserCertificateInput = {
    update: XOR<
      UserUpdateWithoutUserCertificateInput,
      UserUncheckedUpdateWithoutUserCertificateInput
    >;
    create: XOR<
      UserCreateWithoutUserCertificateInput,
      UserUncheckedCreateWithoutUserCertificateInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutUserCertificateInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutUserCertificateInput,
      UserUncheckedUpdateWithoutUserCertificateInput
    >;
  };

  export type UserUpdateWithoutUserCertificateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutUserCertificateInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
    Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type CouponCreateWithoutUserCouponInput = {
    type?: string | null;
    value?: Decimal | DecimalJsLike | number | string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    quantity?: number | null;
    appliedAmount?: number | null;
    minRequire?: Decimal | DecimalJsLike | number | string | null;
    maxValueDiscount?: Decimal | DecimalJsLike | number | string | null;
    code?: string | null;
    User?: UserCreateNestedOneWithoutCouponInput;
    CouponCourse?: CouponCourseCreateNestedManyWithoutCouponInput;
  };

  export type CouponUncheckedCreateWithoutUserCouponInput = {
    idCoupon?: number;
    type?: string | null;
    value?: Decimal | DecimalJsLike | number | string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    quantity?: number | null;
    appliedAmount?: number | null;
    minRequire?: Decimal | DecimalJsLike | number | string | null;
    maxValueDiscount?: Decimal | DecimalJsLike | number | string | null;
    code?: string | null;
    idUser?: number | null;
    CouponCourse?: CouponCourseUncheckedCreateNestedManyWithoutCouponInput;
  };

  export type CouponCreateOrConnectWithoutUserCouponInput = {
    where: CouponWhereUniqueInput;
    create: XOR<
      CouponCreateWithoutUserCouponInput,
      CouponUncheckedCreateWithoutUserCouponInput
    >;
  };

  export type UserCreateWithoutUserCouponInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutUserCouponInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
    Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
    Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutUserCouponInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutUserCouponInput,
      UserUncheckedCreateWithoutUserCouponInput
    >;
  };

  export type CouponUpsertWithoutUserCouponInput = {
    update: XOR<
      CouponUpdateWithoutUserCouponInput,
      CouponUncheckedUpdateWithoutUserCouponInput
    >;
    create: XOR<
      CouponCreateWithoutUserCouponInput,
      CouponUncheckedCreateWithoutUserCouponInput
    >;
    where?: CouponWhereInput;
  };

  export type CouponUpdateToOneWithWhereWithoutUserCouponInput = {
    where?: CouponWhereInput;
    data: XOR<
      CouponUpdateWithoutUserCouponInput,
      CouponUncheckedUpdateWithoutUserCouponInput
    >;
  };

  export type CouponUpdateWithoutUserCouponInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    quantity?: NullableIntFieldUpdateOperationsInput | number | null;
    appliedAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    minRequire?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxValueDiscount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    code?: NullableStringFieldUpdateOperationsInput | string | null;
    User?: UserUpdateOneWithoutCouponNestedInput;
    CouponCourse?: CouponCourseUpdateManyWithoutCouponNestedInput;
  };

  export type CouponUncheckedUpdateWithoutUserCouponInput = {
    idCoupon?: IntFieldUpdateOperationsInput | number;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    quantity?: NullableIntFieldUpdateOperationsInput | number | null;
    appliedAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    minRequire?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxValueDiscount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    code?: NullableStringFieldUpdateOperationsInput | string | null;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    CouponCourse?: CouponCourseUncheckedUpdateManyWithoutCouponNestedInput;
  };

  export type UserUpsertWithoutUserCouponInput = {
    update: XOR<
      UserUpdateWithoutUserCouponInput,
      UserUncheckedUpdateWithoutUserCouponInput
    >;
    create: XOR<
      UserCreateWithoutUserCouponInput,
      UserUncheckedCreateWithoutUserCouponInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutUserCouponInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutUserCouponInput,
      UserUncheckedUpdateWithoutUserCouponInput
    >;
  };

  export type UserUpdateWithoutUserCouponInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutUserCouponInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
    Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type CourseCreateWithoutWishlistInput = {
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseCreateNestedManyWithoutCourseInput;
    User?: UserCreateNestedOneWithoutCourseInput;
    CourseCategory?: CourseCategoryCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailCreateNestedManyWithoutCourseInput;
    Review?: ReviewCreateNestedManyWithoutCourseInput;
    Section?: SectionCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutCourseInput;
  };

  export type CourseUncheckedCreateWithoutWishlistInput = {
    idCourse?: number;
    idUser?: number | null;
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
    Cart?: CartUncheckedCreateNestedManyWithoutCourseInput;
    Certificate?: CertificateUncheckedCreateNestedOneWithoutCourseInput;
    CouponCourse?: CouponCourseUncheckedCreateNestedManyWithoutCourseInput;
    CourseCategory?: CourseCategoryUncheckedCreateNestedManyWithoutCourseInput;
    CourseObjective?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput;
    PaymentDetail?: PaymentDetailUncheckedCreateNestedManyWithoutCourseInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutCourseInput;
    Section?: SectionUncheckedCreateNestedManyWithoutCourseInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutCourseInput;
  };

  export type CourseCreateOrConnectWithoutWishlistInput = {
    where: CourseWhereUniqueInput;
    create: XOR<
      CourseCreateWithoutWishlistInput,
      CourseUncheckedCreateWithoutWishlistInput
    >;
  };

  export type UserCreateWithoutWishlistInput = {
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerCreateNestedManyWithoutUserInput;
    Cart?: CartCreateNestedManyWithoutUserInput;
    Coupon?: CouponCreateNestedManyWithoutUserInput;
    Course?: CourseCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Question?: QuestionCreateNestedManyWithoutUserInput;
    Report?: ReportCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutWishlistInput = {
    idUser?: number;
    name?: string | null;
    biography?: string | null;
    role?: string | null;
    gender?: string | null;
    birthday?: Date | string | null;
    codeExpired?: string | null;
    codeId?: string | null;
    email?: string | null;
    password?: string | null;
    Answer?: AnswerUncheckedCreateNestedManyWithoutUserInput;
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput;
    Coupon?: CouponUncheckedCreateNestedManyWithoutUserInput;
    Course?: CourseUncheckedCreateNestedManyWithoutUserInput;
    Enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowerToUserInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedCreateNestedManyWithoutUser_Follow_idFollowingToUserInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserReceiverToUserInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_idUserSenderToUserInput;
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    NotificationReceiver?: NotificationReceiverUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Question?: QuestionUncheckedCreateNestedManyWithoutUserInput;
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    StudyRemind?: StudyRemindUncheckedCreateNestedManyWithoutUserInput;
    UserCertificate?: UserCertificateUncheckedCreateNestedManyWithoutUserInput;
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutWishlistInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutWishlistInput,
      UserUncheckedCreateWithoutWishlistInput
    >;
  };

  export type CourseUpsertWithoutWishlistInput = {
    update: XOR<
      CourseUpdateWithoutWishlistInput,
      CourseUncheckedUpdateWithoutWishlistInput
    >;
    create: XOR<
      CourseCreateWithoutWishlistInput,
      CourseUncheckedCreateWithoutWishlistInput
    >;
    where?: CourseWhereInput;
  };

  export type CourseUpdateToOneWithWhereWithoutWishlistInput = {
    where?: CourseWhereInput;
    data: XOR<
      CourseUpdateWithoutWishlistInput,
      CourseUncheckedUpdateWithoutWishlistInput
    >;
  };

  export type CourseUpdateWithoutWishlistInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUpdateManyWithoutCourseNestedInput;
    User?: UserUpdateOneWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUpdateManyWithoutCourseNestedInput;
    Section?: SectionUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutCourseNestedInput;
  };

  export type CourseUncheckedUpdateWithoutWishlistInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUncheckedUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUncheckedUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUncheckedUpdateManyWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUncheckedUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutCourseNestedInput;
    Section?: SectionUncheckedUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutCourseNestedInput;
  };

  export type UserUpsertWithoutWishlistInput = {
    update: XOR<
      UserUpdateWithoutWishlistInput,
      UserUncheckedUpdateWithoutWishlistInput
    >;
    create: XOR<
      UserCreateWithoutWishlistInput,
      UserUncheckedCreateWithoutWishlistInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutWishlistInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutWishlistInput,
      UserUncheckedUpdateWithoutWishlistInput
    >;
  };

  export type UserUpdateWithoutWishlistInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutUserNestedInput;
    Cart?: CartUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUpdateManyWithoutUserNestedInput;
    Course?: CourseUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Question?: QuestionUpdateManyWithoutUserNestedInput;
    Report?: ReportUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutWishlistInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    biography?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableStringFieldUpdateOperationsInput | string | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    birthday?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    codeExpired?: NullableStringFieldUpdateOperationsInput | string | null;
    codeId?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutUserNestedInput;
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput;
    Coupon?: CouponUncheckedUpdateManyWithoutUserNestedInput;
    Course?: CourseUncheckedUpdateManyWithoutUserNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput;
    Follow_Follow_idFollowerToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserNestedInput;
    Follow_Follow_idFollowingToUser?: FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserNestedInput;
    Message_Message_idUserReceiverToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserNestedInput;
    Message_Message_idUserSenderToUser?: MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserNestedInput;
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutUserNestedInput;
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutUserNestedInput;
    UserCertificate?: UserCertificateUncheckedUpdateManyWithoutUserNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type CourseCategoryCreateManyCategoryInput = {
    idCourse: number;
  };

  export type CourseCategoryUpdateWithoutCategoryInput = {
    Course?: CourseUpdateOneRequiredWithoutCourseCategoryNestedInput;
  };

  export type CourseCategoryUncheckedUpdateWithoutCategoryInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
  };

  export type CourseCategoryUncheckedUpdateManyWithoutCategoryInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
  };

  export type UserCertificateCreateManyCertificateInput = {
    idUser: number;
  };

  export type UserCertificateUpdateWithoutCertificateInput = {
    User?: UserUpdateOneRequiredWithoutUserCertificateNestedInput;
  };

  export type UserCertificateUncheckedUpdateWithoutCertificateInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
  };

  export type UserCertificateUncheckedUpdateManyWithoutCertificateInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
  };

  export type CouponCourseCreateManyCouponInput = {
    idCourse: number;
  };

  export type UserCouponCreateManyCouponInput = {
    idUser: number;
  };

  export type CouponCourseUpdateWithoutCouponInput = {
    Course?: CourseUpdateOneRequiredWithoutCouponCourseNestedInput;
  };

  export type CouponCourseUncheckedUpdateWithoutCouponInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
  };

  export type CouponCourseUncheckedUpdateManyWithoutCouponInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
  };

  export type UserCouponUpdateWithoutCouponInput = {
    User?: UserUpdateOneRequiredWithoutUserCouponNestedInput;
  };

  export type UserCouponUncheckedUpdateWithoutCouponInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
  };

  export type UserCouponUncheckedUpdateManyWithoutCouponInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
  };

  export type CartCreateManyCourseInput = {
    idUser: number;
  };

  export type CouponCourseCreateManyCourseInput = {
    idCoupon: number;
  };

  export type CourseCategoryCreateManyCourseInput = {
    idCategory: number;
  };

  export type CourseObjectiveCreateManyCourseInput = {
    idCourseObjective: number;
    content?: string | null;
  };

  export type EnrollmentCreateManyCourseInput = {
    idUser: number;
    dateRegister?: Date | string | null;
    finishStatus?: boolean | null;
    progress?: Decimal | DecimalJsLike | number | string | null;
  };

  export type PaymentDetailCreateManyCourseInput = {
    idPayment: number;
    price?: Decimal | DecimalJsLike | number | string | null;
  };

  export type ReviewCreateManyCourseInput = {
    idReview?: number;
    idUser?: number | null;
    rating?: number | null;
    review?: string | null;
  };

  export type SectionCreateManyCourseInput = {
    idSection: number;
    nameSection?: string | null;
  };

  export type StudyRemindCreateManyCourseInput = {
    idStudyRemind?: number;
    idUser?: number | null;
    timeRemind?: Date | string | null;
    typeRemind?: string | null;
  };

  export type WishlistCreateManyCourseInput = {
    idUser: number;
  };

  export type CartUpdateWithoutCourseInput = {
    User?: UserUpdateOneRequiredWithoutCartNestedInput;
  };

  export type CartUncheckedUpdateWithoutCourseInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
  };

  export type CartUncheckedUpdateManyWithoutCourseInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
  };

  export type CouponCourseUpdateWithoutCourseInput = {
    Coupon?: CouponUpdateOneRequiredWithoutCouponCourseNestedInput;
  };

  export type CouponCourseUncheckedUpdateWithoutCourseInput = {
    idCoupon?: IntFieldUpdateOperationsInput | number;
  };

  export type CouponCourseUncheckedUpdateManyWithoutCourseInput = {
    idCoupon?: IntFieldUpdateOperationsInput | number;
  };

  export type CourseCategoryUpdateWithoutCourseInput = {
    Category?: CategoryUpdateOneRequiredWithoutCourseCategoryNestedInput;
  };

  export type CourseCategoryUncheckedUpdateWithoutCourseInput = {
    idCategory?: IntFieldUpdateOperationsInput | number;
  };

  export type CourseCategoryUncheckedUpdateManyWithoutCourseInput = {
    idCategory?: IntFieldUpdateOperationsInput | number;
  };

  export type CourseObjectiveUpdateWithoutCourseInput = {
    idCourseObjective?: IntFieldUpdateOperationsInput | number;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CourseObjectiveUncheckedUpdateWithoutCourseInput = {
    idCourseObjective?: IntFieldUpdateOperationsInput | number;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CourseObjectiveUncheckedUpdateManyWithoutCourseInput = {
    idCourseObjective?: IntFieldUpdateOperationsInput | number;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type EnrollmentUpdateWithoutCourseInput = {
    dateRegister?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    finishStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    progress?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    User?: UserUpdateOneRequiredWithoutEnrollmentNestedInput;
  };

  export type EnrollmentUncheckedUpdateWithoutCourseInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    dateRegister?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    finishStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    progress?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type EnrollmentUncheckedUpdateManyWithoutCourseInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    dateRegister?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    finishStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    progress?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type PaymentDetailUpdateWithoutCourseInput = {
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    Payment?: PaymentUpdateOneRequiredWithoutPaymentDetailNestedInput;
  };

  export type PaymentDetailUncheckedUpdateWithoutCourseInput = {
    idPayment?: IntFieldUpdateOperationsInput | number;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type PaymentDetailUncheckedUpdateManyWithoutCourseInput = {
    idPayment?: IntFieldUpdateOperationsInput | number;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type ReviewUpdateWithoutCourseInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null;
    review?: NullableStringFieldUpdateOperationsInput | string | null;
    User?: UserUpdateOneWithoutReviewNestedInput;
  };

  export type ReviewUncheckedUpdateWithoutCourseInput = {
    idReview?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    rating?: NullableIntFieldUpdateOperationsInput | number | null;
    review?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ReviewUncheckedUpdateManyWithoutCourseInput = {
    idReview?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    rating?: NullableIntFieldUpdateOperationsInput | number | null;
    review?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SectionUpdateWithoutCourseInput = {
    idSection?: IntFieldUpdateOperationsInput | number;
    nameSection?: NullableStringFieldUpdateOperationsInput | string | null;
    Lecture?: LectureUpdateManyWithoutSectionNestedInput;
  };

  export type SectionUncheckedUpdateWithoutCourseInput = {
    idSection?: IntFieldUpdateOperationsInput | number;
    nameSection?: NullableStringFieldUpdateOperationsInput | string | null;
    Lecture?: LectureUncheckedUpdateManyWithoutSectionNestedInput;
  };

  export type SectionUncheckedUpdateManyWithoutCourseInput = {
    idSection?: IntFieldUpdateOperationsInput | number;
    nameSection?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type StudyRemindUpdateWithoutCourseInput = {
    timeRemind?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    typeRemind?: NullableStringFieldUpdateOperationsInput | string | null;
    User?: UserUpdateOneWithoutStudyRemindNestedInput;
  };

  export type StudyRemindUncheckedUpdateWithoutCourseInput = {
    idStudyRemind?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    timeRemind?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    typeRemind?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type StudyRemindUncheckedUpdateManyWithoutCourseInput = {
    idStudyRemind?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    timeRemind?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    typeRemind?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type WishlistUpdateWithoutCourseInput = {
    User?: UserUpdateOneRequiredWithoutWishlistNestedInput;
  };

  export type WishlistUncheckedUpdateWithoutCourseInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
  };

  export type WishlistUncheckedUpdateManyWithoutCourseInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
  };

  export type NoteCreateManyLectureInput = {
    idNote?: number;
    timeNote?: Date | string | null;
    note?: string | null;
    idUser?: number | null;
  };

  export type QuestionCreateManyLectureInput = {
    idQuestion?: number;
    idUser?: number | null;
    contentQuestion?: string | null;
  };

  export type NoteUpdateWithoutLectureInput = {
    timeNote?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    note?: NullableStringFieldUpdateOperationsInput | string | null;
    User?: UserUpdateOneWithoutNoteNestedInput;
  };

  export type NoteUncheckedUpdateWithoutLectureInput = {
    idNote?: IntFieldUpdateOperationsInput | number;
    timeNote?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    note?: NullableStringFieldUpdateOperationsInput | string | null;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type NoteUncheckedUpdateManyWithoutLectureInput = {
    idNote?: IntFieldUpdateOperationsInput | number;
    timeNote?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    note?: NullableStringFieldUpdateOperationsInput | string | null;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type QuestionUpdateWithoutLectureInput = {
    contentQuestion?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutQuestionNestedInput;
    User?: UserUpdateOneWithoutQuestionNestedInput;
  };

  export type QuestionUncheckedUpdateWithoutLectureInput = {
    idQuestion?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    contentQuestion?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput;
  };

  export type QuestionUncheckedUpdateManyWithoutLectureInput = {
    idQuestion?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    contentQuestion?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type NotificationReceiverCreateManyNotificationInput = {
    idUser: number;
    timeGetNotification?: Date | string | null;
  };

  export type NotificationReceiverUpdateWithoutNotificationInput = {
    timeGetNotification?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    User?: UserUpdateOneRequiredWithoutNotificationReceiverNestedInput;
  };

  export type NotificationReceiverUncheckedUpdateWithoutNotificationInput = {
    idUser?: IntFieldUpdateOperationsInput | number;
    timeGetNotification?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type NotificationReceiverUncheckedUpdateManyWithoutNotificationInput =
    {
      idUser?: IntFieldUpdateOperationsInput | number;
      timeGetNotification?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
    };

  export type PaymentDetailCreateManyPaymentInput = {
    idCourse: number;
    price?: Decimal | DecimalJsLike | number | string | null;
  };

  export type PaymentDetailUpdateWithoutPaymentInput = {
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    Course?: CourseUpdateOneRequiredWithoutPaymentDetailNestedInput;
  };

  export type PaymentDetailUncheckedUpdateWithoutPaymentInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type PaymentDetailUncheckedUpdateManyWithoutPaymentInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type AnswerCreateManyQuestionInput = {
    idAnswer: number;
    idUser?: number | null;
    contentAnswer?: string | null;
  };

  export type AnswerUpdateWithoutQuestionInput = {
    idAnswer?: IntFieldUpdateOperationsInput | number;
    contentAnswer?: NullableStringFieldUpdateOperationsInput | string | null;
    User?: UserUpdateOneWithoutAnswerNestedInput;
  };

  export type AnswerUncheckedUpdateWithoutQuestionInput = {
    idAnswer?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    contentAnswer?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AnswerUncheckedUpdateManyWithoutQuestionInput = {
    idAnswer?: IntFieldUpdateOperationsInput | number;
    idUser?: NullableIntFieldUpdateOperationsInput | number | null;
    contentAnswer?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type LectureCreateManySectionInput = {
    idLecture: number;
    nameLecture?: string | null;
    isDone?: boolean | null;
  };

  export type LectureUpdateWithoutSectionInput = {
    idLecture?: IntFieldUpdateOperationsInput | number;
    nameLecture?: NullableStringFieldUpdateOperationsInput | string | null;
    isDone?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    Note?: NoteUpdateManyWithoutLectureNestedInput;
    Question?: QuestionUpdateManyWithoutLectureNestedInput;
  };

  export type LectureUncheckedUpdateWithoutSectionInput = {
    idLecture?: IntFieldUpdateOperationsInput | number;
    nameLecture?: NullableStringFieldUpdateOperationsInput | string | null;
    isDone?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    Note?: NoteUncheckedUpdateManyWithoutLectureNestedInput;
    Question?: QuestionUncheckedUpdateManyWithoutLectureNestedInput;
  };

  export type LectureUncheckedUpdateManyWithoutSectionInput = {
    idLecture?: IntFieldUpdateOperationsInput | number;
    nameLecture?: NullableStringFieldUpdateOperationsInput | string | null;
    isDone?: NullableBoolFieldUpdateOperationsInput | boolean | null;
  };

  export type AnswerCreateManyUserInput = {
    idQuestion: number;
    idAnswer: number;
    contentAnswer?: string | null;
  };

  export type CartCreateManyUserInput = {
    idCourse: number;
  };

  export type CouponCreateManyUserInput = {
    idCoupon?: number;
    type?: string | null;
    value?: Decimal | DecimalJsLike | number | string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    quantity?: number | null;
    appliedAmount?: number | null;
    minRequire?: Decimal | DecimalJsLike | number | string | null;
    maxValueDiscount?: Decimal | DecimalJsLike | number | string | null;
    code?: string | null;
  };

  export type CourseCreateManyUserInput = {
    idCourse?: number;
    title?: string | null;
    subTitle?: string | null;
    description?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    isPublic?: boolean | null;
    isAccepted?: boolean | null;
    thumbnail?: string | null;
    requirement?: string | null;
    targetAudience?: string | null;
  };

  export type EnrollmentCreateManyUserInput = {
    idCourse: number;
    dateRegister?: Date | string | null;
    finishStatus?: boolean | null;
    progress?: Decimal | DecimalJsLike | number | string | null;
  };

  export type FollowCreateManyUser_Follow_idFollowerToUserInput = {
    idFollowing: number;
  };

  export type FollowCreateManyUser_Follow_idFollowingToUserInput = {
    idFollower: number;
  };

  export type MessageCreateManyUser_Message_idUserReceiverToUserInput = {
    idMessage?: number;
    idUserSender?: number | null;
    message?: string | null;
    timeSend?: Date | string | null;
  };

  export type MessageCreateManyUser_Message_idUserSenderToUserInput = {
    idMessage?: number;
    idUserReceiver?: number | null;
    message?: string | null;
    timeSend?: Date | string | null;
  };

  export type NoteCreateManyUserInput = {
    idNote?: number;
    timeNote?: Date | string | null;
    note?: string | null;
    idCourse?: number | null;
    idSection?: number | null;
    idLecture?: number | null;
  };

  export type NotificationCreateManyUserInput = {
    idNotification?: number;
    contentNotification?: string | null;
  };

  export type NotificationReceiverCreateManyUserInput = {
    idNotification: number;
    timeGetNotification?: Date | string | null;
  };

  export type PaymentCreateManyUserInput = {
    idPayment?: number;
    timePayment?: Date | string | null;
    totalPrice?: Decimal | DecimalJsLike | number | string | null;
  };

  export type QuestionCreateManyUserInput = {
    idQuestion?: number;
    idCourse?: number | null;
    idSection?: number | null;
    idLecture?: number | null;
    contentQuestion?: string | null;
  };

  export type ReportCreateManyUserInput = {
    idReport?: number;
    contentReport?: string | null;
  };

  export type ReviewCreateManyUserInput = {
    idReview?: number;
    idCourse?: number | null;
    rating?: number | null;
    review?: string | null;
  };

  export type StudyRemindCreateManyUserInput = {
    idStudyRemind?: number;
    idCourse?: number | null;
    timeRemind?: Date | string | null;
    typeRemind?: string | null;
  };

  export type UserCertificateCreateManyUserInput = {
    idCourse: number;
  };

  export type UserCouponCreateManyUserInput = {
    idCoupon: number;
  };

  export type WishlistCreateManyUserInput = {
    idCourse: number;
  };

  export type AnswerUpdateWithoutUserInput = {
    idAnswer?: IntFieldUpdateOperationsInput | number;
    contentAnswer?: NullableStringFieldUpdateOperationsInput | string | null;
    Question?: QuestionUpdateOneRequiredWithoutAnswerNestedInput;
  };

  export type AnswerUncheckedUpdateWithoutUserInput = {
    idQuestion?: IntFieldUpdateOperationsInput | number;
    idAnswer?: IntFieldUpdateOperationsInput | number;
    contentAnswer?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AnswerUncheckedUpdateManyWithoutUserInput = {
    idQuestion?: IntFieldUpdateOperationsInput | number;
    idAnswer?: IntFieldUpdateOperationsInput | number;
    contentAnswer?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CartUpdateWithoutUserInput = {
    Course?: CourseUpdateOneRequiredWithoutCartNestedInput;
  };

  export type CartUncheckedUpdateWithoutUserInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
  };

  export type CartUncheckedUpdateManyWithoutUserInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
  };

  export type CouponUpdateWithoutUserInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    quantity?: NullableIntFieldUpdateOperationsInput | number | null;
    appliedAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    minRequire?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxValueDiscount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    code?: NullableStringFieldUpdateOperationsInput | string | null;
    CouponCourse?: CouponCourseUpdateManyWithoutCouponNestedInput;
    UserCoupon?: UserCouponUpdateManyWithoutCouponNestedInput;
  };

  export type CouponUncheckedUpdateWithoutUserInput = {
    idCoupon?: IntFieldUpdateOperationsInput | number;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    quantity?: NullableIntFieldUpdateOperationsInput | number | null;
    appliedAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    minRequire?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxValueDiscount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    code?: NullableStringFieldUpdateOperationsInput | string | null;
    CouponCourse?: CouponCourseUncheckedUpdateManyWithoutCouponNestedInput;
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutCouponNestedInput;
  };

  export type CouponUncheckedUpdateManyWithoutUserInput = {
    idCoupon?: IntFieldUpdateOperationsInput | number;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    quantity?: NullableIntFieldUpdateOperationsInput | number | null;
    appliedAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    minRequire?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxValueDiscount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    code?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CourseUpdateWithoutUserInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUpdateManyWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUpdateManyWithoutCourseNestedInput;
    Section?: SectionUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUpdateManyWithoutCourseNestedInput;
  };

  export type CourseUncheckedUpdateWithoutUserInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
    Cart?: CartUncheckedUpdateManyWithoutCourseNestedInput;
    Certificate?: CertificateUncheckedUpdateOneWithoutCourseNestedInput;
    CouponCourse?: CouponCourseUncheckedUpdateManyWithoutCourseNestedInput;
    CourseCategory?: CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput;
    CourseObjective?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput;
    Enrollment?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput;
    PaymentDetail?: PaymentDetailUncheckedUpdateManyWithoutCourseNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutCourseNestedInput;
    Section?: SectionUncheckedUpdateManyWithoutCourseNestedInput;
    StudyRemind?: StudyRemindUncheckedUpdateManyWithoutCourseNestedInput;
    Wishlist?: WishlistUncheckedUpdateManyWithoutCourseNestedInput;
  };

  export type CourseUncheckedUpdateManyWithoutUserInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    isPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    isAccepted?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null;
    requirement?: NullableStringFieldUpdateOperationsInput | string | null;
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type EnrollmentUpdateWithoutUserInput = {
    dateRegister?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    finishStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    progress?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    Course?: CourseUpdateOneRequiredWithoutEnrollmentNestedInput;
  };

  export type EnrollmentUncheckedUpdateWithoutUserInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    dateRegister?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    finishStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    progress?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type EnrollmentUncheckedUpdateManyWithoutUserInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
    dateRegister?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    finishStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    progress?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type FollowUpdateWithoutUser_Follow_idFollowerToUserInput = {
    User_Follow_idFollowingToUser?: UserUpdateOneRequiredWithoutFollow_Follow_idFollowingToUserNestedInput;
  };

  export type FollowUncheckedUpdateWithoutUser_Follow_idFollowerToUserInput = {
    idFollowing?: IntFieldUpdateOperationsInput | number;
  };

  export type FollowUncheckedUpdateManyWithoutUser_Follow_idFollowerToUserInput =
    {
      idFollowing?: IntFieldUpdateOperationsInput | number;
    };

  export type FollowUpdateWithoutUser_Follow_idFollowingToUserInput = {
    User_Follow_idFollowerToUser?: UserUpdateOneRequiredWithoutFollow_Follow_idFollowerToUserNestedInput;
  };

  export type FollowUncheckedUpdateWithoutUser_Follow_idFollowingToUserInput = {
    idFollower?: IntFieldUpdateOperationsInput | number;
  };

  export type FollowUncheckedUpdateManyWithoutUser_Follow_idFollowingToUserInput =
    {
      idFollower?: IntFieldUpdateOperationsInput | number;
    };

  export type MessageUpdateWithoutUser_Message_idUserReceiverToUserInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    timeSend?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    User_Message_idUserSenderToUser?: UserUpdateOneWithoutMessage_Message_idUserSenderToUserNestedInput;
  };

  export type MessageUncheckedUpdateWithoutUser_Message_idUserReceiverToUserInput =
    {
      idMessage?: IntFieldUpdateOperationsInput | number;
      idUserSender?: NullableIntFieldUpdateOperationsInput | number | null;
      message?: NullableStringFieldUpdateOperationsInput | string | null;
      timeSend?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
    };

  export type MessageUncheckedUpdateManyWithoutUser_Message_idUserReceiverToUserInput =
    {
      idMessage?: IntFieldUpdateOperationsInput | number;
      idUserSender?: NullableIntFieldUpdateOperationsInput | number | null;
      message?: NullableStringFieldUpdateOperationsInput | string | null;
      timeSend?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
    };

  export type MessageUpdateWithoutUser_Message_idUserSenderToUserInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    timeSend?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    User_Message_idUserReceiverToUser?: UserUpdateOneWithoutMessage_Message_idUserReceiverToUserNestedInput;
  };

  export type MessageUncheckedUpdateWithoutUser_Message_idUserSenderToUserInput =
    {
      idMessage?: IntFieldUpdateOperationsInput | number;
      idUserReceiver?: NullableIntFieldUpdateOperationsInput | number | null;
      message?: NullableStringFieldUpdateOperationsInput | string | null;
      timeSend?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
    };

  export type MessageUncheckedUpdateManyWithoutUser_Message_idUserSenderToUserInput =
    {
      idMessage?: IntFieldUpdateOperationsInput | number;
      idUserReceiver?: NullableIntFieldUpdateOperationsInput | number | null;
      message?: NullableStringFieldUpdateOperationsInput | string | null;
      timeSend?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
    };

  export type NoteUpdateWithoutUserInput = {
    timeNote?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    note?: NullableStringFieldUpdateOperationsInput | string | null;
    Lecture?: LectureUpdateOneWithoutNoteNestedInput;
  };

  export type NoteUncheckedUpdateWithoutUserInput = {
    idNote?: IntFieldUpdateOperationsInput | number;
    timeNote?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    note?: NullableStringFieldUpdateOperationsInput | string | null;
    idCourse?: NullableIntFieldUpdateOperationsInput | number | null;
    idSection?: NullableIntFieldUpdateOperationsInput | number | null;
    idLecture?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type NoteUncheckedUpdateManyWithoutUserInput = {
    idNote?: IntFieldUpdateOperationsInput | number;
    timeNote?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    note?: NullableStringFieldUpdateOperationsInput | string | null;
    idCourse?: NullableIntFieldUpdateOperationsInput | number | null;
    idSection?: NullableIntFieldUpdateOperationsInput | number | null;
    idLecture?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type NotificationUpdateWithoutUserInput = {
    contentNotification?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    NotificationReceiver?: NotificationReceiverUpdateManyWithoutNotificationNestedInput;
  };

  export type NotificationUncheckedUpdateWithoutUserInput = {
    idNotification?: IntFieldUpdateOperationsInput | number;
    contentNotification?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    NotificationReceiver?: NotificationReceiverUncheckedUpdateManyWithoutNotificationNestedInput;
  };

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    idNotification?: IntFieldUpdateOperationsInput | number;
    contentNotification?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
  };

  export type NotificationReceiverUpdateWithoutUserInput = {
    timeGetNotification?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Notification?: NotificationUpdateOneRequiredWithoutNotificationReceiverNestedInput;
  };

  export type NotificationReceiverUncheckedUpdateWithoutUserInput = {
    idNotification?: IntFieldUpdateOperationsInput | number;
    timeGetNotification?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type NotificationReceiverUncheckedUpdateManyWithoutUserInput = {
    idNotification?: IntFieldUpdateOperationsInput | number;
    timeGetNotification?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type PaymentUpdateWithoutUserInput = {
    timePayment?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    totalPrice?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    PaymentDetail?: PaymentDetailUpdateManyWithoutPaymentNestedInput;
  };

  export type PaymentUncheckedUpdateWithoutUserInput = {
    idPayment?: IntFieldUpdateOperationsInput | number;
    timePayment?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    totalPrice?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    PaymentDetail?: PaymentDetailUncheckedUpdateManyWithoutPaymentNestedInput;
  };

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    idPayment?: IntFieldUpdateOperationsInput | number;
    timePayment?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    totalPrice?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type QuestionUpdateWithoutUserInput = {
    contentQuestion?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUpdateManyWithoutQuestionNestedInput;
    Lecture?: LectureUpdateOneWithoutQuestionNestedInput;
  };

  export type QuestionUncheckedUpdateWithoutUserInput = {
    idQuestion?: IntFieldUpdateOperationsInput | number;
    idCourse?: NullableIntFieldUpdateOperationsInput | number | null;
    idSection?: NullableIntFieldUpdateOperationsInput | number | null;
    idLecture?: NullableIntFieldUpdateOperationsInput | number | null;
    contentQuestion?: NullableStringFieldUpdateOperationsInput | string | null;
    Answer?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput;
  };

  export type QuestionUncheckedUpdateManyWithoutUserInput = {
    idQuestion?: IntFieldUpdateOperationsInput | number;
    idCourse?: NullableIntFieldUpdateOperationsInput | number | null;
    idSection?: NullableIntFieldUpdateOperationsInput | number | null;
    idLecture?: NullableIntFieldUpdateOperationsInput | number | null;
    contentQuestion?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ReportUpdateWithoutUserInput = {
    contentReport?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ReportUncheckedUpdateWithoutUserInput = {
    idReport?: IntFieldUpdateOperationsInput | number;
    contentReport?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ReportUncheckedUpdateManyWithoutUserInput = {
    idReport?: IntFieldUpdateOperationsInput | number;
    contentReport?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ReviewUpdateWithoutUserInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null;
    review?: NullableStringFieldUpdateOperationsInput | string | null;
    Course?: CourseUpdateOneWithoutReviewNestedInput;
  };

  export type ReviewUncheckedUpdateWithoutUserInput = {
    idReview?: IntFieldUpdateOperationsInput | number;
    idCourse?: NullableIntFieldUpdateOperationsInput | number | null;
    rating?: NullableIntFieldUpdateOperationsInput | number | null;
    review?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    idReview?: IntFieldUpdateOperationsInput | number;
    idCourse?: NullableIntFieldUpdateOperationsInput | number | null;
    rating?: NullableIntFieldUpdateOperationsInput | number | null;
    review?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type StudyRemindUpdateWithoutUserInput = {
    timeRemind?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    typeRemind?: NullableStringFieldUpdateOperationsInput | string | null;
    Course?: CourseUpdateOneWithoutStudyRemindNestedInput;
  };

  export type StudyRemindUncheckedUpdateWithoutUserInput = {
    idStudyRemind?: IntFieldUpdateOperationsInput | number;
    idCourse?: NullableIntFieldUpdateOperationsInput | number | null;
    timeRemind?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    typeRemind?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type StudyRemindUncheckedUpdateManyWithoutUserInput = {
    idStudyRemind?: IntFieldUpdateOperationsInput | number;
    idCourse?: NullableIntFieldUpdateOperationsInput | number | null;
    timeRemind?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    typeRemind?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UserCertificateUpdateWithoutUserInput = {
    Certificate?: CertificateUpdateOneRequiredWithoutUserCertificateNestedInput;
  };

  export type UserCertificateUncheckedUpdateWithoutUserInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
  };

  export type UserCertificateUncheckedUpdateManyWithoutUserInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
  };

  export type UserCouponUpdateWithoutUserInput = {
    Coupon?: CouponUpdateOneRequiredWithoutUserCouponNestedInput;
  };

  export type UserCouponUncheckedUpdateWithoutUserInput = {
    idCoupon?: IntFieldUpdateOperationsInput | number;
  };

  export type UserCouponUncheckedUpdateManyWithoutUserInput = {
    idCoupon?: IntFieldUpdateOperationsInput | number;
  };

  export type WishlistUpdateWithoutUserInput = {
    Course?: CourseUpdateOneRequiredWithoutWishlistNestedInput;
  };

  export type WishlistUncheckedUpdateWithoutUserInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
  };

  export type WishlistUncheckedUpdateManyWithoutUserInput = {
    idCourse?: IntFieldUpdateOperationsInput | number;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
